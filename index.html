<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YASAR-AI KRIPTO ULTRA SCANNER - 50+ Optimize İndikatör + 8 Strateji + 7 Borsa + 15 Feature</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: 
                radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%),
                linear-gradient(135deg, #0a0a1e 0%, #1a1a3e 25%, #2d1b4e 50%, #1a1a3e 75%, #0a0a1e 100%);
            background-size: 100% 100%, 400% 400%;
            animation: gradientShift 15s ease infinite;
            color: #fff;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Yıldızlı Arka Plan KALDIRILDI - Performans için */

        @keyframes twinkle {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        /* Parıldayan Büyük Yıldızlar KALDIRILDI - Performans için */

        @keyframes nebulaGlow {
            0%, 100% { 
                opacity: 0.6;
                transform: scale(1) rotate(0deg);
            }
            33% { 
                opacity: 0.8;
                transform: scale(1.1) rotate(120deg);
            }
            66% { 
                opacity: 0.7;
                transform: scale(0.9) rotate(240deg);
            }
        }

        /* Gezinen Yıldızlar KALDIRILDI - Performans için */

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            padding: 50px 30px;
            background: 
                linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.03) 100%),
                radial-gradient(circle at top left, rgba(255, 215, 0, 0.15) 0%, transparent 50%),
                radial-gradient(circle at bottom right, rgba(78, 205, 196, 0.15) 0%, transparent 50%);
            backdrop-filter: blur(30px) saturate(200%);
            -webkit-backdrop-filter: blur(30px) saturate(200%);
            border-radius: 32px;
            margin-bottom: 40px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 0 100px rgba(255, 215, 0, 0.1);
            position: relative;
            overflow: hidden;
            animation: slideInDown 0.8s ease-out, headerGlow 4s ease-in-out infinite;
        }

        @keyframes headerGlow {
            0%, 100% { box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 0 100px rgba(255, 215, 0, 0.1); }
            50% { box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 0 150px rgba(255, 215, 0, 0.2); }
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .lang-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-weight: bold;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .lang-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .lang-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .lang-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        .lang-btn.active {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            border-color: #ffd700;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4);
            transform: scale(1.05);
        }

        .header h1 {
            font-size: 3em;
            background: linear-gradient(135deg, #ffd700 0%, #ff6b6b 33%, #4ecdc4 66%, #9b59b6 100%);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            animation: gradientText 5s ease infinite;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            position: relative;
            font-weight: 800;
            letter-spacing: 2px;
        }

        @keyframes gradientText {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Premium Icon Hover Effects */
        .premium-icon {
            position: relative;
            cursor: pointer;
        }

        .premium-icon:hover {
            transform: translateY(-5px) scale(1.1);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4);
            animation: iconPulse 1.5s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { transform: translateY(-5px) scale(1.1); }
            50% { transform: translateY(-8px) scale(1.15); }
        }

        /* Kripto Sembol Kartları - Premium Tasarım */
        .crypto-symbol-card {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            animation: float 3s ease-in-out infinite;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .crypto-symbol-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.4s;
        }

        .crypto-symbol-card:hover::before {
            opacity: 1;
        }

        .crypto-symbol-card:hover {
            transform: translateY(-12px) scale(1.08);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7);
            border-color: rgba(255, 255, 255, 0.9);
        }

        .crypto-icon {
            font-size: 4.5em;
            line-height: 1;
            margin-bottom: 10px;
            filter: drop-shadow(0 0 15px currentColor);
            transition: all 0.4s;
            position: relative;
            z-index: 2;
        }

        .crypto-symbol-card:hover .crypto-icon {
            transform: scale(1.2) rotate(10deg);
            filter: drop-shadow(0 0 25px currentColor) drop-shadow(0 0 40px currentColor);
        }

        .crypto-label {
            position: relative;
            z-index: 2;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-size: 0.85em;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-12px) rotate(2deg); }
        }

        @keyframes glow-pulse {
            0%, 100% { filter: drop-shadow(0 0 15px currentColor); }
            50% { filter: drop-shadow(0 0 30px currentColor) drop-shadow(0 0 50px currentColor); }
        }

        .crypto-symbol-card:nth-child(1) { animation-delay: 0s; }
        .crypto-symbol-card:nth-child(1) .crypto-icon { animation: glow-pulse 2s ease-in-out infinite; }
        .crypto-symbol-card:nth-child(2) { animation-delay: 0.4s; }
        .crypto-symbol-card:nth-child(2) .crypto-icon { animation: glow-pulse 2s ease-in-out infinite 0.2s; }
        .crypto-symbol-card:nth-child(3) { animation-delay: 0.8s; }
        .crypto-symbol-card:nth-child(3) .crypto-icon { animation: glow-pulse 2s ease-in-out infinite 0.4s; }
        .crypto-symbol-card:nth-child(4) { animation-delay: 1.2s; }
        .crypto-symbol-card:nth-child(4) .crypto-icon { animation: glow-pulse 2s ease-in-out infinite 0.6s; }
        .crypto-symbol-card:nth-child(5) { animation-delay: 1.6s; }
        .crypto-symbol-card:nth-child(5) .crypto-icon { animation: glow-pulse 2s ease-in-out infinite 0.8s; }

        /* === YENİ 15 FEATURE CSS'LERİ === */
        .new-features-nav {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .new-feature-btn {
            padding: 10px 18px;
            background: rgba(255, 215, 0, 0.08);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-weight: bold;
            color: #ffd700;
            position: relative;
            overflow: hidden;
        }

        .new-feature-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .new-feature-btn:hover::before {
            width: 200px;
            height: 200px;
        }

        .new-feature-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.08) translateY(-2px);
            box-shadow: 0 8px 16px rgba(255, 215, 0, 0.3);
        }

        .new-feature-btn.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 107, 107, 0.3));
            border-color: rgba(255, 215, 0, 0.6);
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4);
            transform: scale(1.05);
        }

        .new-feature-content {
            display: none;
            background: rgba(0, 0, 0, 0.4);
            padding: 30px;
            border-radius: 15px;
            margin-top: 30px;
            border: 2px solid rgba(255, 215, 0, 0.2);
        }

        .new-feature-content.active {
            display: block;
        }

        /* CoinMarketCap Style Heatmap */
        .heatmap-container {
            margin-bottom: 30px;
        }

        .heatmap-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .heatmap-cell {
            padding: 12px 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.4);
        }

        .heatmap-cell:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .heatmap-cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.85;
            transition: opacity 0.3s;
        }

        .heatmap-cell:hover::before {
            opacity: 1;
        }

        /* Dinamik renk skalası - CoinMarketCap stili */
        .heatmap-cell-positive-0 { background: linear-gradient(135deg, rgba(76, 175, 80, 0.15), rgba(76, 175, 80, 0.05)); }
        .heatmap-cell-positive-0::before { background: rgba(76, 175, 80, 0.2); }
        .heatmap-cell-positive-1 { background: linear-gradient(135deg, rgba(76, 175, 80, 0.35), rgba(76, 175, 80, 0.15)); }
        .heatmap-cell-positive-1::before { background: rgba(76, 175, 80, 0.4); }
        .heatmap-cell-positive-2 { background: linear-gradient(135deg, rgba(76, 175, 80, 0.55), rgba(76, 175, 80, 0.25)); }
        .heatmap-cell-positive-2::before { background: rgba(76, 175, 80, 0.6); }
        .heatmap-cell-positive-3 { background: linear-gradient(135deg, rgba(76, 175, 80, 0.75), rgba(76, 175, 80, 0.35)); }
        .heatmap-cell-positive-3::before { background: rgba(76, 175, 80, 0.8); }
        .heatmap-cell-positive-4 { background: linear-gradient(135deg, rgba(76, 175, 80, 0.95), rgba(76, 175, 80, 0.45)); }
        .heatmap-cell-positive-4::before { background: rgba(76, 175, 80, 1); }

        .heatmap-cell-negative-0 { background: linear-gradient(135deg, rgba(244, 67, 54, 0.15), rgba(244, 67, 54, 0.05)); }
        .heatmap-cell-negative-0::before { background: rgba(244, 67, 54, 0.2); }
        .heatmap-cell-negative-1 { background: linear-gradient(135deg, rgba(244, 67, 54, 0.35), rgba(244, 67, 54, 0.15)); }
        .heatmap-cell-negative-1::before { background: rgba(244, 67, 54, 0.4); }
        .heatmap-cell-negative-2 { background: linear-gradient(135deg, rgba(244, 67, 54, 0.55), rgba(244, 67, 54, 0.25)); }
        .heatmap-cell-negative-2::before { background: rgba(244, 67, 54, 0.6); }
        .heatmap-cell-negative-3 { background: linear-gradient(135deg, rgba(244, 67, 54, 0.75), rgba(244, 67, 54, 0.35)); }
        .heatmap-cell-negative-3::before { background: rgba(244, 67, 54, 0.8); }
        .heatmap-cell-negative-4 { background: linear-gradient(135deg, rgba(244, 67, 54, 0.95), rgba(244, 67, 54, 0.45)); }
        .heatmap-cell-negative-4::before { background: rgba(244, 67, 54, 1); }

        .heatmap-cell-neutral {
            background: linear-gradient(135deg, rgba(128, 128, 128, 0.2), rgba(128, 128, 128, 0.1));
        }

        .heatmap-coin-symbol {
            font-size: 0.95em;
            font-weight: 700;
            margin-bottom: 6px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .heatmap-change {
            font-size: 1.15em;
            font-weight: 800;
            margin-bottom: 4px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
        }

        .heatmap-price {
            font-size: 0.8em;
            opacity: 0.85;
            color: #ddd;
            margin-top: 4px;
        }

        .heatmap-volume {
            font-size: 0.7em;
            opacity: 0.7;
            color: #bbb;
            margin-top: 2px;
        }

        /* Heatmap legend */
        .heatmap-legend {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            flex-wrap: wrap;
        }

        .heatmap-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }

        .heatmap-legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Smart Money */
        .smart-money-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .smart-money-card {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #4ecdc4;
        }

        /* Liquidation */
        .liquidation-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .liq-item {
            background: rgba(255, 107, 107, 0.1);
            padding: 15px;
            border-left: 4px solid #ff6b6b;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
        }

        /* Fear & Greed */
        .fear-greed-meter {
            width: 100%;
            height: 40px;
            background: linear-gradient(90deg, #f44336, #ff9800, #ffd700, #8bc34a, #4caf50);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            margin: 20px 0;
        }

        .fear-greed-pointer {
            position: absolute;
            top: 0;
            width: 4px;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        .header p {
            color: #aaa;
            font-size: 1.1em;
        }

        .api-status {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .api-badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .api-connected {
            background: rgba(78, 205, 196, 0.3);
            border: 1px solid #4ecdc4;
        }

        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .nav-tab {
            padding: 18px 35px;
            background: rgba(255, 255, 255, 0.06);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .nav-tab::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 0;
            height: 3px;
            background: linear-gradient(90deg, #ffd700, #4ecdc4);
            transform: translateX(-50%);
            transition: width 0.4s ease;
        }

        .nav-tab:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .nav-tab.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 107, 107, 0.2));
            border-color: rgba(255, 215, 0, 0.5);
            box-shadow: 0 8px 32px rgba(255, 215, 0, 0.3);
            transform: translateY(-2px);
        }

        .nav-tab.active::after {
            width: 80%;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: fadeInUp 0.6s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #ffd700;
        }

        .timeframe-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .timeframe-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.06);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .timeframe-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(78, 205, 196, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .timeframe-btn:hover::before {
            width: 200px;
            height: 200px;
        }

        .timeframe-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        .timeframe-btn.active {
            background: linear-gradient(135deg, #4ecdc4, #2a9d8f);
            border-color: #4ecdc4;
            box-shadow: 0 4px 20px rgba(78, 205, 196, 0.4);
            transform: scale(1.05);
        }

        .scan-button {
            width: 100%;
            padding: 25px;
            font-size: 1.6em;
            font-weight: 800;
            background: linear-gradient(135deg, #ff6b6b 0%, #ffd700 50%, #4ecdc4 100%);
            background-size: 200% 200%;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: #000;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.3);
            animation: buttonGlow 3s ease infinite;
            letter-spacing: 1px;
        }

        .scan-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .scan-button:hover::before {
            width: 400px;
            height: 400px;
        }

        .scan-button:hover {
            transform: scale(1.03) translateY(-3px);
            box-shadow: 0 20px 60px rgba(255, 215, 0, 0.5);
            background-position: 100% 50%;
        }

        .scan-button:active {
            transform: scale(0.98);
        }

        .scan-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            animation: none;
        }

        @keyframes buttonGlow {
            0%, 100% { 
                box-shadow: 0 10px 40px rgba(255, 215, 0, 0.3);
            }
            50% { 
                box-shadow: 0 10px 50px rgba(255, 215, 0, 0.5);
            }
        }

        .stats-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px) saturate(180%);
            padding: 25px;
            border-radius: 18px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.4s;
        }

        .stat-card:hover::before {
            opacity: 1;
        }

        .stat-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            color: #aaa;
            margin-top: 10px;
        }

        .strategy-card {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .strategy-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .strategy-icon {
            font-size: 2em;
        }

        .indicator-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .category-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px) saturate(180%);
            padding: 25px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .category-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.25);
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .category-title {
            font-size: 1.2em;
            font-weight: bold;
        }

        .category-count {
            background: #ffd700;
            color: #000;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .indicator-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .indicator-item {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .exchange-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .exchange-card {
            padding: 25px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 18px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .exchange-card::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .exchange-card:hover::before {
            width: 300px;
            height: 300px;
        }

        .exchange-card:hover {
            border-color: rgba(255, 215, 0, 0.5);
            transform: translateY(-8px) scale(1.03);
            box-shadow: 0 16px 48px rgba(255, 215, 0, 0.3);
        }

        .exchange-card.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 107, 107, 0.15));
            border-color: rgba(255, 215, 0, 0.6);
            box-shadow: 0 12px 40px rgba(255, 215, 0, 0.4);
            transform: scale(1.05);
        }

        .exchange-logo {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .results-container {
            display: grid;
            gap: 20px;
        }

        .result-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px) saturate(180%);
            padding: 30px;
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            animation: fadeInUp 0.6s ease-out;
        }

        .result-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .result-card:hover::before {
            left: 100%;
        }

        .result-card:hover {
            border-color: rgba(255, 215, 0, 0.8);
            transform: translateY(-15px) scale(1.03);
            box-shadow: 
                0 25px 70px rgba(255, 215, 0, 0.4),
                0 0 30px rgba(255, 215, 0, 0.3),
                inset 0 0 20px rgba(255, 215, 0, 0.1);
            cursor: pointer;
            animation: pulse 0.5s ease-out;
        }

        /* Detaylı Coin Analiz Modal */
        .coin-detail-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            z-index: 10000;
            overflow-y: auto;
            animation: fadeIn 0.3s ease;
        }

        .coin-detail-modal.active {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            max-width: 1600px;
            margin: 20px auto;
            padding: 30px;
            background: rgba(26, 26, 62, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 24px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.5);
            position: relative;
            animation: slideUp 0.4s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 107, 107, 0.2);
            border: 2px solid #ff6b6b;
            border-radius: 50%;
            color: #ff6b6b;
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .modal-close:hover {
            background: #ff6b6b;
            color: white;
            transform: rotate(90deg);
        }

        .detail-section {
            background: rgba(0, 0, 0, 0.3);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border-left: 4px solid #ffd700;
        }

        .detail-title {
            font-size: 1.8em;
            color: #ffd700;
            margin-bottom: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .fibonacci-levels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .fib-level {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border-left: 3px solid;
            transition: all 0.3s;
        }

        .fib-level:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }

        .fib-236 { border-left-color: #ff6b6b; }
        .fib-382 { border-left-color: #ff9500; }
        .fib-500 { border-left-color: #ffd700; }
        .fib-618 { border-left-color: #4ecdc4; }
        .fib-786 { border-left-color: #9b59b6; }

        .trade-level {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 2px solid;
            transition: all 0.3s;
        }

        .trade-level:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4);
        }

        .level-entry { border-color: #4ecdc4; }
        .level-tp { border-color: #4ecdc4; }
        .level-sl { border-color: #ff6b6b; }

        .indicator-summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .indicator-summary-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid;
            text-align: center;
        }

        .summary-long { border-color: #4ecdc4; background: rgba(78, 205, 196, 0.1); }
        .summary-neutral { border-color: #ffd700; background: rgba(255, 215, 0, 0.1); }
        .summary-short { border-color: #ff6b6b; background: rgba(255, 107, 107, 0.1); }

        .summary-number {
            font-size: 3em;
            font-weight: bold;
            margin: 10px 0;
        }

        .summary-label {
            font-size: 1.1em;
            opacity: 0.8;
            margin-top: 10px;
        }

        /* LONG ve SHORT Ayrı Bölümler */
        .results-sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        /* Mobilde tek sütun */
        @media (max-width: 1200px) {
            .results-sections {
                grid-template-columns: 1fr;
            }
        }

        .result-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 20px;
            padding: 30px;
            border: 2px solid;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            min-height: 400px;
        }

        .long-section {
            border-color: rgba(78, 205, 196, 0.5);
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(44, 160, 141, 0.05));
        }

        .short-section {
            border-color: rgba(255, 107, 107, 0.5);
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(231, 76, 60, 0.05));
        }

        .wait-section {
            border-color: rgba(255, 215, 0, 0.5);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 193, 7, 0.05));
            grid-column: 1 / -1; /* Full width */
        }

        .section-header {
            text-align: center;
            padding: 20px;
            margin-bottom: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .long-header {
            background: rgba(78, 205, 196, 0.15);
            border: 2px solid rgba(78, 205, 196, 0.4);
        }

        .short-header {
            background: rgba(255, 107, 107, 0.15);
            border: 2px solid rgba(255, 107, 107, 0.4);
        }

        .wait-header {
            background: rgba(255, 215, 0, 0.15);
            border: 2px solid rgba(255, 215, 0, 0.4);
        }

        .section-header h2 {
            font-size: 2.5em;
            margin-bottom: 15px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .long-header h2 {
            color: #4ecdc4;
        }

        .short-header h2 {
            color: #ff6b6b;
        }

        .wait-header h2 {
            color: #ffd700;
        }

        .section-count {
            font-size: 1.5em;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: inline-block;
        }

        .long-header .section-count {
            color: #4ecdc4;
            border: 2px solid rgba(78, 205, 196, 0.5);
        }

        .short-header .section-count {
            color: #ff6b6b;
            border: 2px solid rgba(255, 107, 107, 0.5);
        }

        .wait-header .section-count {
            color: #ffd700;
            border: 2px solid rgba(255, 215, 0, 0.5);
        }

        .section-description {
            font-size: 1em;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 10px;
            font-style: italic;
        }

        /* MODERN ANİMASYONLAR VE EFEKTLER */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes glow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.3),
                            0 0 40px rgba(255, 215, 0, 0.2),
                            0 0 60px rgba(255, 215, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.5),
                            0 0 60px rgba(255, 215, 0, 0.4),
                            0 0 90px rgba(255, 215, 0, 0.3);
            }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes shimmerText {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        @keyframes rotateGlow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        @keyframes numberCount {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* Result Card Animasyonları */
        .result-card {
            animation: fadeInUp 0.6s ease-out backwards;
        }

        .result-card:nth-child(1) { animation-delay: 0.1s; }
        .result-card:nth-child(2) { animation-delay: 0.2s; }
        .result-card:nth-child(3) { animation-delay: 0.3s; }
        .result-card:nth-child(4) { animation-delay: 0.4s; }
        .result-card:nth-child(5) { animation-delay: 0.5s; }
        .result-card:nth-child(n+6) { animation-delay: 0.6s; }

        /* Section Animasyonları */
        .result-section {
            animation: slideInRight 0.8s ease-out;
        }

        .long-section {
            animation-delay: 0.1s;
        }

        .short-section {
            animation-delay: 0.3s;
        }

        /* Pulse Efektleri */
        .section-header h2 {
            animation: pulse 2s ease-in-out infinite;
        }

        .section-count {
            animation: numberCount 1s ease-out;
        }

        /* Glow Efektleri */
        .long-header {
            animation: glow 3s ease-in-out infinite;
        }

        .short-header {
            animation: glow 3s ease-in-out infinite 1.5s;
        }

        /* Float Animasyonu */
        .stat-card {
            animation: float 3s ease-in-out infinite;
        }

        .stat-card:nth-child(2) { animation-delay: 0.5s; }
        .stat-card:nth-child(3) { animation-delay: 1s; }
        .stat-card:nth-child(4) { animation-delay: 1.5s; }

        /* Scan Button Özel Animasyon */
        .scan-button {
            position: relative;
            overflow: hidden;
        }

        .scan-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .scan-button:hover::before {
            width: 300px;
            height: 300px;
        }

        .scan-button:active {
            animation: pulse 0.3s;
        }

        /* Loading Spinner Gelişmiş */
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 215, 0, 0.2);
            border-top-color: #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite, glow 2s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Progress Bar Animasyon */
        .progress-bar {
            transition: width 0.5s ease-out;
            background: linear-gradient(90deg, #ffd700, #4ecdc4, #ffd700);
            background-size: 200% 100%;
            animation: shimmerProgress 2s linear infinite;
        }

        @keyframes shimmerProgress {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Indicator Summary Cards Animasyon */
        .indicator-summary-card {
            transition: all 0.3s ease;
            animation: fadeInUp 0.8s ease-out backwards;
        }

        .indicator-summary-card:nth-child(1) { animation-delay: 0.2s; }
        .indicator-summary-card:nth-child(2) { animation-delay: 0.4s; }
        .indicator-summary-card:nth-child(3) { animation-delay: 0.6s; }

        .indicator-summary-card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 20px 40px rgba(255, 215, 0, 0.4);
        }

        /* Summary Number Animasyon */
        .summary-number {
            animation: numberCount 1.5s ease-out, pulse 2s ease-in-out infinite 1.5s;
        }

        /* Detail Section Animasyon */
        .detail-section {
            animation: fadeInUp 0.6s ease-out;
        }

        .detail-section:nth-child(1) { animation-delay: 0.1s; }
        .detail-section:nth-child(2) { animation-delay: 0.2s; }
        .detail-section:nth-child(3) { animation-delay: 0.3s; }
        .detail-section:nth-child(4) { animation-delay: 0.4s; }

        /* Fibonacci Levels Animasyon */
        .fib-level {
            animation: fadeInUp 0.5s ease-out backwards;
        }

        .fib-level:nth-child(1) { animation-delay: 0.1s; }
        .fib-level:nth-child(2) { animation-delay: 0.2s; }
        .fib-level:nth-child(3) { animation-delay: 0.3s; }
        .fib-level:nth-child(4) { animation-delay: 0.4s; }
        .fib-level:nth-child(5) { animation-delay: 0.5s; }

        /* Trade Level Animasyon */
        .trade-level {
            animation: slideInRight 0.5s ease-out backwards;
        }

        .trade-level:nth-child(1) { animation-delay: 0.1s; }
        .trade-level:nth-child(2) { animation-delay: 0.2s; }
        .trade-level:nth-child(3) { animation-delay: 0.3s; }
        .trade-level:nth-child(4) { animation-delay: 0.4s; }
        .trade-level:nth-child(5) { animation-delay: 0.5s; }

        /* Master Signal Animasyon */
        .master-signal {
            animation: fadeInUp 0.8s ease-out, glow 3s ease-in-out infinite 1s;
        }

        /* Result Card Grid Animasyon */
        .results-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 25px;
            animation: fadeIn 0.5s ease-out;
        }

        /* Modal Animasyonları */
        .modal-content {
            animation: fadeInUp 0.5s ease-out, glow 4s ease-in-out infinite 0.5s;
        }

        /* Nav Tab Hover Animasyon */
        .nav-tab {
            position: relative;
            overflow: hidden;
        }

        .nav-tab::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 0;
            height: 3px;
            background: linear-gradient(90deg, #ffd700, #4ecdc4);
            transform: translateX(-50%);
            transition: width 0.3s ease;
        }

        .nav-tab:hover::after,
        .nav-tab.active::after {
            width: 80%;
        }

        /* Stat Card Hover */
        .stat-card:hover {
            transform: translateY(-15px) scale(1.05);
            box-shadow: 0 20px 60px rgba(255, 215, 0, 0.4);
            animation: pulse 0.5s ease-out;
        }

        /* Coin Header Animasyon */
        .coin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .coin-name {
            font-size: 1.8em;
            font-weight: bold;
        }

        .coin-price {
            font-size: 1.4em;
            color: #4ecdc4;
            font-weight: bold;
        }

        .price-change {
            font-size: 0.9em;
            margin-top: 5px;
        }

        .price-up {
            color: #4ecdc4;
        }

        .price-down {
            color: #ff6b6b;
        }

        .master-signal {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
            border: 3px solid;
        }

        .signal-long {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }

        .signal-short {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .signal-neutral {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .signal-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .trade-setup {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .setup-title {
            font-size: 1.3em;
            color: #ffd700;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .setup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .setup-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }

        .setup-label {
            color: #aaa;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .setup-value {
            font-size: 1.2em;
            font-weight: bold;
        }

        .value-long {
            color: #4ecdc4;
        }

        .value-short {
            color: #ff6b6b;
        }

        .value-neutral {
            color: #ffd700;
        }

        .indicator-signals {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .signals-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .signal-column {
            padding: 15px;
            border-radius: 10px;
        }

        .signal-buy {
            background: rgba(78, 205, 196, 0.2);
            border: 2px solid #4ecdc4;
        }

        .signal-sell {
            background: rgba(255, 107, 107, 0.2);
            border: 2px solid #ff6b6b;
        }

        .signal-wait {
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #ffd700;
        }

        .signal-column h4 {
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .signal-list {
            list-style: none;
            font-size: 0.9em;
            line-height: 1.8;
        }

        .fibonacci-levels {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .fib-level {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid;
        }

        .fib-level.support {
            border-left-color: #4ecdc4;
        }

        .fib-level.resistance {
            border-left-color: #ff6b6b;
        }

        .market-participants {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .participant-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .participant-name {
            font-weight: bold;
        }

        .participant-action {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .action-buying {
            background: rgba(78, 205, 196, 0.3);
            color: #4ecdc4;
        }

        .action-selling {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
        }

        .action-neutral {
            background: rgba(255, 215, 0, 0.3);
            color: #ffd700;
        }

        .ai-analysis {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.3), rgba(0, 0, 0, 0.5));
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 2px solid rgba(138, 43, 226, 0.5);
        }

        .ai-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .ai-logo {
            font-size: 2.5em;
        }

        .ai-content {
            line-height: 1.8;
            font-size: 1.05em;
        }

        .ai-recommendation {
            background: rgba(255, 215, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ffd700;
            margin-top: 15px;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.5em;
        }

        .spinner {
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-top: 5px solid #ffd700;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #ffd700;
            border-radius: 10px;
        }

        @media (max-width: 768px) {
            .signals-grid {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 1.8em;
            }
            .language-selector {
                position: relative;
                top: 0;
                right: 0;
                justify-content: center;
                margin-bottom: 15px;
            }
        }
    </style>
</head>
<body>
    <!-- Shooting Stars KALDIRILDI - Performans için -->
    
    <div class="container">
        <div class="header">
            <div class="language-selector">
                <button class="lang-btn active" onclick="changeLanguage('tr', event)">🇹🇷 TR</button>
                <button class="lang-btn" onclick="changeLanguage('de', event)">🇩🇪 DE</button>
            </div>
            
            <!-- Premium Header Section -->
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">
                <!-- Sol Taraf: Para ve Ödüller -->
                <div style="display: flex; align-items: center; gap: 15px; flex: 1; justify-content: center; min-width: 300px;">
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <div class="premium-icon" style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1)); border: 2px solid rgba(255, 215, 0, 0.5); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); transition: all 0.3s;">
                            <div style="font-size: 2em; filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.6));">💰</div>
                        </div>
                        <div class="premium-icon" style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1)); border: 2px solid rgba(78, 205, 196, 0.5); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); transition: all 0.3s;">
                            <div style="font-size: 2em; filter: drop-shadow(0 0 10px rgba(78, 205, 196, 0.6));">💶</div>
                        </div>
                        <div class="premium-icon" style="background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 107, 107, 0.1)); border: 2px solid rgba(255, 107, 107, 0.5); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); transition: all 0.3s;">
                            <div style="font-size: 2em; filter: drop-shadow(0 0 10px rgba(255, 107, 107, 0.6));">💷</div>
                        </div>
                        <div class="premium-icon" style="background: linear-gradient(135deg, rgba(255, 149, 0, 0.2), rgba(255, 149, 0, 0.1)); border: 2px solid rgba(255, 149, 0, 0.5); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); transition: all 0.3s;">
                            <div style="font-size: 2em; filter: drop-shadow(0 0 10px rgba(255, 149, 0, 0.6));">₿</div>
                        </div>
                    </div>
                </div>
                
                <!-- Orta: Başlık -->
                <div style="flex: 1; text-align: center; min-width: 300px;">
                    <h1 style="margin: 0; font-size: 2.8em; background: linear-gradient(135deg, #ffd700 0%, #ff6b6b 33%, #4ecdc4 66%, #9b59b6 100%); background-size: 300% 300%; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; animation: gradientText 5s ease infinite; font-weight: 800; letter-spacing: 3px; text-shadow: 0 0 40px rgba(255, 215, 0, 0.4);">YASAR-AI KRIPTO ULTRA SCANNER</h1>
                </div>
                
                <!-- Sağ Taraf: Ödüller -->
                <div style="display: flex; align-items: center; gap: 15px; flex: 1; justify-content: center; min-width: 300px;">
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <div class="premium-icon" style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1)); border: 2px solid rgba(255, 215, 0, 0.5); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); transition: all 0.3s;">
                            <div style="font-size: 2em; filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.6));">🥇</div>
                        </div>
                        <div class="premium-icon" style="background: linear-gradient(135deg, rgba(155, 89, 182, 0.2), rgba(155, 89, 182, 0.1)); border: 2px solid rgba(155, 89, 182, 0.5); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); transition: all 0.3s;">
                            <div style="font-size: 2em; filter: drop-shadow(0 0 10px rgba(155, 89, 182, 0.6));">💎</div>
                        </div>
                        <div class="premium-icon" style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1)); border: 2px solid rgba(78, 205, 196, 0.5); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); transition: all 0.3s;">
                            <div style="font-size: 2em; filter: drop-shadow(0 0 10px rgba(78, 205, 196, 0.6));">⚡</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Premium Kripto Sembolleri ve Para/Dolar Galerisi -->
            <div style="display: flex; justify-content: center; gap: 25px; margin-bottom: 25px; flex-wrap: wrap;">
                <div class="crypto-symbol-card" style="background: linear-gradient(135deg, rgba(247, 147, 26, 0.3), rgba(247, 147, 26, 0.15)); border: 3px solid rgba(247, 147, 26, 0.7); border-radius: 24px; padding: 30px; backdrop-filter: blur(20px); width: 190px; height: 160px; box-shadow: 0 10px 40px rgba(247, 147, 26, 0.4), inset 0 0 30px rgba(247, 147, 26, 0.1);">
                    <div class="crypto-icon" style="color: #f7931a;">🪙</div>
                    <div class="crypto-label" style="color: #f7931a;">BITCOIN</div>
                </div>
                <div class="crypto-symbol-card" style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.3), rgba(78, 205, 196, 0.15)); border: 3px solid rgba(78, 205, 196, 0.7); border-radius: 24px; padding: 30px; backdrop-filter: blur(20px); width: 190px; height: 160px; box-shadow: 0 10px 40px rgba(78, 205, 196, 0.4), inset 0 0 30px rgba(78, 205, 196, 0.1);">
                    <div class="crypto-icon" style="color: #4ecdc4;">💎</div>
                    <div class="crypto-label" style="color: #4ecdc4;">ETHEREUM</div>
                </div>
                <div class="crypto-symbol-card" style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.15)); border: 3px solid rgba(255, 215, 0, 0.7); border-radius: 24px; padding: 30px; backdrop-filter: blur(20px); width: 190px; height: 160px; box-shadow: 0 10px 40px rgba(255, 215, 0, 0.4), inset 0 0 30px rgba(255, 215, 0, 0.1);">
                    <div class="crypto-icon" style="color: #ffd700;">💵</div>
                    <div class="crypto-label" style="color: #ffd700;">US DOLLAR</div>
                </div>
                <div class="crypto-symbol-card" style="background: linear-gradient(135deg, rgba(255, 107, 107, 0.3), rgba(255, 107, 107, 0.15)); border: 3px solid rgba(255, 107, 107, 0.7); border-radius: 24px; padding: 30px; backdrop-filter: blur(20px); width: 190px; height: 160px; box-shadow: 0 10px 40px rgba(255, 107, 107, 0.4), inset 0 0 30px rgba(255, 107, 107, 0.1);">
                    <div class="crypto-icon" style="color: #ff6b6b;">⚡</div>
                    <div class="crypto-label" style="color: #ff6b6b;">SOLANA</div>
                </div>
                <div class="crypto-symbol-card" style="background: linear-gradient(135deg, rgba(155, 89, 182, 0.3), rgba(155, 89, 182, 0.15)); border: 3px solid rgba(155, 89, 182, 0.7); border-radius: 24px; padding: 30px; backdrop-filter: blur(20px); width: 190px; height: 160px; box-shadow: 0 10px 40px rgba(155, 89, 182, 0.4), inset 0 0 30px rgba(155, 89, 182, 0.1);">
                    <div class="crypto-icon" style="color: #9b59b6;">💶</div>
                    <div class="crypto-label" style="color: #9b59b6;">EURO</div>
            </div>
            </div>
            <p style="margin-top: 10px;">YASAR-AI KRIPTO ULTRA SCANNER (50+ Optimize İndikatör | 8 Strateji | 7 Borsa) + 15 YENİ FEATURE | Fear & Greed</p>
            
            <!-- Coin Arama -->
            <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: center; align-items: center; flex-wrap: wrap;">
                <input type="text" id="coinSearchInput" placeholder="🔍 Coin ara (örn: BTC, ETH, SOL, KGEN)..." 
                       style="padding: 15px 20px; min-width: 300px; max-width: 500px; background: rgba(0,0,0,0.4); 
                              border: 2px solid rgba(255,215,0,0.3); border-radius: 25px; color: #fff; font-size: 1.1em;
                              transition: all 0.3s; outline: none;"
                       onkeypress="if(event.key === 'Enter') searchAndAnalyzeCoin(event)"
                       oninput="debounceSearch(this.value)">
                <button onclick="searchAndAnalyzeCoin(event)" 
                        style="padding: 15px 30px; background: linear-gradient(45deg, #4ecdc4, #44a08d); 
                               border: none; border-radius: 25px; color: #fff; font-weight: bold; 
                               cursor: pointer; font-size: 1.1em; box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
                               transition: all 0.3s;"
                        onmouseover="this.style.transform='scale(1.05)'" 
                        onmouseout="this.style.transform='scale(1)'">
                    📊 Analiz Et
                </button>
            </div>
            <div id="coinSearchResults" style="margin-top: 15px; max-height: 200px; overflow-y: auto; display: none; 
                                                background: rgba(0,0,0,0.5); border-radius: 15px; padding: 10px;"></div>

            <div class="new-features-nav">
                <button class="new-feature-btn active" onclick="switchNewFeature('heatmap', event)">🌡️ Heatmap</button>
                <button class="new-feature-btn" onclick="switchNewFeature('smartmoney', event)">🐋 Smart Money</button>
                <button class="new-feature-btn" onclick="switchNewFeature('liquidation', event)">⚠️ Liquidation</button>
                <button class="new-feature-btn" onclick="switchNewFeature('onchain', event)">⛓️ On-Chain</button>
                <button class="new-feature-btn" onclick="switchNewFeature('funding', event)">📊 Funding</button>
                <button class="new-feature-btn" onclick="switchNewFeature('sr', event)">📍 S/R</button>
                <button class="new-feature-btn" onclick="switchNewFeature('divergence', event)">🔀 Divergence</button>
                <button class="new-feature-btn" onclick="switchNewFeature('volume', event)">📈 Volume</button>
                <button class="new-feature-btn" onclick="switchNewFeature('session', event)">🌍 Session</button>
                <button class="new-feature-btn" onclick="switchNewFeature('risk', event)">💎 Risk</button>
                <button class="new-feature-btn" onclick="switchNewFeature('backtest', event)">⚙️ Backtest</button>
                <button class="new-feature-btn" onclick="switchNewFeature('news', event)">📰 News</button>
                <button class="new-feature-btn" onclick="switchNewFeature('options', event)">📞 Options</button>
                <button class="new-feature-btn" onclick="switchNewFeature('fear', event)">😨 Fear & Greed</button>
                <button class="new-feature-btn" onclick="switchNewFeature('multitf', event)">⏱️ Multi-TF</button>
                <button class="new-feature-btn" onclick="switchNewFeature('openinterest', event)">📊 Open Interest</button>
                <button class="new-feature-btn" onclick="switchNewFeature('longshort', event)">⚖️ Long/Short</button>
                <button class="new-feature-btn" onclick="switchNewFeature('marketdepth', event)">📈 Depth</button>
                <button class="new-feature-btn" onclick="switchNewFeature('whaletrades', event)">🐋 Whales</button>
                <button class="new-feature-btn" onclick="switchNewFeature('correlation', event)">🔗 Correlation</button>
                <button class="new-feature-btn" onclick="switchNewFeature('alerts', event)">🔔 Alerts</button>
            </div>
        </div>

        <div class="nav-tabs">
            <div class="nav-tab active" onclick="switchTab('home', event)">🏠 Ana Sayfa</div>
            <div class="nav-tab" onclick="switchTab('indicators', event)">📊 İndikatörler (50+ Premium)</div>
            <div class="nav-tab" onclick="switchTab('exchanges', event)">💱 Borsalar (7)</div>
            <div class="nav-tab" onclick="switchTab('strategies', event)">🎯 Stratejiler (8)</div>
            <div class="nav-tab" onclick="switchTab('tradingtools', event)">⚙️ İşlem Araçları</div>
            <div class="nav-tab" onclick="switchTab('dashboard', event)">🎯 AI Trading Dashboard</div>
            <div class="nav-tab" onclick="switchTab('results', event)">📈 Sonuçlar</div>
        </div>

        <!-- ANA SAYFA -->
        <div id="home" class="tab-content active">
            <div class="control-panel">
                <div class="control-group">
                    <label>⏰ Zaman Dilimi:</label>
                    <div class="timeframe-selector">
                        <div class="timeframe-btn" onclick="selectTimeframe('1m', event)">1m</div>
                        <div class="timeframe-btn" onclick="selectTimeframe('5m', event)">5m</div>
                        <div class="timeframe-btn active" onclick="selectTimeframe('15m', event)">15m</div>
                        <div class="timeframe-btn" onclick="selectTimeframe('30m', event)">30m</div>
                        <div class="timeframe-btn" onclick="selectTimeframe('1h', event)">1h</div>
                        <div class="timeframe-btn" onclick="selectTimeframe('4h', event)">4h</div>
                        <div class="timeframe-btn" onclick="selectTimeframe('1d', event)">1D</div>
                    </div>
                </div>

                <div class="control-group">
                    <label>🎯 Minimum Skor: <span id="minScoreValue">70</span></label>
                    <input type="range" id="minScore" min="0" max="100" value="70" 
                           style="width: 100%;" oninput="updateMinScore(this.value)">
                </div>
            </div>

            <button class="scan-button" onclick="startScan()" id="scanButton">
                🔍 GERÇEK ZAMANLI AI TARAMA BAŞLAT 🚀
            </button>

            <div class="stats-overview">
                <div class="stat-card">
                    <div class="stat-value" id="totalCoins">0</div>
                    <div class="stat-label">Taranan Coin</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="bullishSignals" style="color: #4ecdc4;">0</div>
                    <div class="stat-label">🟢 LONG Sinyali</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="bearishSignals" style="color: #ff6b6b;">0</div>
                    <div class="stat-label">🔴 SHORT Sinyali</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="neutralSignals" style="color: #ffd700;">0</div>
                    <div class="stat-label">⚪ Bekle</div>
                </div>
            </div>
        </div>

        <!-- İNDİKATÖRLER -->
        <div id="indicators" class="tab-content">
            <div class="indicator-categories" id="indicatorCategories"></div>
        </div>

        <!-- BORSALAR -->
        <div id="exchanges" class="tab-content">
            <h2 style="margin-bottom: 20px; text-align: center;">Desteklenen Borsalar</h2>
            <div class="exchange-grid" id="exchangeGrid"></div>
        </div>

        <!-- STRATEJİLER - GENIŞLET İLMİŞ -->
        <div id="strategies" class="tab-content">
            <h2 style="text-align: center; margin-bottom: 30px; font-size: 2em; color: #ffd700;">
                🎯 8 PROFESYONEL STRATEJİ - DETAYLI KILAVUZ
            </h2>

            <!-- 1. FİBONACCI -->
            <div class="strategy-card">
                <div class="strategy-header">
                    <div class="strategy-icon">💎</div>
                    <div style="flex: 1;">
                        <h3 style="font-size: 1.5em; margin-bottom: 5px;">1. Fibonacci Golden Zone Stratejisi</h3>
                        <p style="color: #aaa;">Altın Oran (0.618) | Win Rate: 75-80% | Risk/Reward: 1:3</p>
                    </div>
                </div>
                <div style="padding: 20px; background: rgba(255,255,255,0.03); border-radius: 10px; margin-top: 15px;">
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">📊 Kullanılan İndikatörler:</strong>
                        <div style="margin-top: 10px; line-height: 1.8; padding-left: 15px;">
                            • Auto Fibonacci Retracement<br>
                            • Fibonacci Extension (161.8%, 261.8%)<br>
                            • EMA 21/50 (Trend konfirmasyonu)<br>
                            • RSI (30-70 aralığı)<br>
                            • Volume Profile (POC onayı)
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #4ecdc4; font-size: 1.1em;">✅ LONG Giriş Kriterleri:</strong>
                        <div style="margin-top: 10px; line-height: 2; padding-left: 15px;">
                            <strong>1.</strong> Fiyat 0.618 (Golden Zone) seviyesine gelir<br>
                            <strong>2.</strong> RSI 40-50 arasında (oversold değil)<br>
                            <strong>3.</strong> EMA 21 > EMA 50 (uptrend)<br>
                            <strong>4.</strong> Volume artışı (1.5x ortalama)<br>
                            <strong>5.</strong> Bullish candlestick pattern (hammer, engulfing)
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ff6b6b; font-size: 1.1em;">❌ SHORT Giriş Kriterleri:</strong>
                        <div style="margin-top: 10px; line-height: 2; padding-left: 15px;">
                            <strong>1.</strong> Fiyat 0.382 seviyesinde reject edilir<br>
                            <strong>2.</strong> RSI 50-60 arasında<br>
                            <strong>3.</strong> EMA 21 < EMA 50 (downtrend)<br>
                            <strong>4.</strong> Volume artışı ile rejection<br>
                            <strong>5.</strong> Bearish pattern (shooting star, dark cloud)
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">🎯 Çıkış Stratejisi:</strong>
                        <div style="margin-top: 10px; line-height: 2; padding-left: 15px;">
                            • <strong>Stop Loss:</strong> 0.786 seviyesinin altı/üstü<br>
                            • <strong>TP1:</strong> 0.382 seviyesi (1:1 RR)<br>
                            • <strong>TP2:</strong> 0 seviyesi - Previous high/low (1:2 RR)<br>
                            • <strong>TP3:</strong> Fibonacci Extension 1.618 (1:3 RR)<br>
                            • <strong>Break-even:</strong> TP1'de stop loss'u entry'ye çek
                        </div>
                    </div>
                    <div style="background: rgba(255,215,0,0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ffd700;">
                        <strong style="color: #ffd700;">💡 PRO TİP:</strong> En güçlü sinyaller 0.618 ve 0.786 arasındaki "Kill Zone"da oluşur. Bu bölgede volume spike + candlestick pattern = Yüksek olasılık!
                    </div>
                </div>
            </div>

            <!-- 2. TEpe & Dip Avcısı -->
            <div class="strategy-card">
                <div class="strategy-header">
                    <div class="strategy-icon">🎯</div>
                    <div style="flex: 1;">
                        <h3 style="font-size: 1.5em; margin-bottom: 5px;">2. Tepe & Dip Avcısı Stratejisi</h3>
                        <p style="color: #aaa;">Trend Reversal | Win Rate: 65-70% | Risk/Reward: 1:2</p>
                    </div>
                </div>
                <div style="padding: 20px; background: rgba(255,255,255,0.03); border-radius: 10px; margin-top: 15px;">
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">📊 Kullanılan İndikatörler:</strong>
                        <div style="margin-top: 10px; line-height: 1.8; padding-left: 15px;">
                            • RSI (14) - Divergence tespiti<br>
                            • Stochastic Oscillator<br>
                            • Volume Profile - Support/Resistance<br>
                            • Pivot Points (Yüksek/Düşük)
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">🎯 Strateji Kuralları:</strong>
                        <div style="margin-top: 10px; line-height: 2; padding-left: 15px;">
                            • <strong>Giriş:</strong> RSI < 30 (Dip) veya RSI > 70 (Tepe) + Volume spike<br>
                            • <strong>Konfirmasyon:</strong> Stochastic oversold/overbought + Candlestick reversal pattern<br>
                            • <strong>Stop Loss:</strong> Son pivot low/high ± %1<br>
                            • <strong>TP1:</strong> Son pivot seviyesi (1:1 RR)<br>
                            • <strong>TP2:</strong> Fibonacci 0.382 (1:2 RR)
                        </div>
                    </div>
                    <div style="background: rgba(255,215,0,0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ffd700;">
                        <strong style="color: #ffd700;">💡 PRO TİP:</strong> Bullish/Bearish divergence RSI'da tespit edildiğinde %85+ başarı oranı! Trend reversal'lar için en güçlü sinyal.
                    </div>
                </div>
            </div>

            <!-- 3. Smart Money Concepts -->
            <div class="strategy-card">
                <div class="strategy-header">
                    <div class="strategy-icon">🐋</div>
                    <div style="flex: 1;">
                        <h3 style="font-size: 1.5em; margin-bottom: 5px;">3. Smart Money Concepts (SMC) Stratejisi</h3>
                        <p style="color: #aaa;">Institutional Flow | Win Rate: 70-75% | Risk/Reward: 1:2.5</p>
                    </div>
                </div>
                <div style="padding: 20px; background: rgba(255,255,255,0.03); border-radius: 10px; margin-top: 15px;">
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">📊 Kullanılan İndikatörler:</strong>
                        <div style="margin-top: 10px; line-height: 1.8; padding-left: 15px;">
                            • Order Blocks (Yüksek Volume Mumları)<br>
                            • Fair Value Gaps (FVG)<br>
                            • BOS (Break of Structure)<br>
                            • CHoCH (Change of Character)<br>
                            • CVD (Cumulative Volume Delta)
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">🎯 Strateji Kuralları:</strong>
                        <div style="margin-top: 10px; line-height: 2; padding-left: 15px;">
                            • <strong>Giriş:</strong> Order Block'ta price reaction + FVG doldurma<br>
                            • <strong>Konfirmasyon:</strong> BOS + CHoCH + CVD bullish/bearish trend<br>
                            • <strong>Stop Loss:</strong> Order Block dışı<br>
                            • <strong>TP1:</strong> İlk FVG (1:1.5 RR)<br>
                            • <strong>TP2:</strong> Son BOS seviyesi (1:2.5 RR)
                        </div>
                    </div>
                    <div style="background: rgba(78,205,196,0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #4ecdc4;">
                        <strong style="color: #4ecdc4;">💡 PRO TİP:</strong> Order Blocks ve FVG'ler "Smart Money" için kritik seviyelerdir. Bu seviyelerde rejection + volume = Yüksek kazanç potansiyeli!
                    </div>
                </div>
            </div>

            <!-- 4. Wyckoff Accumulation -->
            <div class="strategy-card">
                <div class="strategy-header">
                    <div class="strategy-icon">📊</div>
                    <div style="flex: 1;">
                        <h3 style="font-size: 1.5em; margin-bottom: 5px;">4. Wyckoff Accumulation/Distribution Stratejisi</h3>
                        <p style="color: #aaa;">Institutional Manipulation | Win Rate: 75-80% | Risk/Reward: 1:3</p>
                    </div>
                </div>
                <div style="padding: 20px; background: rgba(255,255,255,0.03); border-radius: 10px; margin-top: 15px;">
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">📊 Kullanılan İndikatörler:</strong>
                        <div style="margin-top: 10px; line-height: 1.8; padding-left: 15px;">
                            • Wyckoff Phases (Accumulation/Markup/Distribution/Markdown)<br>
                            • Volume Spread Analysis (VSA)<br>
                            • Supply/Demand Zones<br>
                            • CVD (Cumulative Volume Delta)
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">🎯 Strateji Kuralları:</strong>
                        <div style="margin-top: 10px; line-height: 2; padding-left: 15px;">
                            • <strong>Giriş:</strong> Accumulation fazı sonu + Spring testi başarılı<br>
                            • <strong>Konfirmasyon:</strong> Markup fazı başlangıcı + Volume artışı + CVD bullish<br>
                            • <strong>Stop Loss:</strong> Accumulation zone altı<br>
                            • <strong>TP1:</strong> Markup 50% (1:2 RR)<br>
                            • <strong>TP2:</strong> Distribution zone öncesi (1:3 RR)
                        </div>
                    </div>
                    <div style="background: rgba(255,149,0,0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff9500;">
                        <strong style="color: #ff9500;">💡 PRO TİP:</strong> Wyckoff'ta "Spring" (pshing) testleri en güvenilir giriş noktalarıdır. Market makerlerin manipülasyonunu yakalayın!
                    </div>
                </div>
            </div>

            <!-- 5. Breakout Momentum -->
            <div class="strategy-card">
                <div class="strategy-header">
                    <div class="strategy-icon">🚀</div>
                    <div style="flex: 1;">
                        <h3 style="font-size: 1.5em; margin-bottom: 5px;">5. Breakout Momentum Stratejisi</h3>
                        <p style="color: #aaa;">Trend Continuation | Win Rate: 60-65% | Risk/Reward: 1:2</p>
                    </div>
                </div>
                <div style="padding: 20px; background: rgba(255,255,255,0.03); border-radius: 10px; margin-top: 15px;">
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">📊 Kullanılan İndikatörler:</strong>
                        <div style="margin-top: 10px; line-height: 1.8; padding-left: 15px;">
                            • Bollinger Bands (BB) - Volatilite<br>
                            • Volume Spike (2x+ Average Volume)<br>
                            • EMA 9/21/50 - Trend konfirmasyonu<br>
                            • ADX - Trend gücü (25+)
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">🎯 Strateji Kuralları:</strong>
                        <div style="margin-top: 10px; line-height: 2; padding-left: 15px;">
                            • <strong>Giriş:</strong> BB üst/alt bandı kırılımı + Volume 2x+ + EMA alignment<br>
                            • <strong>Konfirmasyon:</strong> ADX > 25 + MACD bullish cross<br>
                            • <strong>Stop Loss:</strong> BB middle band (1.5 ATR)<br>
                            • <strong>TP1:</strong> Fibonacci Extension 1.272 (1:1.5 RR)<br>
                            • <strong>TP2:</strong> Fibonacci Extension 1.618 (1:2 RR)
                        </div>
                    </div>
                    <div style="background: rgba(255,107,107,0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff6b6b;">
                        <strong style="color: #ff6b6b;">💡 PRO TİP:</strong> Breakout'lar volume olmadan false olabilir! Volume spike mutlaka olmalı, yoksa trap'e düşebilirsiniz.
                    </div>
                </div>
            </div>

            <!-- 6. CVD Divergence -->
            <div class="strategy-card">
                <div class="strategy-header">
                    <div class="strategy-icon">📈</div>
                    <div style="flex: 1;">
                        <h3 style="font-size: 1.5em; margin-bottom: 5px;">6. CVD Divergence Stratejisi</h3>
                        <p style="color: #aaa;">Volume Analysis | Win Rate: 70-75% | Risk/Reward: 1:2</p>
                    </div>
                </div>
                <div style="padding: 20px; background: rgba(255,255,255,0.03); border-radius: 10px; margin-top: 15px;">
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">📊 Kullanılan İndikatörler:</strong>
                        <div style="margin-top: 10px; line-height: 1.8; padding-left: 15px;">
                            • CVD (Cumulative Volume Delta)<br>
                            • Price Action - Higher Highs/Lower Lows<br>
                            • Volume Profile<br>
                            • VWAP (Volume Weighted Average Price)
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">🎯 Strateji Kuralları:</strong>
                        <div style="margin-top: 10px; line-height: 2; padding-left: 15px;">
                            • <strong>Giriş:</strong> Price yeni yüksek/alçak yaparken CVD düşüyor/yükseliyor (Divergence)<br>
                            • <strong>Konfirmasyon:</strong> Volume artışı + VWAP reaksiyonu<br>
                            • <strong>Stop Loss:</strong> Son CVD support/resistance<br>
                            • <strong>TP1:</strong> CVD reversal seviyesi (1:1.5 RR)<br>
                            • <strong>TP2:</strong> Volume Profile Point of Control (1:2 RR)
                        </div>
                    </div>
                    <div style="background: rgba(78,205,196,0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #4ecdc4;">
                        <strong style="color: #4ecdc4;">💡 PRO TİP:</strong> CVD divergence, kurumsal oyuncuların pozisyonlarını değiştirdiğini gösterir. Bu sinyal çok güçlüdür!
                    </div>
                </div>
            </div>

            <!-- 7. Liquidation Hunt -->
            <div class="strategy-card">
                <div class="strategy-header">
                    <div class="strategy-icon">💀</div>
                    <div style="flex: 1;">
                        <h3 style="font-size: 1.5em; margin-bottom: 5px;">7. Liquidation Hunt Stratejisi</h3>
                        <p style="color: #aaa;">Market Manipulation | Win Rate: 65-70% | Risk/Reward: 1:2.5</p>
                    </div>
                </div>
                <div style="padding: 20px; background: rgba(255,255,255,0.03); border-radius: 10px; margin-top: 15px;">
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">📊 Kullanılan İndikatörler:</strong>
                        <div style="margin-top: 10px; line-height: 1.8; padding-left: 15px;">
                            • Liquidation Heatmap (Long/Short Liq. Seviyeleri)<br>
                            • Order Flow Analysis<br>
                            • Funding Rates<br>
                            • Open Interest (OI) Değişimleri
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">🎯 Strateji Kuralları:</strong>
                        <div style="margin-top: 10px; line-height: 2; padding-left: 15px;">
                            • <strong>Giriş:</strong> Büyük liquidation cluster yakınında + Funding rate extreme<br>
                            • <strong>Konfirmasyon:</strong> OI düşüşü + Price liquidation seviyesine yaklaşıyor<br>
                            • <strong>Stop Loss:</strong> Liquidation seviyesinin %2 ötesi<br>
                            • <strong>TP1:</strong> Liquidation cluster sonrası %5 hareket (1:2 RR)<br>
                            • <strong>TP2:</strong> Sonraki major liquidation seviyesi (1:2.5 RR)
                        </div>
                    </div>
                    <div style="background: rgba(255,107,107,0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff6b6b;">
                        <strong style="color: #ff6b6b;">💡 PRO TİP:</strong> Market makerler liquidation'ları avlar. Büyük liquidation cluster'ları "hunted" olduktan sonra price genelde ters yöne gider!
                    </div>
                </div>
            </div>

            <!-- 8. Multi-Timeframe Confluence -->
            <div class="strategy-card">
                <div class="strategy-header">
                    <div class="strategy-icon">⏱️</div>
                    <div style="flex: 1;">
                        <h3 style="font-size: 1.5em; margin-bottom: 5px;">8. Multi-Timeframe Confluence Stratejisi</h3>
                        <p style="color: #aaa;">High Probability Entry | Win Rate: 80-85% | Risk/Reward: 1:2</p>
                    </div>
                </div>
                <div style="padding: 20px; background: rgba(255,255,255,0.03); border-radius: 10px; margin-top: 15px;">
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">📊 Kullanılan İndikatörler:</strong>
                        <div style="margin-top: 10px; line-height: 1.8; padding-left: 15px;">
                            • Multi-Timeframe Analysis (1H, 4H, 1D)<br>
                            • Support/Resistance Levels (Tüm timeframe'lerde)<br>
                            • Fibonacci Levels (Major timeframe'den)<br>
                            • EMA Alignment (3 timeframe'de aynı trend)
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffd700; font-size: 1.1em;">🎯 Strateji Kuralları:</strong>
                        <div style="margin-top: 10px; line-height: 2; padding-left: 15px;">
                            • <strong>Giriş:</strong> 3 timeframe'de aynı yönde trend + S/R seviyesinde confluence<br>
                            • <strong>Konfirmasyon:</strong> Fibonacci + EMA + S/R seviyesi aynı noktada<br>
                            • <strong>Stop Loss:</strong> En yakın S/R seviyesinin ötesi<br>
                            • <strong>TP1:</strong> Bir üst S/R seviyesi (1:1.5 RR)<br>
                            • <strong>TP2:</strong> Major Fibonacci extension (1:2 RR)
                        </div>
                    </div>
                    <div style="background: rgba(155,89,182,0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                        <strong style="color: #9b59b6;">💡 PRO TİP:</strong> 3 timeframe confluence = En yüksek başarı oranı! Büyük timeframe (1D) trend, orta (4H) entry, küçük (1H) timing.
                    </div>
                </div>
            </div>

        </div>

        <!-- İŞLEM ARAÇLARI - TRADING TOOLS -->
        <div id="tradingtools" class="tab-content">
            <h2 style="text-align: center; margin-bottom: 30px; font-size: 2em; color: #ffd700;">
                ⚙️ PROFESYONEL İŞLEM ARAÇLARI
            </h2>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-bottom: 30px;">
                <!-- 1. POSITION SIZE CALCULATOR -->
                <div class="strategy-card">
                    <h3 style="font-size: 1.5em; margin-bottom: 15px; color: #ffd700;">💰 Position Size Calculator</h3>
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Portföy Değeri (USDT):</label>
                            <input type="number" id="portfolioValue" placeholder="10000" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Risk Yüzdesi (%):</label>
                            <input type="number" id="riskPercent" placeholder="2" step="0.1" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Entry Price:</label>
                            <input type="number" id="entryPrice" placeholder="50000" step="0.01" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Stop Loss Price:</label>
                            <input type="number" id="stopLossPrice" placeholder="49000" step="0.01" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Leverage (Opsiyonel):</label>
                            <input type="number" id="leverage" placeholder="1" min="1" max="125" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <button onclick="calculatePositionSize()" style="padding: 15px; background: linear-gradient(45deg, #4ecdc4, #44a08d); border: none; border-radius: 10px; color: #fff; font-weight: bold; cursor: pointer; font-size: 1.1em;">
                            📊 Position Size Hesapla
                        </button>
                        <div id="positionSizeResult" style="margin-top: 15px; padding: 15px; background: rgba(78,205,196,0.1); border-radius: 8px; display: none;"></div>
                    </div>
                </div>

                <!-- 2. RISK/REWARD CALCULATOR -->
                <div class="strategy-card">
                    <h3 style="font-size: 1.5em; margin-bottom: 15px; color: #ffd700;">📈 Risk/Reward Calculator</h3>
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Entry Price:</label>
                            <input type="number" id="rrEntry" placeholder="50000" step="0.01" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Stop Loss:</label>
                            <input type="number" id="rrStopLoss" placeholder="49000" step="0.01" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Take Profit 1:</label>
                            <input type="number" id="rrTP1" placeholder="51000" step="0.01" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Take Profit 2:</label>
                            <input type="number" id="rrTP2" placeholder="52000" step="0.01" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Pozisyon Türü:</label>
                            <select id="positionType" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                                <option value="long">🟢 LONG</option>
                                <option value="short">🔴 SHORT</option>
                            </select>
                        </div>
                        <button onclick="calculateRiskReward()" style="padding: 15px; background: linear-gradient(45deg, #ffd700, #ff9500); border: none; border-radius: 10px; color: #000; font-weight: bold; cursor: pointer; font-size: 1.1em;">
                            📊 Risk/Reward Hesapla
                        </button>
                        <div id="riskRewardResult" style="margin-top: 15px; padding: 15px; background: rgba(255,215,0,0.1); border-radius: 8px; display: none;"></div>
                    </div>
                </div>

                <!-- 3. LEVERAGE CALCULATOR -->
                <div class="strategy-card">
                    <h3 style="font-size: 1.5em; margin-bottom: 15px; color: #ffd700;">⚡ Leverage Calculator</h3>
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Margin (USDT):</label>
                            <input type="number" id="marginAmount" placeholder="1000" step="0.01" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Leverage (1x-125x):</label>
                            <input type="number" id="leverageAmount" placeholder="10" min="1" max="125" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Entry Price:</label>
                            <input type="number" id="levEntryPrice" placeholder="50000" step="0.01" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <button onclick="calculateLeverage()" style="padding: 15px; background: linear-gradient(45deg, #ff6b6b, #c44569); border: none; border-radius: 10px; color: #fff; font-weight: bold; cursor: pointer; font-size: 1.1em;">
                            ⚡ Leverage Hesapla
                        </button>
                        <div id="leverageResult" style="margin-top: 15px; padding: 15px; background: rgba(255,107,107,0.1); border-radius: 8px; display: none;"></div>
                    </div>
                </div>

                <!-- 4. CORRELATION ANALYZER -->
                <div class="strategy-card">
                    <h3 style="font-size: 1.5em; margin-bottom: 15px; color: #ffd700;">🔗 Coin Correlation Analyzer</h3>
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Ana Coin:</label>
                            <select id="baseCoin" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                                <option value="BTC/USDT">BTC/USDT</option>
                                <option value="ETH/USDT">ETH/USDT</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Karşılaştırılacak Coinler (virgülle ayırın):</label>
                            <input type="text" id="compareCoins" placeholder="ETH/USDT, SOL/USDT, BNB/USDT" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px;">Periyot (Gün):</label>
                            <input type="number" id="correlationPeriod" placeholder="30" min="7" max="365" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                        </div>
                        <button onclick="analyzeCorrelation()" style="padding: 15px; background: linear-gradient(45deg, #9b59b6, #8e44ad); border: none; border-radius: 10px; color: #fff; font-weight: bold; cursor: pointer; font-size: 1.1em;">
                            🔗 Korelasyon Analizi
                        </button>
                        <div id="correlationResult" style="margin-top: 15px; padding: 15px; background: rgba(155,89,182,0.1); border-radius: 8px; display: none;"></div>
                    </div>
                </div>
            </div>

            <!-- PORTFOLIO TRACKER -->
            <div class="strategy-card" style="margin-top: 30px;">
                <h3 style="font-size: 1.5em; margin-bottom: 15px; color: #ffd700;">📊 Portfolio Tracker</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px;">Coin:</label>
                        <input type="text" id="portfolioCoin" placeholder="BTC/USDT" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px;">Miktar:</label>
                        <input type="number" id="portfolioAmount" placeholder="0.1" step="0.00000001" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px;">Giriş Fiyatı:</label>
                        <input type="number" id="portfolioEntry" placeholder="50000" step="0.01" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px;">Pozisyon Türü:</label>
                        <select id="portfolioType" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff;">
                            <option value="long">🟢 LONG</option>
                            <option value="short">🔴 SHORT</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: flex-end;">
                        <button onclick="addToPortfolio()" style="padding: 15px; background: linear-gradient(45deg, #4ecdc4, #44a08d); border: none; border-radius: 10px; color: #fff; font-weight: bold; cursor: pointer; width: 100%;">
                            ➕ Portföye Ekle
                        </button>
                    </div>
                </div>
                <div id="portfolioList" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- SONUÇLAR -->
        <div id="results" class="tab-content">
            <div id="loadingSection" style="display: none;" class="loading">
                <div class="spinner"></div>
                <p style="font-size: 1.3em; font-weight: bold; animation: pulse 2s ease-in-out infinite;">⚡ Teknik Analiz Hesaplanıyor...</p>
                <p style="font-size: 0.9em; margin-top: 10px; animation: fadeIn 2s ease-in-out infinite;">📊 7 Borsa • 50+ Premium İndikatör • Gerçek Zamanlı Veriler</p>
                <div class="progress-bar" style="width: 0%; height: 8px; background: linear-gradient(90deg, #ffd700, #4ecdc4); border-radius: 10px; margin: 20px auto; max-width: 400px; transition: width 0.3s;"></div>
            </div>
            <!-- LONG ve SHORT için ayrı bölümler -->
            <div class="results-sections">
                <!-- LONG SONUÇLAR -->
                <div class="result-section long-section">
                    <div class="section-header long-header">
                        <h2>🟢 LONG SİNYALLERİ</h2>
                        <div class="section-count" id="longCount">0 Coin</div>
                        <div class="section-description">Yükseliş potansiyeli olan coinler - Detaylı analiz için coin kartına tıklayın</div>
                    </div>
                    <div class="results-container" id="longResultsContainer"></div>
                </div>

                <!-- SHORT SONUÇLAR -->
                <div class="result-section short-section">
                    <div class="section-header short-header">
                        <h2>🔴 SHORT SİNYALLERİ</h2>
                        <div class="section-count" id="shortCount">0 Coin</div>
                        <div class="section-description">Düşüş potansiyeli olan coinler - Detaylı analiz için coin kartına tıklayın</div>
                    </div>
                    <div class="results-container" id="shortResultsContainer"></div>
                </div>

                <!-- WAIT/KARARSIZ SONUÇLAR (isteğe bağlı) -->
                <div class="result-section wait-section" id="waitSection" style="display: none;">
                    <div class="section-header wait-header">
                        <h2>⚪ BEKLEME MODU</h2>
                        <div class="section-count" id="waitCount">0 Coin</div>
                        <div class="section-description">Net sinyal beklenen coinler</div>
                    </div>
                    <div class="results-container" id="waitResultsContainer"></div>
                </div>
            </div>
        </div>

        <!-- AI TRADING DASHBOARD -->
        <div id="dashboard" class="tab-content">
            <div style="text-align: center; margin-bottom: 30px;">
                <h1 style="font-size: 2.5em; background: linear-gradient(135deg, #ffd700, #4ecdc4); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px;">
                    🎯 AI TRADING DASHBOARD
                </h1>
                <p style="color: #aaa; font-size: 1.1em;">Tüm analizleri birleştiren profesyonel sinyal sistemi</p>
            </div>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 30px;">
                <!-- Top Signals -->
                <div style="background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(76, 175, 80, 0.5);">
                    <h3 style="color: #4caf50; margin-bottom: 15px;">🏆 TOP LONG SİNYALLERİ</h3>
                    <div id="topLongSignals" style="display: flex; flex-direction: column; gap: 10px;">
                        <div style="text-align: center; color: #aaa; padding: 20px;">Tarama yapın...</div>
                    </div>
                </div>

                <div style="background: rgba(244, 67, 54, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(244, 67, 54, 0.5);">
                    <h3 style="color: #f44336; margin-bottom: 15px;">🏆 TOP SHORT SİNYALLERİ</h3>
                    <div id="topShortSignals" style="display: flex; flex-direction: column; gap: 10px;">
                        <div style="text-align: center; color: #aaa; padding: 20px;">Tarama yapın...</div>
                    </div>
                </div>

                <div style="background: rgba(255, 215, 0, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(255, 215, 0, 0.5);">
                    <h3 style="color: #ffd700; margin-bottom: 15px;">⚡ HIZLI İŞLEM FIRSATLARI</h3>
                    <div id="quickOpportunities" style="display: flex; flex-direction: column; gap: 10px;">
                        <div style="text-align: center; color: #aaa; padding: 20px;">Tarama yapın...</div>
                    </div>
                </div>
            </div>

            <!-- Advanced Analytics -->
            <div style="background: rgba(0,0,0,0.4); padding: 30px; border-radius: 15px; margin-bottom: 30px;">
                <h3 style="color: #4ecdc4; margin-bottom: 20px;">📊 GELİŞMİŞ ANALİTİK</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                    <div id="dashboard-stats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Stats will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Market Overview -->
            <div style="background: rgba(0,0,0,0.4); padding: 30px; border-radius: 15px;">
                <h3 style="color: #ffd700; margin-bottom: 20px;">🌍 PİYASA GENEL BAKIŞ</h3>
                <div id="marketOverview" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    <!-- Market data will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // ✅ API ANAHTARLARI - GÜVENLİK UYARISI
        // ⚠️ UYARI: Production'da bu anahtarları environment variable olarak kullanın!
        const API_KEYS = {
            GROQ: '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',
            COINGECKO: 'CG-byACFdCvS96r4nNP2ZL2R8SS',
            TELEGRAM_BOT: '8429888891:AAEJS59OiC06g7-R2ZhZgAzHwc0cGXhkMv8',
            TELEGRAM_CHAT: '1591184905'
        };

        let currentLanguage = 'tr';
        let selectedTimeframe = '15m';
        let minScore = 70;
        let selectedExchanges = ['Binance', 'OKX', 'Bybit', 'MEXC', 'KuCoin', 'Gate.io', 'Huobi'];
        let realPrices = {};
        
        // ===== GERÇEK ZAMANLI VERİ DEPOLARI =====
        let websocketConnections = {};
        let candleData = {}; // OHLCV verileri
        let technicalIndicators = {}; // Teknik analiz sonuçları
        let fearGreedIndex = null;
        let liquidationData = {};
        let fundingRates = {};
        let volumeData = {};
        let onChainData = {};
        let cvdData = {}; // Cumulative Volume Delta
        let orderBlocks = {}; // Smart Money Order Blocks
        let fvgData = {}; // Fair Value Gaps
        let openInterestData = {}; // Open Interest (Açık Pozisyon)
        let longShortRatioData = {}; // Long/Short Ratio
        let marketDepthData = {}; // Order Book Depth
        let largeTradesData = {}; // Whale Trades
        let correlationMatrix = {}; // Coin Correlation Matrix
        let exchangeFlows = {}; // Exchange Coin Transfers
        let socialSentiment = {}; // Social Media Sentiment
        let alertSettings = {}; // Price/Volume Alerts
        
        // WebSocket URL'leri
        const BINANCE_WS = 'wss://stream.binance.com:9443/ws/';
        const BINANCE_WS_STREAM = 'wss://stream.binance.com:9443/stream?streams=';
        const OKX_WS = 'wss://ws.okx.com:8443/ws/v5/public';
        const BYBIT_WS = 'wss://stream.bybit.com/v5/public/spot';
        
        // Daha fazla coin desteği
        const SUPPORTED_COINS = [
            'BTC', 'ETH', 'BNB', 'SOL', 'XRP', 'ADA', 'DOGE', 'DOT',
            'MATIC', 'AVAX', 'LINK', 'UNI', 'ATOM', 'LTC', 'ETC', 'FIL',
            'TRX', 'XLM', 'ALGO', 'VET', 'ICP', 'APT', 'ARB', 'OP',
            'NEAR', 'AAVE', 'SNX', 'MKR', 'CRV', 'COMP', 'SUSHI', '1INCH'
        ];

        // ===== DÜZELTME: Event parametreleri eklendi =====
        function changeLanguage(lang, event) {
            currentLanguage = lang;
            const buttons = document.querySelectorAll('.lang-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                buttons.forEach(btn => {
                    if (btn.textContent.includes(lang.toUpperCase())) {
                        btn.classList.add('active');
                    }
                });
            }
        }

        function switchTab(tabName, event) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    if (tab.textContent.includes(tabName) || tab.getAttribute('onclick')?.includes(tabName)) {
                        tab.classList.add('active');
                    }
                });
            }
            
            // Dashboard açıldığında güncelle
            if (tabName === 'dashboard') {
                setTimeout(updateTradingDashboard, 100);
            }
        }

        function selectTimeframe(tf, event) {
            selectedTimeframe = tf;
            document.querySelectorAll('.timeframe-btn').forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                document.querySelectorAll('.timeframe-btn').forEach(btn => {
                    if (btn.textContent === tf) {
                        btn.classList.add('active');
                    }
                });
            }
        }

        function updateMinScore(value) {
            minScore = value;
            document.getElementById('minScoreValue').textContent = value;
        }

        // ===== GERÇEK LİKİDASYON HARITASI FONKSIYONU =====
        function generateLiquidationHTML(coin, currentPrice) {
            // Gerçek likidasyon verilerini kullan
            const symbol = coin.replace('/USDT', 'USDT');
            const realLiquidation = liquidationData[symbol];
            
            // Gerçek veri varsa kullan, yoksa tahmini hesapla
            let liquidationLevels;
            
            if (realLiquidation && realLiquidation.total > 0) {
                // Gerçek likidasyon verilerinden seviyeler oluştur
                const total = realLiquidation.total;
                const longRatio = realLiquidation.longLiquidation / total;
                const shortRatio = realLiquidation.shortLiquidation / total;
                
                liquidationLevels = [
                    { price: currentPrice * 0.93, long: total * longRatio * 0.2, short: total * shortRatio * 0.1 },
                    { price: currentPrice * 0.96, long: total * longRatio * 0.25, short: total * shortRatio * 0.15 },
                    { price: currentPrice * 0.98, long: total * longRatio * 0.3, short: total * shortRatio * 0.25 },
                    { price: currentPrice * 1.00, long: total * longRatio * 0.15, short: total * shortRatio * 0.2 },
                    { price: currentPrice * 1.02, long: total * longRatio * 0.05, short: total * shortRatio * 0.15 },
                    { price: currentPrice * 1.04, long: total * longRatio * 0.03, short: total * shortRatio * 0.1 },
                    { price: currentPrice * 1.07, long: total * longRatio * 0.02, short: total * shortRatio * 0.05 },
                ];
            } else {
                // Fallback: Tahmini seviyeler (gerçek veri yoksa)
                const estimatedTotal = currentPrice * 100000; // Tahmini toplam likidasyon
                liquidationLevels = [
                    { price: currentPrice * 0.93, long: estimatedTotal * 0.2, short: estimatedTotal * 0.1 },
                    { price: currentPrice * 0.96, long: estimatedTotal * 0.25, short: estimatedTotal * 0.15 },
                    { price: currentPrice * 0.98, long: estimatedTotal * 0.3, short: estimatedTotal * 0.25 },
                    { price: currentPrice * 1.00, long: estimatedTotal * 0.15, short: estimatedTotal * 0.2 },
                    { price: currentPrice * 1.02, long: estimatedTotal * 0.05, short: estimatedTotal * 0.15 },
                    { price: currentPrice * 1.04, long: estimatedTotal * 0.03, short: estimatedTotal * 0.1 },
                    { price: currentPrice * 1.07, long: estimatedTotal * 0.02, short: estimatedTotal * 0.05 },
                ];
            }

            let totalLong = 0, totalShort = 0;
            let maxLongLevel = 0, maxShortLevel = 0;
            let maxLongPrice = 0, maxShortPrice = 0;

            liquidationLevels.forEach(level => {
                totalLong += level.long;
                totalShort += level.short;
                if (level.long > maxLongLevel) {
                    maxLongLevel = level.long;
                    maxLongPrice = level.price;
                }
                if (level.short > maxShortLevel) {
                    maxShortLevel = level.short;
                    maxShortPrice = level.price;
                }
            });

            const maxValue = Math.max(maxLongLevel, maxShortLevel);
            const distanceFromLongMax = Math.abs(currentPrice - maxLongPrice) / currentPrice * 100;
            const distanceFromShortMax = Math.abs(currentPrice - maxShortPrice) / currentPrice * 100;
            
            let html = `
            <div style="background: linear-gradient(135deg, rgba(255, 107, 107, 0.15), rgba(231, 76, 60, 0.15)); border: 2px solid #ff6b6b; padding: 20px; border-radius: 15px; margin: 20px 0; box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);">
                <div style="color: #ff6b6b; font-weight: bold; font-size: 1.4em; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                    💀 LİKİDASYON SEVİYELERİ - ${coin}
                    <span style="font-size: 0.6em; color: #aaa; font-weight: normal;">Gerçek Zamanlı Analiz</span>
                </div>
                
                <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div style="background: rgba(78, 205, 196, 0.15); border: 1px solid rgba(78, 205, 196, 0.5); padding: 12px; border-radius: 8px;">
                            <div style="color: #4ecdc4; font-size: 0.85em; margin-bottom: 5px;">🟢 Max LONG Liquidation</div>
                            <div style="color: #4ecdc4; font-size: 1.2em; font-weight: bold;">$${formatPrice(maxLongPrice)}</div>
                            <div style="font-size: 0.75em; color: #aaa; margin-top: 5px;">Mevcut: $${formatPrice(currentPrice)} (${distanceFromLongMax.toFixed(1)}% uzaklık)</div>
                            <div style="background: rgba(0,0,0,0.3); border-radius: 5px; overflow: hidden; height: 8px; margin-top: 8px;">
                                <div style="height: 100%; background: linear-gradient(90deg, #4ecdc4, #2a9d8f); width: ${Math.max(10, 100 - (distanceFromLongMax * 2))}%;"></div>
                            </div>
                        </div>
                        <div style="background: rgba(255, 107, 107, 0.15); border: 1px solid rgba(255, 107, 107, 0.5); padding: 12px; border-radius: 8px;">
                            <div style="color: #ff6b6b; font-size: 0.85em; margin-bottom: 5px;">🔴 Max SHORT Liquidation</div>
                            <div style="color: #ff6b6b; font-size: 1.2em; font-weight: bold;">$${formatPrice(maxShortPrice)}</div>
                            <div style="font-size: 0.75em; color: #aaa; margin-top: 5px;">Mevcut: $${formatPrice(currentPrice)} (${distanceFromShortMax.toFixed(1)}% uzaklık)</div>
                            <div style="background: rgba(0,0,0,0.3); border-radius: 5px; overflow: hidden; height: 8px; margin-top: 8px;">
                                <div style="height: 100%; background: linear-gradient(90deg, #ff6b6b, #e74c3c); width: ${Math.max(10, 100 - (distanceFromShortMax * 2))}%;"></div>
                            </div>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div style="background: rgba(78, 205, 196, 0.1); border-left: 3px solid #4ecdc4; padding: 10px; border-radius: 8px;">
                            <div style="color: #4ecdc4; font-size: 0.85em; font-weight: bold;">Toplam LONG Liq.</div>
                            <div style="color: #4ecdc4; font-size: 1.1em; font-weight: bold;">$${(totalLong / 1000000).toFixed(2)}M</div>
                        </div>
                        <div style="background: rgba(255, 107, 107, 0.1); border-left: 3px solid #ff6b6b; padding: 10px; border-radius: 8px;">
                            <div style="color: #ff6b6b; font-size: 0.85em; font-weight: bold;">Toplam SHORT Liq.</div>
                            <div style="color: #ff6b6b; font-size: 1.1em; font-weight: bold;">$${(totalShort / 1000000).toFixed(2)}M</div>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(255, 215, 0, 0.1); border-left: 4px solid #ffd700; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">⚠️ Uyarı</div>
                    <div style="color: #ddd; font-size: 0.85em; line-height: 1.5;">
                        ${distanceFromLongMax < 5 ? '🔴 <strong>KRİTİK:</strong> LONG likidasyon seviyelerine çok yakınsınız!' : distanceFromShortMax < 5 ? '🔴 <strong>KRİTİK:</strong> SHORT likidasyon seviyelerine çok yakınsınız!' : distanceFromLongMax < 10 || distanceFromShortMax < 10 ? '⚠️ <strong>DİKKAT:</strong> Likidasyon seviyelerine yaklaşıyorsunuz.' : '✅ <strong>GÜVENLİ:</strong> Likidasyon seviyelerinden yeterince uzaksınız.'}
                    </div>
                </div>
                
                <div style="max-height: 400px; overflow-y: auto; border-radius: 10px;">`;

            liquidationLevels.forEach((level, index) => {
                const longPercent = (level.long / maxValue) * 100;
                const shortPercent = (level.short / maxValue) * 100;
                const isCurrent = Math.abs(level.price - currentPrice) < currentPrice * 0.01;
                const distance = ((level.price - currentPrice) / currentPrice * 100);
                const distanceAbs = Math.abs(distance);
                const marker = isCurrent ? ' ⚡ MEVCUT FİYAT' : distanceAbs < 2 ? ' 🔴 ÇOK YAKIN' : distanceAbs < 5 ? ' ⚠️ YAKIN' : '';
                const riskLevel = distanceAbs < 2 ? 'high' : distanceAbs < 5 ? 'medium' : 'low';
                
                html += `
                <div style="display: grid; grid-template-columns: 0.9fr 1.4fr 1.4fr 0.9fr; gap: 12px; padding: 15px; margin: 8px 0; 
                            background: ${isCurrent ? 'rgba(255, 215, 0, 0.2)' : riskLevel === 'high' ? 'rgba(255, 107, 107, 0.15)' : riskLevel === 'medium' ? 'rgba(255, 149, 0, 0.1)' : 'rgba(255, 255, 255, 0.03)'}; 
                            border-radius: 10px; border-left: 4px solid ${isCurrent ? '#ffd700' : riskLevel === 'high' ? '#ff6b6b' : riskLevel === 'medium' ? '#ff9500' : '#666'}; 
                            align-items: center; transition: all 0.3s; ${isCurrent ? 'box-shadow: 0 2px 10px rgba(255, 215, 0, 0.5);' : ''}">
                    <div style="text-align: center;">
                        <div style="font-weight: bold; color: ${isCurrent ? '#ffd700' : '#4ecdc4'}; font-size: 1em; margin-bottom: 3px;">
                            $${formatPrice(level.price)}
                        </div>
                        <div style="font-size: 0.7em; color: ${distance >= 0 ? '#4ecdc4' : '#ff6b6b'};">
                            ${distance >= 0 ? '↑' : '↓'} ${distanceAbs.toFixed(1)}%
                        </div>
                        ${marker ? `<div style="font-size: 0.65em; color: ${riskLevel === 'high' ? '#ff6b6b' : '#ffd700'}; margin-top: 3px; font-weight: bold;">${marker}</div>` : ''}
                    </div>
                    <div style="background: rgba(78, 205, 196, 0.15); padding: 10px; border-radius: 8px; border: 1px solid rgba(78, 205, 196, 0.3);">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                            <span style="color: #4ecdc4; font-size: 0.75em; font-weight: bold;">🟢 LONG</span>
                            <span style="color: #4ecdc4; font-size: 0.75em; font-weight: bold;">$${(level.long / 1000000).toFixed(2)}M</span>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 6px; overflow: hidden; height: 18px; position: relative;">
                            <div style="width: ${Math.max(longPercent, 8)}%; height: 100%; background: linear-gradient(90deg, #4ecdc4 0%, #2a9d8f 100%); 
                                         border-radius: 4px; display: flex; align-items: center; justify-content: center; 
                                         color: ${longPercent > 15 ? '#fff' : '#000'}; font-weight: bold; font-size: 0.7em; 
                                         transition: width 0.5s; min-width: ${longPercent > 5 ? '50px' : '30px'};">
                                ${longPercent > 5 ? longPercent.toFixed(0) + '%' : ''}
                            </div>
                        </div>
                    </div>
                    <div style="background: rgba(255, 107, 107, 0.15); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 107, 107, 0.3);">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                            <span style="color: #ff6b6b; font-size: 0.75em; font-weight: bold;">🔴 SHORT</span>
                            <span style="color: #ff6b6b; font-size: 0.75em; font-weight: bold;">$${(level.short / 1000000).toFixed(2)}M</span>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 6px; overflow: hidden; height: 18px; position: relative;">
                            <div style="width: ${Math.max(shortPercent, 8)}%; height: 100%; background: linear-gradient(90deg, #ff6b6b 0%, #e74c3c 100%); 
                                         border-radius: 4px; display: flex; align-items: center; justify-content: center; 
                                         color: ${shortPercent > 15 ? '#fff' : '#000'}; font-weight: bold; font-size: 0.7em; 
                                         transition: width 0.5s; min-width: ${shortPercent > 5 ? '50px' : '30px'}; margin-left: auto;">
                                ${shortPercent > 5 ? shortPercent.toFixed(0) + '%' : ''}
                            </div>
                        </div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: #aaa; font-size: 0.75em; margin-bottom: 3px;">Toplam</div>
                        <div style="color: #fff; font-weight: bold; font-size: 0.9em;">
                            $${((level.long + level.short) / 1000000).toFixed(2)}M
                        </div>
                        <div style="font-size: 0.65em; color: #666; margin-top: 3px;">
                            ${((level.long + level.short) / (totalLong + totalShort) * 100).toFixed(1)}%
                        </div>
                    </div>
                </div>`;
            });

            html += `
                </div>
                
                <div style="margin-top: 20px; padding-top: 15px; border-top: 2px solid rgba(255, 107, 107, 0.3);">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(44, 160, 141, 0.2)); border: 2px solid #4ecdc4; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(78, 205, 196, 0.3);">
                            <div style="color: #4ecdc4; font-weight: bold; font-size: 1.1em; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                🟢 LONG Likidation Özeti
                            </div>
                            <div style="font-size: 0.95em; color: #ddd; line-height: 1.8;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Toplam Likidation:</span>
                                    <span style="color: #4ecdc4; font-weight: bold; font-size: 1.1em;">$${(totalLong / 1000000).toFixed(2)}M</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Max Likidation Fiyatı:</span>
                                    <span style="color: #4ecdc4; font-weight: bold;">$${maxLongPrice.toFixed(2)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span>Mevcut Fiyat Uzaklığı:</span>
                                    <span style="color: ${distanceFromLongMax < 5 ? '#ff6b6b' : distanceFromLongMax < 10 ? '#ff9500' : '#4ecdc4'}; font-weight: bold;">
                                        ${distanceFromLongMax.toFixed(1)}%
                                    </span>
                                </div>
                            </div>
                        </div>
                        <div style="background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(231, 76, 60, 0.2)); border: 2px solid #ff6b6b; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(255, 107, 107, 0.3);">
                            <div style="color: #ff6b6b; font-weight: bold; font-size: 1.1em; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                🔴 SHORT Likidation Özeti
                            </div>
                            <div style="font-size: 0.95em; color: #ddd; line-height: 1.8;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Toplam Likidation:</span>
                                    <span style="color: #ff6b6b; font-weight: bold; font-size: 1.1em;">$${(totalShort / 1000000).toFixed(2)}M</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span>Max Likidation Fiyatı:</span>
                                    <span style="color: #ff6b6b; font-weight: bold;">$${maxShortPrice.toFixed(2)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span>Mevcut Fiyat Uzaklığı:</span>
                                    <span style="color: ${distanceFromShortMax < 5 ? '#ff6b6b' : distanceFromShortMax < 10 ? '#ff9500' : '#4ecdc4'}; font-weight: bold;">
                                        ${distanceFromShortMax.toFixed(1)}%
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; margin-top: 15px;">
                        <div style="color: #ffd700; font-weight: bold; margin-bottom: 8px; font-size: 1em;">📊 Genel Özet</div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-size: 0.9em;">
                            <div>
                                <div style="color: #aaa; margin-bottom: 3px;">Toplam Likidation</div>
                                <div style="color: #fff; font-weight: bold; font-size: 1.1em;">$${((totalLong + totalShort) / 1000000).toFixed(2)}M</div>
                            </div>
                            <div>
                                <div style="color: #aaa; margin-bottom: 3px;">LONG/SHORT Oranı</div>
                                <div style="color: #fff; font-weight: bold; font-size: 1.1em;">
                                    ${((totalLong / (totalLong + totalShort || 1)) * 100).toFixed(1)}% / ${((totalShort / (totalLong + totalShort || 1)) * 100).toFixed(1)}%
                                </div>
                            </div>
                            <div>
                                <div style="color: #aaa; margin-bottom: 3px;">Risk Seviyesi</div>
                                <div style="color: ${distanceFromLongMax < 5 || distanceFromShortMax < 5 ? '#ff6b6b' : distanceFromLongMax < 10 || distanceFromShortMax < 10 ? '#ff9500' : '#4ecdc4'}; font-weight: bold; font-size: 1.1em;">
                                    ${distanceFromLongMax < 5 || distanceFromShortMax < 5 ? '🔴 YÜKSEK' : distanceFromLongMax < 10 || distanceFromShortMax < 10 ? '⚠️ ORTA' : '✅ DÜŞÜK'}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>`;

            return html;
        }

        // 50+ PREMİUM OPTİMİZE İNDİKATÖRLER (Gereksiz tekrarlar çıkarıldı, sadece en güvenilir olanlar)
        const indicatorCategories = {
            'TREND İNDİKATÖRLER (12)': [
                'SMA(50) - Orta vadeli trend desteği/direnci',
                'SMA(200) - Uzun vadeli trend desteği/direnci (Death/Golden Cross)',
                'EMA(9) - Kısa vadeli momentum',
                'EMA(21) - Orta vadeli momentum',
                'EMA(50) - Trend konfirmasyonu',
                'EMA(200) - Uzun vadeli trend',
                'EMA Golden Cross (50>200) - Uzun vadeli yükseliş trendi',
                'EMA Death Cross (50<200) - Uzun vadeli düşüş trendi',
                'EMA Perfect Alignment - Tüm EMA\'lar aynı yönde (Güçlü trend)',
                'MACD - Trend ve momentum analizi (En güvenilir)',
                'ADX - Trend gücü ölçümü (Sadece güçlü trendlerde sinyal)',
                'Ichimoku Cloud - Japon teknik analiz (Trend + Destek/Direnç)',
                'Supertrend - Trend takip (Çok güvenilir, trend değişimleri)'
            ],
            'MOMENTUM İNDİKATÖRLER (6)': [
                'RSI(14) - Aşırı alım/satım + Divergence tespiti (En popüler)',
                'RSI Bullish Divergence - Fiyat düşerken RSI yükseliyor (Güçlü sinyal)',
                'RSI Bearish Divergence - Fiyat yükselirken RSI düşüyor (Güçlü sinyal)',
                'Stochastic Oscillator - Momentum ve aşırı alım/satım',
                'Stochastic Bullish Cross - Yeni yükseliş sinyali',
                'Stochastic Bearish Cross - Yeni düşüş sinyali',
                'MACD Histogram - Momentum hızlanması/yavaşlaması'
            ],
            'VOLUME İNDİKATÖRLER (6)': [
                'Volume Ratio - Kurumsal aktivite tespiti (1.5x+ = Güçlü hareket)',
                'OBV (On-Balance Volume) - Kurumsal birikim/dağıtım göstergesi',
                'VWAP - Kurumsal referans fiyatı (Institutional reference)',
                'VWAP Mesafesi - Fiyatın VWAP\'tan uzaklığı (Kurumsal baskı)',
                'CVD (Cumulative Volume Delta) - Kurumsal alım/satış akışı',
                'Institutional Volume - 3x+ volume (Kurumsal aktivite - ÇOK GÜÇLÜ)'
            ],
            'VOLATİLİTE İNDİKATÖRLER (4)': [
                'Bollinger Bands - Volatilite ve aşırı alım/satım',
                'BB Band Genişliği - Yüksek/düşük volatilite tespiti',
                'BB Aşırı Satım/Alım - Fiyatın alt/üst band dışında (Güçlü fırsat)',
                'ATR (Average True Range) - Volatilite ölçümü ve risk yönetimi'
            ],
            'SMART MONEY CONCEPTS (12)': [
                'Order Blocks - Kurumsal işlem bölgeleri (Smart Money entry/exit)',
                'Fair Value Gaps (FVG) - Dengesizlik bölgeleri (Fırsat alanları)',
                'BOS (Break of Structure) - Yapı kırılımları',
                'CHoCH (Change of Character) - Karakter değişimi',
                'Premium/Discount Zones - Kurumsal birikim/dağıtım bölgeleri',
                'Wyckoff Phases - Accumulation/Markup/Distribution/Markdown',
                'VSA (Volume Spread Analysis) - Volume ile fiyat analizi',
                'Dark Pool Activity - Karanlık havuz aktivitesi',
                'Order Flow Analysis - Alım/satım basıncı',
                'Block Trades - Büyük kurumsal işlemler',
                'Whale Activity - Balina aktivitesi ve sentiment',
                'CVD Trend - Kurumsal akış trendi'
            ],
            'FIBONACCI & PATTERNS (20)': [
                'Auto Fibonacci', 'Fib Extension', 'Fib Fan', 'Fib Time Zones', 'Fib Arcs',
                'Fib Spiral', 'Gann Fan', 'Gann Square', 'Elliott Wave', 'Harmonic Patterns',
                'ABCD', 'Bat', 'Butterfly', 'Gartley', 'Crab',
                'Shark', 'Cypher', '3 Drives', 'Head & Shoulders', 'Double Top/Bottom'
            ],
            'PUMP & DUMP (20)': [
                'ZS Pump Detector', 'Pump Sensitive', 'Peak Detection', 'Volume Surprise',
                'OBV MACD Pump', 'ML RSI Dump', 'Volume Delta Pump', 'ADX Pump',
                'Top & Bottom Finder', '%R Exhaustion', 'RSI Divergence', 'MACD Bottom',
                'Stochastic Top', 'SAR Reversal', 'Pivot Points', 'Elder Impulse',
                'ZigZag Tops', 'Relative Vigor', 'Chande Forecast', 'Williams Fractals'
            ]
        };

        // Borsalar - Tümü aktif başlatılıyor
        const exchanges = [
            { name: 'Binance', logo: '🟡', active: true },
            { name: 'OKX', logo: '⚫', active: true },
            { name: 'Bybit', logo: '🟠', active: true },
            { name: 'MEXC', logo: '🔵', active: true },
            { name: 'KuCoin', logo: '🟢', active: true },
            { name: 'Gate.io', logo: '🟣', active: true },
            { name: 'Huobi', logo: '🔴', active: true }
        ];

        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 YASAR-AI KRIPTO ULTRA SCANNER - Gerçek Zamanlı Sistem Başlatılıyor...');
            
            // Statik içerikleri yükle
            loadIndicators();
            loadExchanges();
            
            // Gerçek zamanlı verileri başlat
            initializeRealTimeData();
        });
        
        // ===== GERÇEK ZAMANLI VERİ İNİTİALİZASYONU =====
        async function initializeRealTimeData() {
            try {
                // İlk veri yükleme
                await fetchRealPrices();
                await fetchFearGreedIndex();
                await fetchFundingRates();
                await fetchLiquidationData();
                await fetchOnChainData();
                
                // WebSocket bağlantılarını başlat
                connectBinanceWebSocket();
                if (selectedExchanges.includes('OKX')) {
                    connectOKXWebSocket();
                }
                if (selectedExchanges.includes('Bybit')) {
                    connectBybitWebSocket();
                }
                
                // Periyodik güncellemeler
                setInterval(fetchRealPrices, 30000); // 30 saniyede bir fiyat güncelle
                setInterval(fetchFearGreedIndex, 300000); // 5 dakikada bir Fear & Greed
                setInterval(fetchFundingRates, 60000); // 1 dakikada bir funding rates
                setInterval(fetchLiquidationData, 60000); // 1 dakikada bir liquidation
                setInterval(fetchOnChainData, 300000); // 5 dakikada bir on-chain
                setInterval(calculateTechnicalIndicators, 60000); // 1 dakikada bir teknik analiz
                
                console.log('✅ Gerçek zamanlı veri sistemi başlatıldı');
            } catch (error) {
                console.error('❌ Veri başlatma hatası:', error);
            }
        }

        function loadIndicators() {
            const container = document.getElementById('indicatorCategories');
            if (!container) return;
            
            container.innerHTML = '';
            Object.keys(indicatorCategories).forEach(category => {
                const indicators = indicatorCategories[category];
                const card = document.createElement('div');
                card.className = 'category-card';
                
                let color = '#4ecdc4';
                if (category.includes('MOMENTUM')) color = '#ffd700';
                else if (category.includes('SMART')) color = '#9b59b6';
                else if (category.includes('WHALE')) color = '#e74c3c';
                
                card.innerHTML = `
                    <div class="category-header">
                        <div class="category-title" style="color: ${color};">${category}</div>
                        <div class="category-count">${indicators.length}</div>
                    </div>
                    <div class="indicator-list">
                        ${indicators.map(ind => `
                            <div class="indicator-item">
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" value="${ind}" checked style="margin-right: 10px;">
                                    <span>${ind}</span>
                                </label>
                            </div>
                        `).join('')}
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function loadExchanges() {
            const container = document.getElementById('exchangeGrid');
            if (!container) return;
            
            container.innerHTML = '';
            exchanges.forEach(ex => {
                const card = document.createElement('div');
                card.className = `exchange-card ${ex.active ? 'active' : ''}`;
                card.onclick = () => toggleExchange(ex.name);
                card.innerHTML = `<div class="exchange-logo">${ex.logo}</div><div>${ex.name}</div>`;
                container.appendChild(card);
            });
        }

        function toggleExchange(name) {
            const ex = exchanges.find(e => e.name === name);
            if (ex) {
                ex.active = !ex.active;
                if (ex.active) {
                    if (!selectedExchanges.includes(name)) {
                        selectedExchanges.push(name);
                    }
                } else {
                    selectedExchanges = selectedExchanges.filter(e => e !== name);
                }
                loadExchanges();
            }
        }

        // ===== 7 BORSADAN TÜM COINLERİ ÇEKME =====
        async function fetchAllExchangeSymbols() {
            const allSymbols = new Set();
            
            // Binance - Tüm USDT çiftleri
            try {
                const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                const data = await response.json();
                if (data && data.symbols) {
                    data.symbols.forEach(s => {
                        if (s.status === 'TRADING' && s.symbol.endsWith('USDT')) {
                            allSymbols.add(s.symbol);
                        }
                    });
                }
                console.log(`✅ Binance: ${allSymbols.size} coin bulundu`);
            } catch (e) {
                console.error('Binance symbol hatası:', e);
            }
            
            // OKX - Tüm USDT çiftleri
            try {
                const response = await fetch('https://www.okx.com/api/v5/public/instruments?instType=SPOT');
                const data = await response.json();
                if (data && data.data) {
                    data.data.forEach(s => {
                        if (s.state === 'live' && s.settleCcy === 'USDT') {
                            allSymbols.add(s.instId.replace('-', ''));
                        }
                    });
                }
                console.log(`✅ OKX: Toplam ${allSymbols.size} coin`);
            } catch (e) {
                console.error('OKX symbol hatası:', e);
            }
            
            // Bybit - Tüm USDT çiftleri
            try {
                const response = await fetch('https://api.bybit.com/v5/market/instruments-info?category=spot');
                const data = await response.json();
                if (data && data.result && data.result.list) {
                    data.result.list.forEach(s => {
                        if (s.status === 'Trading' && s.quoteCoin === 'USDT') {
                            allSymbols.add(s.symbol);
                        }
                    });
                }
                console.log(`✅ Bybit: Toplam ${allSymbols.size} coin`);
            } catch (e) {
                console.error('Bybit symbol hatası:', e);
            }
            
            // MEXC - Tüm USDT çiftleri
            try {
                const response = await fetch('https://api.mexc.com/api/v3/exchangeInfo');
                const data = await response.json();
                if (data && data.symbols) {
                    data.symbols.forEach(s => {
                        if (s.status === 'ENABLED' && s.symbol.endsWith('USDT')) {
                            allSymbols.add(s.symbol);
                        }
                    });
                }
                console.log(`✅ MEXC: Toplam ${allSymbols.size} coin`);
            } catch (e) {
                console.error('MEXC symbol hatası:', e);
            }
            
            // KuCoin - Tüm USDT çiftleri
            try {
                const response = await fetch('https://api.kucoin.com/api/v1/symbols');
                const data = await response.json();
                if (data && data.data) {
                    data.data.forEach(s => {
                        if (s.enableTrading && s.symbol.endsWith('-USDT')) {
                            allSymbols.add(s.symbol.replace('-', ''));
                        }
                    });
                }
                console.log(`✅ KuCoin: Toplam ${allSymbols.size} coin`);
            } catch (e) {
                console.error('KuCoin symbol hatası:', e);
            }
            
            // Gate.io - Tüm USDT çiftleri
            try {
                const response = await fetch('https://api.gateio.ws/api/v4/spot/currency_pairs');
                const data = await response.json();
                if (Array.isArray(data)) {
                    data.forEach(s => {
                        if (s.trade_status === 'tradable' && s.quote === 'USDT') {
                            allSymbols.add(s.base + s.quote);
                        }
                    });
                }
                console.log(`✅ Gate.io: Toplam ${allSymbols.size} coin`);
            } catch (e) {
                console.error('Gate.io symbol hatası:', e);
            }
            
            // Huobi - Tüm USDT çiftleri
            try {
                const response = await fetch('https://api.huobi.pro/market/symbols');
                const data = await response.json();
                if (data && data.data) {
                    data.data.forEach(s => {
                        if (s.state === 'online' && s.quoteCurrency === 'usdt') {
                            allSymbols.add(s.baseCurrency.toUpperCase() + 'USDT');
                        }
                    });
                }
                console.log(`✅ Huobi: Toplam ${allSymbols.size} coin`);
            } catch (e) {
                console.error('Huobi symbol hatası:', e);
            }
            
            return Array.from(allSymbols);
        }
        
        // ===== 7 BORSADAN GERÇEK ZAMANLI FİYAT ÇEKME =====
        async function fetchRealPrices() {
            try {
                console.log('💰 7 BORSADAN TÜM COINLER ÇEKİLİYOR...');
                
                // Önce tüm coin listesini al
                const allSymbols = await fetchAllExchangeSymbols();
                console.log(`📊 Toplam ${allSymbols.length} benzersiz coin bulundu`);
                
                // Her borsadan seçilen coinler için fiyat çek
                const pricePromises = [];
                
                // Binance
                if (selectedExchanges.includes('Binance')) {
                    const binanceSymbols = allSymbols.filter(s => s.length <= 12); // Binance format kontrolü
                    for (const symbol of binanceSymbols.slice(0, 100)) { // Rate limit için sınırla
                        pricePromises.push(
                            fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`)
                                .then(res => res.json())
                                .then(data => ({ symbol, data, exchange: 'Binance' }))
                                .catch(() => null)
                        );
                    }
                }
                
                // OKX
                if (selectedExchanges.includes('OKX')) {
                    const okxSymbols = allSymbols.slice(0, 50); // Rate limit için sınırla
                    okxSymbols.forEach(symbol => {
                        const okxSymbol = symbol.replace('USDT', '-USDT');
                        pricePromises.push(
                            fetch(`https://www.okx.com/api/v5/market/ticker?instId=${okxSymbol}`)
                                .then(res => res.json())
                                .then(data => ({ symbol, data: data.data?.[0], exchange: 'OKX' }))
                                .catch(() => null)
                        );
                    });
                }
                
                // Bybit
                if (selectedExchanges.includes('Bybit')) {
                    const bybitSymbols = allSymbols.slice(0, 50);
                    bybitSymbols.forEach(symbol => {
                        pricePromises.push(
                            fetch(`https://api.bybit.com/v5/market/tickers?category=spot&symbol=${symbol}`)
                                .then(res => res.json())
                                .then(data => ({ symbol, data: data.result?.list?.[0], exchange: 'Bybit' }))
                                .catch(() => null)
                        );
                    });
                }
                
                // MEXC
                if (selectedExchanges.includes('MEXC')) {
                    const mexcSymbols = allSymbols.slice(0, 50);
                    mexcSymbols.forEach(symbol => {
                        pricePromises.push(
                            fetch(`https://api.mexc.com/api/v3/ticker/24hr?symbol=${symbol}`)
                                .then(res => res.json())
                                .then(data => ({ symbol, data, exchange: 'MEXC' }))
                                .catch(() => null)
                        );
                    });
                }
                
                // KuCoin
                if (selectedExchanges.includes('KuCoin')) {
                    const kucoinSymbols = allSymbols.slice(0, 50);
                    kucoinSymbols.forEach(symbol => {
                        const kucoinSymbol = symbol.replace('USDT', '-USDT');
                        pricePromises.push(
                            fetch(`https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${kucoinSymbol}`)
                                .then(res => res.json())
                                .then(data => ({ 
                                    symbol, 
                                    data: data.data ? {
                                        lastPrice: data.data.price,
                                        priceChangePercent: '0'
                                    } : null,
                                    exchange: 'KuCoin' 
                                }))
                                .catch(() => null)
                        );
                    });
                }
                
                // Gate.io
                if (selectedExchanges.includes('Gate.io')) {
                    const gateSymbols = allSymbols.slice(0, 50);
                    gateSymbols.forEach(symbol => {
                        const base = symbol.replace('USDT', '');
                        pricePromises.push(
                            fetch(`https://api.gateio.ws/api/v4/spot/tickers?currency_pair=${base}_USDT`)
                                .then(res => res.json())
                                .then(data => ({ symbol, data: data?.[0], exchange: 'Gate.io' }))
                                .catch(() => null)
                        );
                    });
                }
                
                // Huobi
                if (selectedExchanges.includes('Huobi')) {
                    const huobiSymbols = allSymbols.slice(0, 50);
                    huobiSymbols.forEach(symbol => {
                        const base = symbol.replace('USDT', '').toLowerCase();
                        pricePromises.push(
                            fetch(`https://api.huobi.pro/market/detail/merged?symbol=${base}usdt`)
                                .then(res => res.json())
                                .then(data => ({ 
                                    symbol, 
                                    data: data.tick ? {
                                        close: data.tick.close,
                                        change: ((data.tick.close - data.tick.open) / data.tick.open * 100).toFixed(2)
                                    } : null,
                                    exchange: 'Huobi' 
                                }))
                                .catch(() => null)
                        );
                    });
                }
                
                // Tüm istekleri çalıştır (batch'ler halinde)
                const batchSize = 50;
                const results = [];
                
                for (let i = 0; i < pricePromises.length; i += batchSize) {
                    const batch = pricePromises.slice(i, i + batchSize);
                    const batchResults = await Promise.all(batch);
                    results.push(...batchResults.filter(r => r && r.data));
                    
                    // Rate limit için bekleme
                    if (i + batchSize < pricePromises.length) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                const tickers = results;
                
                // Tüm borsalardan gelen verileri parse et
                tickers.forEach(result => {
                    if (!result || !result.symbol || !result.data) return;
                    
                    const pair = result.symbol.replace('USDT', '/USDT');
                    const exchange = result.exchange;
                    const data = result.data;
                    
                    let priceData = null;
                    
                    // Binance formatı
                    if (exchange === 'Binance' && data.lastPrice) {
                        priceData = {
                            price: parseFloat(data.lastPrice),
                            change: parseFloat(data.priceChangePercent || 0),
                            volume: parseFloat(data.volume || 0),
                            high24h: parseFloat(data.highPrice || 0),
                            low24h: parseFloat(data.lowPrice || 0),
                            open24h: parseFloat(data.openPrice || 0),
                            close24h: parseFloat(data.lastPrice || 0),
                            source: 'Binance',
                            exchange: 'Binance'
                        };
                    }
                    // OKX formatı
                    else if (exchange === 'OKX' && data.last) {
                        priceData = {
                            price: parseFloat(data.last),
                            change: parseFloat(data.last24hChangePercent || data.changePercent24h || 0) * 100,
                            volume: parseFloat(data.vol24h || data.volume24h || 0),
                            high24h: parseFloat(data.high24h || data.high_24h || 0),
                            low24h: parseFloat(data.low24h || data.low_24h || 0),
                            open24h: parseFloat(data.open24h || data.open_24h || 0),
                            close24h: parseFloat(data.last || 0),
                            source: 'OKX',
                            exchange: 'OKX'
                        };
                    }
                    // Bybit formatı
                    else if (exchange === 'Bybit' && data.lastPrice) {
                        priceData = {
                            price: parseFloat(data.lastPrice),
                            change: parseFloat(data.price24hPcnt || 0) * 100,
                            volume: parseFloat(data.volume24h || 0),
                            high24h: parseFloat(data.highPrice24h || 0),
                            low24h: parseFloat(data.lowPrice24h || 0),
                            open24h: parseFloat(data.prevPrice24h || 0),
                            close24h: parseFloat(data.lastPrice || 0),
                            source: 'Bybit',
                            exchange: 'Bybit'
                        };
                    }
                    // MEXC formatı
                    else if (exchange === 'MEXC' && data.lastPrice) {
                        priceData = {
                            price: parseFloat(data.lastPrice),
                            change: parseFloat(data.priceChangePercent || 0),
                            volume: parseFloat(data.volume || 0),
                            high24h: parseFloat(data.highPrice || 0),
                            low24h: parseFloat(data.lowPrice || 0),
                            open24h: parseFloat(data.openPrice || 0),
                            close24h: parseFloat(data.lastPrice || 0),
                            source: 'MEXC',
                            exchange: 'MEXC'
                        };
                    }
                    // KuCoin formatı
                    else if (exchange === 'KuCoin' && data.lastPrice) {
                        priceData = {
                            price: parseFloat(data.lastPrice),
                            change: parseFloat(data.priceChangePercent || 0),
                            volume: 0,
                            high24h: 0,
                            low24h: 0,
                            open24h: 0,
                            close24h: parseFloat(data.lastPrice || 0),
                            source: 'KuCoin',
                            exchange: 'KuCoin'
                        };
                    }
                    // Gate.io formatı
                    else if (exchange === 'Gate.io' && data.last) {
                        priceData = {
                            price: parseFloat(data.last),
                            change: parseFloat(data.change_percentage || 0),
                            volume: parseFloat(data.base_volume || 0),
                            high24h: parseFloat(data.high_24h || 0),
                            low24h: parseFloat(data.low_24h || 0),
                            open24h: parseFloat(data.open_24h || 0),
                            close24h: parseFloat(data.last || 0),
                            source: 'Gate.io',
                            exchange: 'Gate.io'
                        };
                    }
                    // Huobi formatı
                    else if (exchange === 'Huobi' && data.close) {
                        priceData = {
                            price: parseFloat(data.close),
                            change: parseFloat(data.change || 0),
                            volume: 0,
                            high24h: 0,
                            low24h: 0,
                            open24h: 0,
                            close24h: parseFloat(data.close || 0),
                            source: 'Huobi',
                            exchange: 'Huobi'
                        };
                    }
                    
                    // Eğer coin zaten varsa, en iyi veriyi seç (en yüksek volume veya en güncel)
                    if (priceData) {
                        if (!realPrices[pair] || (realPrices[pair].volume < priceData.volume)) {
                            realPrices[pair] = priceData;
                        }
                    }
                });
                
                // CoinGecko fallback eksik coinler için
                const cgMap = {
                    'BTC/USDT': 'bitcoin',
                    'ETH/USDT': 'ethereum',
                    'BNB/USDT': 'binancecoin',
                    'SOL/USDT': 'solana',
                    'XRP/USDT': 'ripple',
                    'ADA/USDT': 'cardano',
                    'DOGE/USDT': 'dogecoin',
                    'DOT/USDT': 'polkadot',
                    'MATIC/USDT': 'matic-network',
                    'AVAX/USDT': 'avalanche-2',
                    'LINK/USDT': 'chainlink',
                    'UNI/USDT': 'uniswap',
                    'ATOM/USDT': 'cosmos',
                    'LTC/USDT': 'litecoin'
                };
                
                Object.keys(cgMap).forEach(pair => {
                    if (!realPrices[pair] && cgData[cgMap[pair]]) {
                        const coinData = cgData[cgMap[pair]];
                        realPrices[pair] = {
                            price: coinData.usd,
                            change: coinData.usd_24h_change || 0,
                            volume: coinData.usd_24h_vol || 0,
                            source: 'CoinGecko'
                        };
                    }
                });
                
                console.log(`✅ 7 BORSADAN TOPLAM ${Object.keys(realPrices).length} COIN GÜNCELLENDI!`);
                console.log('Gerçek zamanlı fiyatlar:', realPrices);
                
                // UI'da coin sayısını göster
                updateCoinCount();
                
                // Fiyatlar güncellendiğinde UI'ı güncelle
                updatePriceDisplays();
                
                // Teknik analiz hesapla (sadece popüler coinler için - performans için)
                await calculateTechnicalIndicators();
                
            } catch (error) {
                console.error('❌ Fiyat hatası:', error);
            }
        }
        
        // ===== WEB SOCKET GERÇEK ZAMANLI BAĞLANTI =====
        function connectBinanceWebSocket() {
            const symbols = ['btcusdt', 'ethusdt', 'bnbusdt', 'solusdt'];
            const streams = symbols.map(s => `${s}@ticker`).join('/');
            const wsUrl = `wss://stream.binance.com:9443/stream?streams=${streams}`;
            
            // Eğer mevcut bağlantı varsa kapat
            if (websocketConnections['binance']) {
                websocketConnections['binance'].close();
            }
            
            try {
                const ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    console.log('🔌 Binance WebSocket bağlandı');
                    websocketConnections['binance'] = ws;
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.stream && data.data) {
                        const symbol = data.stream.split('@')[0].toUpperCase();
                        const ticker = data.data;
                        
                        // Symbol mapping
                        const symbolMap = {
                            'BTCUSDT': 'BTC/USDT',
                            'ETHUSDT': 'ETH/USDT',
                            'BNBUSDT': 'BNB/USDT',
                            'SOLUSDT': 'SOL/USDT'
                        };
                        
                        const pair = symbolMap[symbol];
                        if (pair && realPrices[pair]) {
                            realPrices[pair].price = parseFloat(ticker.c);
                            realPrices[pair].change = parseFloat(ticker.P);
                            realPrices[pair].volume = parseFloat(ticker.v);
                            realPrices[pair].high24h = parseFloat(ticker.h);
                            realPrices[pair].low24h = parseFloat(ticker.l);
                            realPrices[pair].open24h = parseFloat(ticker.o);
                            
                            // UI'ı güncelle
                            updatePriceDisplay(pair);
                        }
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('❌ WebSocket hatası:', error);
                };
                
                ws.onclose = () => {
                    console.log('🔌 WebSocket bağlantısı kapandı, yeniden bağlanılıyor...');
                    setTimeout(connectBinanceWebSocket, 5000);
                };
                
            } catch (error) {
                console.error('❌ WebSocket bağlantı hatası:', error);
            }
        }
        
        // ===== OKX WEBSOCKET BAĞLANTISI =====
        function connectOKXWebSocket() {
            try {
                const ws = new WebSocket(OKX_WS);
                
                ws.onopen = () => {
                    console.log('🔌 OKX WebSocket bağlandı');
                    websocketConnections['okx'] = ws;
                    
                    // Subscribe to ticker channels
                    const symbols = ['BTC-USDT', 'ETH-USDT', 'SOL-USDT'];
                    symbols.forEach(symbol => {
                        ws.send(JSON.stringify({
                            op: 'subscribe',
                            args: [{ channel: 'tickers', instId: symbol }]
                        }));
                    });
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    
                    if (data.data && Array.isArray(data.data)) {
                        data.data.forEach(ticker => {
                            const symbol = ticker.instId;
                            const pair = symbol.replace('-', '/');
                            
                            if (realPrices[pair]) {
                                realPrices[pair].price = parseFloat(ticker.last);
                                realPrices[pair].change = parseFloat(ticker.sodUtc8) || 0;
                                realPrices[pair].volume = parseFloat(ticker.vol24h) || 0;
                                realPrices[pair].high24h = parseFloat(ticker.high24h);
                                realPrices[pair].low24h = parseFloat(ticker.low24h);
                                realPrices[pair].source = 'OKX';
                                
                                updatePriceDisplay(pair);
                            }
                        });
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('❌ OKX WebSocket hatası:', error);
                };
                
                ws.onclose = () => {
                    console.log('🔌 OKX WebSocket kapandı, yeniden bağlanılıyor...');
                    setTimeout(connectOKXWebSocket, 5000);
                };
                
            } catch (error) {
                console.error('❌ OKX WebSocket bağlantı hatası:', error);
            }
        }
        
        // ===== BYBIT WEBSOCKET BAĞLANTISI =====
        function connectBybitWebSocket() {
            try {
                const ws = new WebSocket(BYBIT_WS);
                
                ws.onopen = () => {
                    console.log('🔌 Bybit WebSocket bağlandı');
                    websocketConnections['bybit'] = ws;
                    
                    // Subscribe to ticker channels
                    const symbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
                    ws.send(JSON.stringify({
                        op: 'subscribe',
                        args: symbols.map(s => `tickers.${s}`)
                    }));
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    
                    if (data.topic && data.data) {
                        const symbol = data.topic.split('.')[1];
                        const pair = symbol.replace('USDT', '/USDT');
                        const ticker = data.data;
                        
                        if (realPrices[pair]) {
                            realPrices[pair].price = parseFloat(ticker.lastPrice);
                            realPrices[pair].change = parseFloat(ticker.price24hPcnt) * 100;
                            realPrices[pair].volume = parseFloat(ticker.volume24h);
                            realPrices[pair].high24h = parseFloat(ticker.highPrice24h);
                            realPrices[pair].low24h = parseFloat(ticker.lowPrice24h);
                            realPrices[pair].source = 'Bybit';
                            
                            updatePriceDisplay(pair);
                        }
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('❌ Bybit WebSocket hatası:', error);
                };
                
                ws.onclose = () => {
                    console.log('🔌 Bybit WebSocket kapandı, yeniden bağlanılıyor...');
                    setTimeout(connectBybitWebSocket, 5000);
                };
                
            } catch (error) {
                console.error('❌ Bybit WebSocket bağlantı hatası:', error);
            }
        }
        
        // ===== GERÇEK FEAR & GREED INDEX =====
        async function fetchFearGreedIndex() {
            try {
                // Alternative.me API kullanarak gerçek Fear & Greed Index
                const response = await fetch('https://api.alternative.me/fng/?limit=1');
                const data = await response.json();
                
                if (data.data && data.data.length > 0) {
                    fearGreedIndex = {
                        value: parseInt(data.data[0].value),
                        classification: data.data[0].value_classification,
                        timestamp: data.data[0].timestamp
                    };
                    
                    updateFearGreedDisplay();
                    console.log('✅ Fear & Greed Index güncellendi:', fearGreedIndex);
                }
            } catch (error) {
                console.error('❌ Fear & Greed Index hatası:', error);
                // Fallback değer
                fearGreedIndex = { value: 50, classification: 'Neutral' };
            }
        }
        
        // ===== GERÇEK FUNDING RATES (Binance Futures) =====
        async function fetchFundingRates() {
            try {
                const symbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
                const rates = {};
                
                for (const symbol of symbols) {
                    try {
                        // Binance Futures API
                        const response = await fetch(`https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${symbol}`);
                        const data = await response.json();
                        
                        if (data && data.lastFundingRate !== undefined) {
                            rates[symbol] = {
                                fundingRate: parseFloat(data.lastFundingRate) * 100,
                                nextFundingTime: data.nextFundingTime,
                                markPrice: parseFloat(data.markPrice),
                                indexPrice: parseFloat(data.indexPrice),
                                estimatedSettlePrice: parseFloat(data.estimatedSettlePrice || 0)
                            };
                        }
                    } catch (e) {
                        // Fallback: Spot premiumIndex
                        try {
                            const spotResponse = await fetch(`https://api.binance.com/api/v3/premiumIndex?symbol=${symbol}`);
                            const spotData = await spotResponse.json();
                            
                            if (spotData && spotData.lastFundingRate !== undefined) {
                                rates[symbol] = {
                                    fundingRate: parseFloat(spotData.lastFundingRate) * 100,
                                    markPrice: parseFloat(spotData.markPrice || spotData.lastPrice || 0),
                                    indexPrice: parseFloat(spotData.indexPrice || spotData.lastPrice || 0)
                                };
                            }
                        } catch (e2) {
                            console.error(`Funding rate hatası ${symbol}:`, e2);
                        }
                    }
                }
                
                fundingRates = rates;
                console.log('✅ Funding rates güncellendi:', fundingRates);
                
                // Funding rates görselleştirmesini güncelle
                updateFundingRatesDisplay();
            } catch (error) {
                console.error('❌ Funding rates hatası:', error);
            }
        }
        
        // ===== GERÇEK ON-CHAIN VERİLER =====
        async function fetchOnChainData() {
            try {
                // CoinGecko on-chain metrics (ücretsiz endpoint)
                const coins = ['bitcoin', 'ethereum'];
                const onChain = {};
                
                for (const coinId of coins) {
                    try {
                        // CoinGecko'nun basit metrics API'si
                        const response = await fetch(
                            `https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false`,
                            { headers: { 'x-cg-demo-api-key': API_KEYS.COINGECKO } }
                        );
                        const data = await response.json();
                        
                        if (data && data.market_data) {
                            const symbol = coinId === 'bitcoin' ? 'BTC/USDT' : 'ETH/USDT';
                            onChain[symbol] = {
                                totalSupply: data.market_data.total_supply,
                                circulatingSupply: data.market_data.circulating_supply,
                                marketCap: data.market_data.market_cap?.usd || 0,
                                fullyDilutedValuation: data.market_data.fully_diluted_valuation?.usd || 0,
                                totalValueLocked: data.market_data.total_value_locked || null,
                                mcapToTvlRatio: data.market_data.mcap_to_tvl_ratio || null,
                                lastUpdate: Date.now()
                            };
                        }
                    } catch (e) {
                        console.error(`On-chain data hatası ${coinId}:`, e);
                    }
                }
                
                // Blockchain.com API (Bitcoin için ücretsiz)
                try {
                    const btcResponse = await fetch('https://blockchain.info/stats?format=json');
                    const btcData = await btcResponse.json();
                    
                    if (btcData && onChain['BTC/USDT']) {
                        onChain['BTC/USDT'].hashRate = btcData.hash_rate;
                        onChain['BTC/USDT'].difficulty = btcData.difficulty;
                        onChain['BTC/USDT'].totalBitcoins = btcData.totalbc / 100000000;
                        onChain['BTC/USDT'].transactions24h = btcData.n_tx;
                    }
                } catch (e) {
                    console.error('Bitcoin on-chain hatası:', e);
                }
                
                onChainData = onChain;
                console.log('✅ On-chain veriler güncellendi:', onChainData);
            } catch (error) {
                console.error('❌ On-chain veriler hatası:', error);
            }
        }
        
        // ===== GERÇEK LİKİDASYON VERİLERİ (Binance Futures) =====
        async function fetchLiquidationData() {
            try {
                // Binance futures liquidation data
                const symbols = ['BTCUSDT', 'ETHUSDT'];
                const liquidations = {};
                
                for (const symbol of symbols) {
                    try {
                        // Binance futures liquidation snipes API (public)
                        const response = await fetch(`https://fapi.binance.com/fapi/v1/forceOrders?symbol=${symbol}&limit=100`);
                        const data = await response.json();
                        
                        if (Array.isArray(data)) {
                            const longLiq = data.filter(d => d.side === 'BUY').reduce((sum, d) => sum + parseFloat(d.executedQty), 0);
                            const shortLiq = data.filter(d => d.side === 'SELL').reduce((sum, d) => sum + parseFloat(d.executedQty), 0);
                            
                            liquidations[symbol] = {
                                longLiquidation: longLiq,
                                shortLiquidation: shortLiq,
                                total: longLiq + shortLiq,
                                timestamp: Date.now()
                            };
                        }
                    } catch (e) {
                        console.error(`Liquidation data hatası ${symbol}:`, e);
                    }
                }
                
                liquidationData = liquidations;
                console.log('✅ Liquidation data güncellendi:', liquidationData);
            } catch (error) {
                console.error('❌ Liquidation data hatası:', error);
            }
        }
        
        // ===== GERÇEK TEKNİK ANALİZ HESAPLAMA (OPTİMİZE EDİLMİŞ) =====
        async function calculateTechnicalIndicators() {
            try {
                // Performans için: En çok volume'u olan coinlerden başla
                const allPairs = Object.keys(realPrices);
                const sortedPairs = allPairs
                    .map(pair => ({ pair, volume: realPrices[pair].volume || 0 }))
                    .sort((a, b) => b.volume - a.volume)
                    .slice(0, 50) // En fazla 50 coin için teknik analiz (performans için)
                    .map(item => item.pair.replace('/USDT', 'USDT'));
                
                const symbols = sortedPairs.length > 0 ? sortedPairs : ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT'];
                console.log(`📊 ${symbols.length} coin için teknik analiz hesaplanıyor... (Paralel işleme ile)`);
                
                // PARALEL İŞLEME - 10'ar 10'ar batch halinde
                const batchSize = 10;
                for (let i = 0; i < symbols.length; i += batchSize) {
                    const batch = symbols.slice(i, i + batchSize);
                    const promises = batch.map(symbol => processSymbolIndicators(symbol));
                    await Promise.all(promises);
                    
                    // Rate limit için kısa bekleme
                    if (i + batchSize < symbols.length) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
                
                console.log('✅ Teknik analiz hesaplandı:', technicalIndicators);
            } catch (error) {
                console.error('❌ Teknik analiz hatası:', error);
            }
        }
        
        // Tek bir symbol için indikatör hesaplama (paralel işleme için)
        async function processSymbolIndicators(symbol) {
            try {
                // Binance kline API - son 200 mum
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${selectedTimeframe}&limit=200`);
                const klines = await response.json();
                
                if (klines && klines.length > 0) {
                    const closes = klines.map(k => parseFloat(k[4])); // Close prices
                    const highs = klines.map(k => parseFloat(k[2])); // High prices
                    const lows = klines.map(k => parseFloat(k[3])); // Low prices
                    const volumes = klines.map(k => parseFloat(k[5])); // Volumes
                    
                    const pair = symbol.replace('USDT', '/USDT');
                    
                    // RSI hesapla
                    const rsi = calculateRSI(closes, 14);
                    
                    // MACD hesapla
                    const macd = calculateMACD(closes);
                    
                    // EMA hesapla
                    const ema9 = calculateEMA(closes, 9);
                    const ema21 = calculateEMA(closes, 21);
                    const ema50 = calculateEMA(closes, 50);
                    
                    // Bollinger Bands
                    const bb = calculateBollingerBands(closes, 20);
                    
                    // Volume analizi
                    const avgVolume = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;
                    const currentVolume = volumes[volumes.length - 1];
                    const volumeRatio = currentVolume / avgVolume;
                    
                    // Daha fazla indikatör hesapla
                    const stochastic = calculateStochastic(highs, lows, closes, 14);
                    const adx = calculateADX(highs, lows, closes, 14);
                    const atr = calculateATR(highs, lows, closes, 14);
                    const vwap = calculateVWAP(klines);
                    const cvd = calculateCVD(klines);
                    
                    // Smart Money Concepts
                    const detectedOB = detectOrderBlocks(klines);
                    const detectedFVG = detectFVG(klines);
                    
                    // 90 İndikatör analizi
                    const indicators90 = calculate90Indicators(klines, currentVolume, avgVolume);
                    
                    // Institutional analiz
                    const institutional = analyzeInstitutional(klines, volumes);
                    
                    // Whale analiz
                    const whales = analyzeWhales(klines, avgVolume);
                    
                    // Market Makers analiz
                    const marketMakers = analyzeMarketMakers(klines);
                    
                    // Smart Money Concepts detaylı
                    const smartMoneyConcepts = analyzeSmartMoneyConcepts(klines);
                    
                    // Trader analiz
                    const traders = analyzeTraders(klines, institutional);
                    
                    // Stratejik analizler
                    const pumpDump = analyzePumpDump(klines, bb, currentVolume, avgVolume);
                    const trendBreak = analyzeTrendBreak(klines);
                    const peaksAndDips = analyzePeaksAndDips(klines);
                    
                    // === YENİ: GELİŞMİŞ KURUMSAL TEKNİKLER ===
                    const orderFlowDelta = calculateOrderFlowDelta(klines);
                    const liquiditySweeps = detectLiquiditySweeps(klines);
                    const premiumDiscount = calculatePremiumDiscountZones(klines);
                    const advancedVolumeProfile = calculateAdvancedVolumeProfile(klines);
                    const sessionAnalysis = analyzeTradingSessions();
                    const tapeReading = analyzeTapeReading(klines);
                    
                    // Order Blocks ve FVG'leri kaydet
                    orderBlocks[pair] = detectedOB;
                    fvgData[pair] = detectedFVG;
                    
                    // CVD'yi kaydet
                    cvdData[pair] = cvd;
                    
                    technicalIndicators[pair] = {
                        rsi: rsi[rsi.length - 1],
                        macd: macd.macd[macd.macd.length - 1],
                        macdSignal: macd.signal[macd.signal.length - 1],
                        macdHistogram: macd.histogram[macd.histogram.length - 1],
                        ema9: ema9[ema9.length - 1],
                        ema21: ema21[ema21.length - 1],
                        ema50: ema50[ema50.length - 1],
                        bbUpper: bb.upper[bb.upper.length - 1],
                        bbMiddle: bb.middle[bb.middle.length - 1],
                        bbLower: bb.lower[bb.lower.length - 1],
                        volumeRatio: volumeRatio,
                        trend: ema9[ema9.length - 1] > ema21[ema21.length - 1] ? 'UP' : 'DOWN',
                        stochastic: stochastic.k[stochastic.k.length - 1],
                        stochasticD: stochastic.d[stochastic.d.length - 1],
                        adx: adx[adx.length - 1],
                        atr: atr[atr.length - 1],
                        vwap: vwap[vwap.length - 1],
                        cvd: cvd.current,
                        cvdTrend: cvd.trend,
                        cvdChange: cvd.change,
                        orderBlocks: detectedOB.length,
                        fvg: detectedFVG.length,
                        candles: klines.length,
                        lastUpdate: Date.now(),
                        // Yeni eklenen detaylı analizler
                        indicators90: indicators90,
                        institutional: institutional,
                        whales: whales,
                        marketMakers: marketMakers,
                        smartMoneyConcepts: smartMoneyConcepts,
                        traders: traders,
                        pumpDump: pumpDump,
                        trendBreak: trendBreak,
                        peaksAndDips: peaksAndDips,
                        // Yeni gelişmiş teknikler
                        orderFlowDelta: orderFlowDelta,
                        liquiditySweeps: liquiditySweeps,
                        premiumDiscount: premiumDiscount,
                        advancedVolumeProfile: advancedVolumeProfile,
                        sessionAnalysis: sessionAnalysis,
                        tapeReading: tapeReading
                    };
                }
            } catch (e) {
                console.error(`Teknik analiz hatası ${symbol}:`, e);
            }
        }
        
        // ===== TEKNİK İNDİKATÖR HESAPLAMA FONKSİYONLARI =====
        function calculateRSI(prices, period = 14) {
            const changes = [];
            for (let i = 1; i < prices.length; i++) {
                changes.push(prices[i] - prices[i - 1]);
            }
            
            const gains = changes.map(c => c > 0 ? c : 0);
            const losses = changes.map(c => c < 0 ? -c : 0);
            
            const rsi = [];
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
            
            for (let i = period; i < gains.length; i++) {
                avgGain = (avgGain * (period - 1) + gains[i]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
                
                const rs = avgGain / avgLoss;
                const rsiValue = 100 - (100 / (1 + rs));
                rsi.push(rsiValue);
            }
            
            return rsi;
        }
        
        function calculateEMA(prices, period) {
            const ema = [];
            const multiplier = 2 / (period + 1);
            
            // İlk EMA değeri SMA
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += prices[i];
            }
            ema.push(sum / period);
            
            // Geri kalan EMA hesapla
            for (let i = period; i < prices.length; i++) {
                const emaValue = (prices[i] - ema[ema.length - 1]) * multiplier + ema[ema.length - 1];
                ema.push(emaValue);
            }
            
            return ema;
        }
        
        function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const fastEMA = calculateEMA(prices, fastPeriod);
            const slowEMA = calculateEMA(prices, slowPeriod);
            
            // MACD line = Fast EMA - Slow EMA
            const macd = [];
            const offset = slowPeriod - fastPeriod;
            for (let i = 0; i < slowEMA.length; i++) {
                if (fastEMA[i + offset]) {
                    macd.push(fastEMA[i + offset] - slowEMA[i]);
                }
            }
            
            // Signal line = EMA of MACD
            const signal = calculateEMA(macd, signalPeriod);
            
            // Histogram = MACD - Signal
            const histogram = [];
            const signalOffset = macd.length - signal.length;
            for (let i = 0; i < signal.length; i++) {
                histogram.push(macd[i + signalOffset] - signal[i]);
            }
            
            return { macd, signal, histogram };
        }
        
        function calculateBollingerBands(prices, period = 20, stdDev = 2) {
            const sma = [];
            const upper = [];
            const lower = [];
            
            for (let i = period - 1; i < prices.length; i++) {
                const slice = prices.slice(i - period + 1, i + 1);
                const mean = slice.reduce((a, b) => a + b, 0) / period;
                
                const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;
                const standardDeviation = Math.sqrt(variance);
                
                sma.push(mean);
                upper.push(mean + (stdDev * standardDeviation));
                lower.push(mean - (stdDev * standardDeviation));
            }
            
            return { middle: sma, upper, lower };
        }
        
        // ===== STOCHASTIC OSCILLATOR =====
        function calculateStochastic(highs, lows, closes, period = 14, smoothK = 3, smoothD = 3) {
            const k = [];
            const d = [];
            
            for (let i = period - 1; i < closes.length; i++) {
                const highSlice = highs.slice(i - period + 1, i + 1);
                const lowSlice = lows.slice(i - period + 1, i + 1);
                const close = closes[i];
                
                const highestHigh = Math.max(...highSlice);
                const lowestLow = Math.min(...lowSlice);
                
                const kValue = ((close - lowestLow) / (highestHigh - lowestLow)) * 100;
                k.push(kValue);
            }
            
            // Smooth K (%K)
            const smoothedK = [];
            for (let i = smoothK - 1; i < k.length; i++) {
                const kSlice = k.slice(i - smoothK + 1, i + 1);
                smoothedK.push(kSlice.reduce((a, b) => a + b, 0) / smoothK);
            }
            
            // Smooth D (%D = SMA of %K)
            for (let i = smoothD - 1; i < smoothedK.length; i++) {
                const dSlice = smoothedK.slice(i - smoothD + 1, i + 1);
                d.push(dSlice.reduce((a, b) => a + b, 0) / smoothD);
            }
            
            return { k: smoothedK, d };
        }
        
        // ===== ADX (Average Directional Index) =====
        function calculateADX(highs, lows, closes, period = 14) {
            const tr = [];
            const plusDM = [];
            const minusDM = [];
            
            // True Range ve Directional Movement hesapla
            for (let i = 1; i < closes.length; i++) {
                const tr1 = highs[i] - lows[i];
                const tr2 = Math.abs(highs[i] - closes[i - 1]);
                const tr3 = Math.abs(lows[i] - closes[i - 1]);
                tr.push(Math.max(tr1, tr2, tr3));
                
                const upMove = highs[i] - highs[i - 1];
                const downMove = lows[i - 1] - lows[i];
                
                if (upMove > downMove && upMove > 0) {
                    plusDM.push(upMove);
                    minusDM.push(0);
                } else if (downMove > upMove && downMove > 0) {
                    plusDM.push(0);
                    minusDM.push(downMove);
                } else {
                    plusDM.push(0);
                    minusDM.push(0);
                }
            }
            
            // Smoothed TR, +DM, -DM
            const atr = calculateATR(highs, lows, closes, period);
            const plusDI = [];
            const minusDI = [];
            
            for (let i = period - 1; i < tr.length; i++) {
                const trSlice = tr.slice(i - period + 1, i + 1);
                const plusDMSlice = plusDM.slice(i - period + 1, i + 1);
                const minusDMSlice = minusDM.slice(i - period + 1, i + 1);
                
                const atrValue = atr[i - period + 1];
                plusDI.push((plusDMSlice.reduce((a, b) => a + b, 0) / trSlice.reduce((a, b) => a + b, 0)) * 100);
                minusDI.push((minusDMSlice.reduce((a, b) => a + b, 0) / trSlice.reduce((a, b) => a + b, 0)) * 100);
            }
            
            // DX ve ADX hesapla
            const dx = [];
            for (let i = 0; i < plusDI.length; i++) {
                const diSum = plusDI[i] + minusDI[i];
                const diDiff = Math.abs(plusDI[i] - minusDI[i]);
                if (diSum > 0) {
                    dx.push((diDiff / diSum) * 100);
                } else {
                    dx.push(0);
                }
            }
            
            // ADX = SMA of DX
            const adx = [];
            for (let i = period - 1; i < dx.length; i++) {
                const dxSlice = dx.slice(i - period + 1, i + 1);
                adx.push(dxSlice.reduce((a, b) => a + b, 0) / period);
            }
            
            return adx;
        }
        
        // ===== ATR (Average True Range) =====
        function calculateATR(highs, lows, closes, period = 14) {
            const tr = [];
            
            for (let i = 1; i < closes.length; i++) {
                const tr1 = highs[i] - lows[i];
                const tr2 = Math.abs(highs[i] - closes[i - 1]);
                const tr3 = Math.abs(lows[i] - closes[i - 1]);
                tr.push(Math.max(tr1, tr2, tr3));
            }
            
            // ATR = EMA of TR
            const atr = [];
            let sum = tr.slice(0, period).reduce((a, b) => a + b, 0);
            atr.push(sum / period);
            
            const multiplier = 2 / (period + 1);
            for (let i = period; i < tr.length; i++) {
                const atrValue = (tr[i] - atr[atr.length - 1]) * multiplier + atr[atr.length - 1];
                atr.push(atrValue);
            }
            
            return atr;
        }
        
        // ===== VWAP (Volume Weighted Average Price) =====
        function calculateVWAP(klines) {
            const vwap = [];
            let cumulativeTPV = 0; // Typical Price * Volume
            let cumulativeVolume = 0;
            
            for (let i = 0; i < klines.length; i++) {
                const k = klines[i];
                const high = parseFloat(k[2]);
                const low = parseFloat(k[3]);
                const close = parseFloat(k[4]);
                const volume = parseFloat(k[5]);
                
                const typicalPrice = (high + low + close) / 3;
                const tpv = typicalPrice * volume;
                
                cumulativeTPV += tpv;
                cumulativeVolume += volume;
                
                if (cumulativeVolume > 0) {
                    vwap.push(cumulativeTPV / cumulativeVolume);
                } else {
                    vwap.push(close);
                }
            }
            
            return vwap;
        }
        
        // ===== CVD (Cumulative Volume Delta) =====
        function calculateCVD(klines) {
            let cvd = 0;
            
            for (let i = 0; i < klines.length; i++) {
                const k = klines[i];
                const open = parseFloat(k[1]);
                const close = parseFloat(k[4]);
                const volume = parseFloat(k[5]);
                
                // Delta = Volume * (Close - Open) / Open
                const priceChange = close - open;
                const delta = volume * (priceChange / open);
                
                cvd += delta;
            }
            
            return cvd;
        }

        // ===== DARVAS BOX (Profesyonel Trader Sistemi) =====
        function calculateDarvasBox(highs, lows, closes, volumes) {
            const period = 20;
            if (highs.length < period) return { upperBox: 0, lowerBox: 0, boxHeight: 0, breakoutDirection: 'NONE' };
            
            // Son N mumun high ve low'larını al
            const recentHighs = highs.slice(-period);
            const recentLows = lows.slice(-period);
            
            const upperBox = Math.max(...recentHighs);
            const lowerBox = Math.min(...recentLows);
            const boxHeight = ((upperBox - lowerBox) / lowerBox) * 100;
            
            const currentPrice = closes[closes.length - 1];
            let breakoutDirection = 'NONE';
            
            // Volume ile birlikte breakout kontrolü
            const recentVolume = volumes.slice(-period);
            const avgVolume = recentVolume.reduce((a, b) => a + b, 0) / recentVolume.length;
            const currentVolume = volumes[volumes.length - 1];
            
            if (currentPrice > upperBox && currentVolume > avgVolume * 1.5) {
                breakoutDirection = 'UP';
            } else if (currentPrice < lowerBox && currentVolume > avgVolume * 1.5) {
                breakoutDirection = 'DOWN';
            }
            
            return { upperBox, lowerBox, boxHeight, breakoutDirection };
        }

        // ===== SQUEEZE MOMENTUM (Gizli Profesyonel İndikatör) =====
        function calculateSqueezeMomentum(highs, lows, closes) {
            const bb = calculateBollingerBands(closes, 20);
            const keltner = calculateKeltnerChannels(closes, highs, lows, 20, 2);
            
            const currentBBWidth = bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1];
            const currentKCWidth = keltner.upper - keltner.lower;
            
            // Squeeze: BB Keltner içinde (sıkışma)
            const squeeze = currentBBWidth < currentKCWidth;
            
            // Momentum: RSI benzeri hesaplama
            const momentum = calculateRSI(closes, 14);
            const momentumValue = momentum[momentum.length - 1] - 50; // -50 to +50 range
            
            return { squeeze, momentum: momentumValue };
        }

        // ===== MARKET PROFILE (Kurumsal Seviyeler) =====
        function calculateMarketProfile(highs, lows, closes, volumes) {
            const period = 20;
            const priceRange = [];
            
            // Son 20 mumun high-low aralığını 10 seviyeye böl
            const recentHigh = Math.max(...highs.slice(-period));
            const recentLow = Math.min(...lows.slice(-period));
            const range = recentHigh - recentLow;
            const step = range / 10;
            
            // Her seviyede volume topla
            const volumeAtPrice = {};
            for (let i = closes.length - period; i < closes.length; i++) {
                const price = closes[i];
                const level = Math.floor((price - recentLow) / step) * step + recentLow;
                
                if (!volumeAtPrice[level]) volumeAtPrice[level] = 0;
                volumeAtPrice[level] += volumes[i];
            }
            
            // Value Area (en yüksek volume'lu %70 bölge)
            const sortedPrices = Object.entries(volumeAtPrice)
                .sort((a, b) => b[1] - a[1])
                .map(([price]) => parseFloat(price));
            
            const valueAreaCount = Math.ceil(sortedPrices.length * 0.7);
            const valueArea = sortedPrices.slice(0, valueAreaCount);
            
            // POC (Point of Control - En yüksek volume)
            const poc = sortedPrices[0];
            
            return { valueArea, poc };
        }

        // ===== KELTNER CHANNELS =====
        function calculateKeltnerChannels(closes, highs, lows, period, multiplier) {
            const ema = calculateEMA(closes, period);
            const atr = calculateATR(highs, lows, closes, period);
            
            const middle = ema[ema.length - 1];
            const atrValue = atr[atr.length - 1];
            
            return {
                upper: middle + (multiplier * atrValue),
                middle: middle,
                lower: middle - (multiplier * atrValue)
            };
        }

        // ===== DONCHIAN CHANNELS =====
        function calculateDonchianChannels(highs, lows, period) {
            const recentHighs = highs.slice(-period);
            const recentLows = lows.slice(-period);
            
            return {
                upper: Math.max(...recentHighs),
                lower: Math.min(...recentLows),
                middle: (Math.max(...recentHighs) + Math.min(...recentLows)) / 2
            };
        }

        // ===== TSI (True Strength Index) =====
        function calculateTSI(closes, longPeriod, shortPeriod) {
            const priceChange = [];
            for (let i = 1; i < closes.length; i++) {
                priceChange.push(closes[i] - closes[i - 1]);
            }
            
            // Double smoothed momentum
            const momentum = calculateEMA(priceChange, longPeriod);
            const absMomentum = calculateEMA(priceChange.map(Math.abs), longPeriod);
            
            const smoothedMomentum = calculateEMA(momentum, shortPeriod);
            const smoothedAbsMomentum = calculateEMA(absMomentum, shortPeriod);
            
            const tsi = [];
            for (let i = 0; i < smoothedMomentum.length; i++) {
                if (smoothedAbsMomentum[i] !== 0) {
                    tsi.push((smoothedMomentum[i] / smoothedAbsMomentum[i]) * 100);
                } else {
                    tsi.push(0);
                }
            }
            
            return tsi[tsi.length - 1] || 0;
        }

        // ===== CHOPPINESS INDEX =====
        function calculateChoppinessIndex(highs, lows, closes, period) {
            if (closes.length < period + 1) return 50;
            
            let sumTrueRange = 0;
            for (let i = closes.length - period; i < closes.length; i++) {
                const tr = Math.max(
                    highs[i] - lows[i],
                    Math.abs(highs[i] - closes[i - 1]),
                    Math.abs(lows[i] - closes[i - 1])
                );
                sumTrueRange += tr;
            }
            
            const highestHigh = Math.max(...highs.slice(-period));
            const lowestLow = Math.min(...lows.slice(-period));
            const range = highestHigh - lowestLow;
            
            if (range === 0) return 50;
            
            const choppiness = 100 * Math.log10(sumTrueRange / range) / Math.log10(period);
            return Math.min(100, Math.max(0, choppiness));
        }

        // ===== VOLUME PROFILE =====
        function calculateVolumeProfile(candles, bins) {
            const closes = candles.map(c => parseFloat(c[4]));
            const volumes = candles.map(c => parseFloat(c[5]));
            
            const minPrice = Math.min(...closes);
            const maxPrice = Math.max(...closes);
            const priceRange = maxPrice - minPrice;
            const binSize = priceRange / bins;
            
            const volumeAtPrice = {};
            
            for (let i = 0; i < candles.length; i++) {
                const price = closes[i];
                const bin = Math.floor((price - minPrice) / binSize);
                const binPrice = minPrice + (bin * binSize);
                
                if (!volumeAtPrice[binPrice]) volumeAtPrice[binPrice] = 0;
                volumeAtPrice[binPrice] += volumes[i];
            }
            
            // Yüksek volume node'ları bul
            const sortedNodes = Object.entries(volumeAtPrice)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([price, volume]) => ({ price: parseFloat(price), volume }));
            
            return { highVolumeNodes: sortedNodes };
        }
        
        // ===== ORDER BLOCKS TESPİTİ =====
        function detectOrderBlocks(klines) {
            const blocks = [];
            const lookback = 20;
            
            for (let i = lookback; i < klines.length - 5; i++) {
                const k = klines[i];
                const open = parseFloat(k[1]);
                const high = parseFloat(k[2]);
                const low = parseFloat(k[3]);
                const close = parseFloat(k[4]);
                const volume = parseFloat(k[5]);
                
                // Bullish Order Block: Düşüş öncesi son yeşil mum
                const prevK = klines[i - 1];
                const prevClose = parseFloat(prevK[4]);
                const prevOpen = parseFloat(prevK[1]);
                
                if (close > open && prevClose < prevOpen) {
                    // Düşüşten sonra ilk yükseliş - Bullish OB
                    const futureK = klines[i + 1];
                    if (futureK && parseFloat(futureK[4]) < close) {
                        blocks.push({
                            type: 'BULLISH',
                            high: high,
                            low: low,
                            timestamp: k[0],
                            volume: volume
                        });
                    }
                }
                
                // Bearish Order Block: Yükseliş öncesi son kırmızı mum
                if (close < open && prevClose > prevOpen) {
                    const futureK = klines[i + 1];
                    if (futureK && parseFloat(futureK[4]) > close) {
                        blocks.push({
                            type: 'BEARISH',
                            high: high,
                            low: low,
                            timestamp: k[0],
                            volume: volume
                        });
                    }
                }
            }
            
            return blocks;
        }
        
        // ===== FVG (Fair Value Gap) TESPİTİ =====
        function detectFVG(klines) {
            const fvgs = [];
            
            for (let i = 1; i < klines.length - 1; i++) {
                const prevK = klines[i - 1];
                const currK = klines[i];
                const nextK = klines[i + 1];
                
                const prevHigh = parseFloat(prevK[2]);
                const prevLow = parseFloat(prevK[3]);
                const currHigh = parseFloat(currK[2]);
                const currLow = parseFloat(currK[3]);
                const nextHigh = parseFloat(nextK[2]);
                const nextLow = parseFloat(nextK[3]);
                
                // Bullish FVG: Alt mumun high'ı, üst mumun low'undan yüksek
                if (prevLow > currHigh && nextHigh > currLow) {
                    fvgs.push({
                        type: 'BULLISH',
                        top: prevLow,
                        bottom: currHigh,
                        filled: false,
                        timestamp: currK[0]
                    });
                }
                
                // Bearish FVG: Üst mumun low'u, alt mumun high'ından düşük
                if (prevHigh < currLow && nextLow < currHigh) {
                    fvgs.push({
                        type: 'BEARISH',
                        top: currLow,
                        bottom: prevHigh,
                        filled: false,
                        timestamp: currK[0]
                    });
                }
            }
            
            return fvgs;
        }
        
        // ===== OPTİMİZE EDİLMİŞ PREMİUM İNDİKATÖR HESAPLAMA (50+ En Sağlam İndikatör) =====
        // Gereksiz tekrarlar çıkarıldı, sadece en güvenilir ve etkili indikatörler kaldı
        function calculate90Indicators(candles, volume, avgVol) {
            const closes = candles.map(c => parseFloat(c[4]));
            const highs = candles.map(c => parseFloat(c[2]));
            const lows = candles.map(c => parseFloat(c[3]));
            const volumes = candles.map(c => parseFloat(c[5]));
            const price = closes[closes.length - 1];

            let bull = 0, bear = 0, neutral = 0;
            const indicatorDetails = {
                long: [],
                short: [],
                neutral: []
            };
            const scores = {
                trend: { bull: 0, bear: 0 },
                momentum: { bull: 0, bear: 0 },
                volume: { bull: 0, bear: 0 },
                volatility: { bull: 0, bear: 0 },
                institutional: { bull: 0, bear: 0 }
            };

            // ===== TREND İNDİKATÖRLER (Sadece En Önemli Periyotlar) =====
            // SMA: Sadece kritik seviyeler (50 = Mid-term, 200 = Long-term trend)
            [50, 200].forEach(p => {
                if (closes.length >= p) {
                    const sma = closes.slice(-p).reduce((a, b) => a + b) / p;
                    if (price > sma) { 
                        bull++; scores.trend.bull++; 
                        indicatorDetails.long.push(`SMA(${p}) [${p === 50 ? 'Orta vadeli trend desteği' : 'Uzun vadeli trend desteği'}]`);
                    } else { 
                        bear++; scores.trend.bear++; 
                        indicatorDetails.short.push(`SMA(${p}) [${p === 50 ? 'Orta vadeli trend direnci' : 'Uzun vadeli trend direnci'}]`);
                    }
                }
            });

            // EMA: Sadece kritik seviyeler (9 = Short, 21 = Medium, 50 = Mid, 200 = Long)
            [9, 21, 50, 200].forEach(p => {
                if (closes.length >= p) {
                    const ema = calculateEMA(closes, p);
                    const emaValue = ema[ema.length - 1];
                    if (price > emaValue) { 
                        bull++; scores.trend.bull++; 
                        indicatorDetails.long.push(`EMA(${p}) [${p === 9 ? 'Kısa vadeli momentum' : p === 21 ? 'Orta momentum' : p === 50 ? 'Trend konfirmasyonu' : 'Uzun trend'}]`);
                    } else { 
                        bear++; scores.trend.bear++; 
                        indicatorDetails.short.push(`EMA(${p}) [${p === 9 ? 'Kısa vadeli zayıflık' : p === 21 ? 'Orta zayıflık' : p === 50 ? 'Trend zayıflığı' : 'Uzun trend zayıflığı'}]`);
                    }
                }
            });
            
            // EMA Cross Signals (En güçlü sinyaller)
            if (closes.length >= 200) {
                const ema9 = calculateEMA(closes, 9);
                const ema21 = calculateEMA(closes, 21);
                const ema50 = calculateEMA(closes, 50);
                const ema200 = calculateEMA(closes, 200);
                
                const ema9Val = ema9[ema9.length - 1];
                const ema21Val = ema21[ema21.length - 1];
                const ema50Val = ema50[ema50.length - 1];
                const ema200Val = ema200[ema200.length - 1];
                
                // Golden Cross / Death Cross
                if (ema50Val > ema200Val) {
                    bull += 2; scores.trend.bull += 2;
                    indicatorDetails.long.push('EMA Golden Cross (50>200) [Uzun vadeli yükseliş trendi]');
                } else {
                    bear += 2; scores.trend.bear += 2;
                    indicatorDetails.short.push('EMA Death Cross (50<200) [Uzun vadeli düşüş trendi]');
                }
                
                // EMA Alignment
                if (ema9Val > ema21Val && ema21Val > ema50Val && ema50Val > ema200Val) {
                    bull += 2; scores.trend.bull += 2;
                    indicatorDetails.long.push('EMA Perfect Alignment [Tüm EMA\'lar yükselişte - Güçlü trend]');
                } else if (ema9Val < ema21Val && ema21Val < ema50Val && ema50Val < ema200Val) {
                    bear += 2; scores.trend.bear += 2;
                    indicatorDetails.short.push('EMA Perfect Alignment [Tüm EMA\'lar düşüşte - Güçlü trend]');
                }
            }

            // ===== MACD (En Güvenilir Trend/Momentum İndikatörü) =====
            const macd = calculateMACD(closes);
            const macdValue = macd.macd[macd.macd.length - 1];
            const macdSignal = macd.signal[macd.signal.length - 1];
            const macdHistogram = macd.histogram[macd.histogram.length - 1];
            const prevMacdHist = macd.histogram[macd.histogram.length - 2] || 0;
            
            // MACD Line pozisyonu
            if (macdValue > 0) { 
                bull++; scores.trend.bull++; 
                indicatorDetails.long.push('MACD Line > 0 [Piyasa momentumu pozitif]');
            } else { 
                bear++; scores.trend.bear++; 
                indicatorDetails.short.push('MACD Line < 0 [Piyasa momentumu negatif]');
            }
            
            // MACD Cross (En güçlü sinyal)
            if (macdValue > macdSignal && prevMacdHist <= 0) { 
                bull += 2; scores.trend.bull += 2; 
                indicatorDetails.long.push('MACD Bullish Cross [Yeni yükseliş sinyali - Çok güçlü]');
            } else if (macdValue < macdSignal && prevMacdHist >= 0) { 
                bear += 2; scores.trend.bear += 2; 
                indicatorDetails.short.push('MACD Bearish Cross [Yeni düşüş sinyali - Çok güçlü]');
            } else if (macdValue > macdSignal) {
                bull++; scores.trend.bull++;
                indicatorDetails.long.push('MACD Above Signal [Yükseliş momentumu devam ediyor]');
            } else {
                bear++; scores.trend.bear++;
                indicatorDetails.short.push('MACD Below Signal [Düşüş momentumu devam ediyor]');
            }
            
            // MACD Histogram momentum
            if (macdHistogram > prevMacdHist && macdHistogram > 0) {
                bull++; scores.momentum.bull++;
                indicatorDetails.long.push('MACD Histogram Accelerating [Momentum hızlanıyor]');
            } else if (macdHistogram < prevMacdHist && macdHistogram < 0) {
                bear++; scores.momentum.bear++;
                indicatorDetails.short.push('MACD Histogram Decelerating [Momentum yavaşlıyor]');
            }

            // ===== ADX (Trend Gücü - Sadece gerçekten güçlü trendlerde sinyal ver) =====
            const adx = calculateADX(highs, lows, closes, 14);
            const adxValue = adx[adx.length - 1];
            if (adxValue > 25) { 
                // ADX güçlüyse, trend yönüne göre sinyal ver
                const trend = closes[closes.length - 1] > closes[closes.length - 20] ? 'UP' : 'DOWN';
                if (trend === 'UP') {
                    bull += 2; scores.trend.bull += 2; 
                    indicatorDetails.long.push(`ADX ${adxValue.toFixed(1)} [Güçlü yükseliş trendi - Trend takip et]`);
                } else {
                    bear += 2; scores.trend.bear += 2;
                    indicatorDetails.short.push(`ADX ${adxValue.toFixed(1)} [Güçlü düşüş trendi - Trend takip et]`);
                }
            } else if (adxValue < 20) {
                neutral++;
                indicatorDetails.neutral.push(`ADX ${adxValue.toFixed(1)} [Zayıf trend - Yatay piyasa, bekle]`);
            } else {
                neutral++;
                indicatorDetails.neutral.push(`ADX ${adxValue.toFixed(1)} [Orta trend gücü]`);
            }

            // ===== RSI (Sadece En Popüler ve Güvenilir Periyot: 14) =====
            const rsi = calculateRSI(closes, 14);
            const rsiValue = rsi[rsi.length - 1];
            const prevRSI = rsi[rsi.length - 2] || 50;
            
            // RSI Divergence tespiti (güçlü sinyal)
            const priceHigher = price > closes[closes.length - 10];
            const rsiLower = rsiValue < prevRSI;
            if (priceHigher && rsiLower && rsiValue > 70) {
                bear += 2; scores.momentum.bear += 2;
                indicatorDetails.short.push(`RSI ${rsiValue.toFixed(1)} [Bearish Divergence - Fiyat yükselirken RSI düşüyor!]`);
            } else if (!priceHigher && !rsiLower && rsiValue < 30) {
                bull += 2; scores.momentum.bull += 2;
                indicatorDetails.long.push(`RSI ${rsiValue.toFixed(1)} [Bullish Divergence - Fiyat düşerken RSI yükseliyor!]`);
            }
            
            // RSI Seviye analizi
            if (rsiValue > 70) { 
                bear++; scores.momentum.bear++; 
                indicatorDetails.short.push(`RSI ${rsiValue.toFixed(1)} [Aşırı alım - Satış fırsatı]`);
            } else if (rsiValue < 30) { 
                bull++; scores.momentum.bull++; 
                indicatorDetails.long.push(`RSI ${rsiValue.toFixed(1)} [Aşırı satım - Alış fırsatı]`);
            } else if (rsiValue > 50 && rsiValue < 70) {
                bull++; scores.momentum.bull++;
                indicatorDetails.long.push(`RSI ${rsiValue.toFixed(1)} [Yükseliş momentumu - Sağlıklı]`);
            } else if (rsiValue < 50 && rsiValue > 30) {
                bear++; scores.momentum.bear++;
                indicatorDetails.short.push(`RSI ${rsiValue.toFixed(1)} [Düşüş momentumu - Zayıf]`);
            } else {
                neutral++;
                indicatorDetails.neutral.push(`RSI ${rsiValue.toFixed(1)} [Nötr bölge]`);
            }

            // ===== STOCHASTIC OSCILLATOR (Momentum ve Aşırı Alım/Satım) =====
            const stoch = calculateStochastic(highs, lows, closes, 14);
            const stochK = stoch.k[stoch.k.length - 1];
            const stochD = stoch.d[stoch.d.length - 1];
            const prevStochK = stoch.k[stoch.k.length - 2] || 50;
            const prevStochD = stoch.d[stoch.d.length - 2] || 50;
            
            // Oversold/Overbought (En güçlü sinyaller)
            if (stochK < 20 && stochD < 20) {
                bull += 2; scores.momentum.bull += 2;
                indicatorDetails.long.push(`Stochastic ${stochK.toFixed(1)}/${stochD.toFixed(1)} [Aşırı satım - Güçlü alış sinyali]`);
            } else if (stochK > 80 && stochD > 80) {
                bear += 2; scores.momentum.bear += 2;
                indicatorDetails.short.push(`Stochastic ${stochK.toFixed(1)}/${stochD.toFixed(1)} [Aşırı alım - Güçlü satış sinyali]`);
            } else if (stochK > 50) {
                bull++; scores.momentum.bull++;
                indicatorDetails.long.push(`Stochastic %K ${stochK.toFixed(1)} [Yükseliş momentumu]`);
            } else {
                bear++; scores.momentum.bear++;
                indicatorDetails.short.push(`Stochastic %K ${stochK.toFixed(1)} [Düşüş momentumu]`);
            }
            
            // Stochastic Cross (Çok önemli sinyal)
            if (stochK > stochD && prevStochK <= prevStochD) {
                bull += 2; scores.momentum.bull += 2;
                indicatorDetails.long.push('Stochastic Bullish Cross [%K > %D - Yeni yükseliş sinyali]');
            } else if (stochK < stochD && prevStochK >= prevStochD) {
                bear += 2; scores.momentum.bear += 2;
                indicatorDetails.short.push('Stochastic Bearish Cross [%K < %D - Yeni düşüş sinyali]');
            }

            // ===== VOLUME ANALİZİ (Sadece Önemli Eşikler) =====
            const volRatio = volume / avgVol;
            
            // Yüksek volume (institutional activity işareti)
            if (volRatio > 2) { 
                bull += 2; scores.volume.bull += 2; 
                indicatorDetails.long.push(`Volume ${volRatio.toFixed(2)}x [Kurumsal aktivite - Çok güçlü sinyal]`);
            } else if (volRatio > 1.5) {
                bull++; scores.volume.bull++;
                indicatorDetails.long.push(`Volume ${volRatio.toFixed(2)}x [Yüksek volume - Güçlü hareket]`);
            } else if (volRatio < 0.7) {
                bear++;
                scores.volume.bear++;
                indicatorDetails.short.push(`Volume ${volRatio.toFixed(2)}x [Düşük volume - Zayıf hareket, dikkat]`);
            } else {
                neutral++;
                indicatorDetails.neutral.push(`Volume ${volRatio.toFixed(2)}x [Normal volume]`);
            }

            // ===== OBV (On-Balance Volume - Kurumsal akış göstergesi) =====
            const candleObjs = candles.map((c, i) => ({
                open: parseFloat(c[1]),
                close: parseFloat(c[4]),
                volume: parseFloat(c[5])
            }));
            
            let obv = 0;
            for (let i = 1; i < candleObjs.length; i++) {
                if (candleObjs[i].close > candleObjs[i-1].close) obv += candleObjs[i].volume;
                else if (candleObjs[i].close < candleObjs[i-1].close) obv -= candleObjs[i].volume;
            }
            
            const obvTrend = obv > 0 ? 'BULLISH' : 'BEARISH';
            if (obvTrend === 'BULLISH') { 
                bull += 2; scores.volume.bull += 2; 
                indicatorDetails.long.push('OBV Pozitif [Kurumsal birikim - Yükseliş trendi]');
            } else { 
                bear += 2; scores.volume.bear += 2; 
                indicatorDetails.short.push('OBV Negatif [Kurumsal dağıtım - Düşüş trendi]');
            }

            // ===== VWAP (Volume Weighted Average Price - Kurumsal referans fiyatı) =====
            const vwap = calculateVWAP(candles);
            const vwapValue = vwap[vwap.length - 1];
            const vwapDistance = ((price - vwapValue) / vwapValue) * 100;
            
            if (price > vwapValue && vwapDistance > 2) { 
                bull += 2; scores.volume.bull += 2; 
                indicatorDetails.long.push(`VWAP ${vwapDistance.toFixed(1)}% üzerinde [Kurumsal alım baskısı - Güçlü]`);
            } else if (price < vwapValue && vwapDistance < -2) {
                bear += 2; scores.volume.bear += 2;
                indicatorDetails.short.push(`VWAP ${Math.abs(vwapDistance).toFixed(1)}% altında [Kurumsal satış baskısı - Güçlü]`);
            } else if (price > vwapValue) {
                bull++; scores.volume.bull++;
                indicatorDetails.long.push(`VWAP üzerinde [Kurumsal alım]`);
            } else {
                bear++; scores.volume.bear++;
                indicatorDetails.short.push(`VWAP altında [Kurumsal satış]`);
            }

            // ===== BOLLINGER BANDS (Volatilite ve Aşırı Alım/Satım) =====
            const bb = calculateBollingerBands(closes, 20);
            const bbMiddle = bb.middle[bb.middle.length - 1];
            const bbUpper = bb.upper[bb.upper.length - 1];
            const bbLower = bb.lower[bb.lower.length - 1];
            const bbWidth = ((bbUpper - bbLower) / bbMiddle) * 100;
            
            // Band genişliği (volatilite)
            if (bbWidth > 5) {
                neutral++;
                indicatorDetails.neutral.push(`BB Geniş ${bbWidth.toFixed(1)}% [Yüksek volatilite - Dikkatli]`);
            } else if (bbWidth < 2) {
                neutral++;
                indicatorDetails.neutral.push(`BB Dar ${bbWidth.toFixed(1)}% [Düşük volatilite - Breakout bekleniyor]`);
            }
            
            // Fiyat pozisyonu
            if (price < bbLower) {
                bull += 2; scores.volatility.bull += 2;
                indicatorDetails.long.push(`Fiyat BB Alt Bandı Altında [Aşırı satım - Güçlü alış fırsatı]`);
            } else if (price > bbUpper) {
                bear += 2; scores.volatility.bear += 2;
                indicatorDetails.short.push(`Fiyat BB Üst Bandı Üstünde [Aşırı alım - Güçlü satış fırsatı]`);
            } else if (price > bbMiddle) {
                bull++; scores.volatility.bull++;
                indicatorDetails.long.push(`Fiyat BB Ortalaması Üzerinde [Yükseliş eğilimi]`);
            } else {
                bear++; scores.volatility.bear++;
                indicatorDetails.short.push(`Fiyat BB Ortalaması Altında [Düşüş eğilimi]`);
            }

            // ===== ATR (Average True Range - Volatilite ve Risk Yönetimi) =====
            const atr = calculateATR(highs, lows, closes, 14);
            const atrValue = atr[atr.length - 1];
            const atrPercent = (atrValue / price) * 100;
            const priceChange = Math.abs(price - closes[closes.length - 2]);
            
            // Yüksek volatilite + trend
            if (priceChange > atrValue * 1.5) {
                if (price > closes[closes.length - 2]) {
                    bull += 2; scores.volatility.bull += 2;
                    indicatorDetails.long.push(`ATR ${atrPercent.toFixed(2)}% - Yüksek volatilite + Yükseliş [Güçlü hareket]`);
                } else {
                    bear += 2; scores.volatility.bear += 2;
                    indicatorDetails.short.push(`ATR ${atrPercent.toFixed(2)}% - Yüksek volatilite + Düşüş [Güçlü hareket]`);
                }
            } else if (atrPercent > 5) {
                neutral++;
                indicatorDetails.neutral.push(`ATR ${atrPercent.toFixed(2)}% [Yüksek volatilite - Stop Loss geniş tut]`);
            } else {
                neutral++;
                indicatorDetails.neutral.push(`ATR ${atrPercent.toFixed(2)}% [Normal volatilite]`);
            }

            // ===== INSTITUTIONAL VOLUME (Kurumsal Aktivite - Çok Önemli) =====
            if (volRatio > 3 && volume > avgVol * 3) {
                if (price > closes[closes.length - 2]) { 
                    bull += 3; scores.institutional.bull += 3; 
                    indicatorDetails.long.push(`Kurumsal Volume ${volRatio.toFixed(2)}x + Alım Baskısı [ÇOK GÜÇLÜ SİNYAL]`);
                } else {
                    bear += 3; scores.institutional.bear += 3;
                    indicatorDetails.short.push(`Kurumsal Volume ${volRatio.toFixed(2)}x + Satış Baskısı [ÇOK GÜÇLÜ SİNYAL]`);
                }
            } else if (volRatio > 2) {
                bull += 2; scores.institutional.bull += 2;
                indicatorDetails.long.push(`Kurumsal Volume ${volRatio.toFixed(2)}x [Kurumsal aktivite tespit edildi]`);
            }

            // ===== ICHIMOKU CLOUD (Japon Teknik Analiz - Trend ve Destek/Direnç) =====
            const ichimoku = calculateIchimoku(highs, lows, closes);
            const priceInCloud = price > Math.min(ichimoku.tenkan, ichimoku.kijun) && 
                               price < Math.max(ichimoku.tenkan, ichimoku.kijun);
            
            if (price > ichimoku.tenkan && price > ichimoku.kijun && ichimoku.tenkan > ichimoku.kijun) {
                bull += 2; scores.trend.bull += 2;
                indicatorDetails.long.push('Ichimoku Cloud [Tenkan > Kijun, fiyat üstünde - Güçlü yükseliş]');
            } else if (price < ichimoku.tenkan && price < ichimoku.kijun && ichimoku.tenkan < ichimoku.kijun) {
                bear += 2; scores.trend.bear += 2;
                indicatorDetails.short.push('Ichimoku Cloud [Tenkan < Kijun, fiyat altında - Güçlü düşüş]');
            } else if (priceInCloud) {
                neutral++;
                indicatorDetails.neutral.push('Ichimoku Cloud [Fiyat bulut içinde - Kararsız]');
            }

            // ===== SUPERTREND (Trend Takip - Çok Güvenilir) =====
            const supertrend = calculateSupertrend(highs, lows, closes, 10, 3);
            const prevSupertrend = calculateSupertrend(highs.slice(0, -1), lows.slice(0, -1), closes.slice(0, -1), 10, 3);
            
            if (supertrend.direction === 'UP' && prevSupertrend.direction === 'DOWN') {
                bull += 3; scores.trend.bull += 3;
                indicatorDetails.long.push(`Supertrend UP [Trend değişimi - YENİ YÜKSELİŞ SİNYALI - ÇOK GÜÇLÜ]`);
            } else if (supertrend.direction === 'DOWN' && prevSupertrend.direction === 'UP') {
                bear += 3; scores.trend.bear += 3;
                indicatorDetails.short.push(`Supertrend DOWN [Trend değişimi - YENİ DÜŞÜŞ SİNYALI - ÇOK GÜÇLÜ]`);
            } else if (supertrend.direction === 'UP') {
                bull += 2; scores.trend.bull += 2;
                indicatorDetails.long.push(`Supertrend UP [Yükseliş trendi devam ediyor - Güvenilir]`);
            } else {
                bear += 2; scores.trend.bear += 2;
                indicatorDetails.short.push(`Supertrend DOWN [Düşüş trendi devam ediyor - Güvenilir]`);
            }
            
            // ===== CVD (Cumulative Volume Delta - Kurumsal Akış) =====
            const cvd = calculateCVD(candles);
            if (cvd > 0) {
                bull += 2; scores.volume.bull += 2;
                indicatorDetails.long.push(`CVD +${cvd.toFixed(0)} [Kurumsal alım akışı - Yükseliş beklentisi]`);
            } else {
                bear += 2; scores.volume.bear += 2;
                indicatorDetails.short.push(`CVD ${cvd.toFixed(0)} [Kurumsal satış akışı - Düşüş beklentisi]`);
            }

            // ===== DARVAS BOX (Profesyonel Trader Sistemi) =====
            const darvasBox = calculateDarvasBox(highs, lows, closes, volumes);
            if (darvasBox.boxHeight > 0) {
                if (price > darvasBox.upperBox && darvasBox.breakoutDirection === 'UP') {
                    bull += 3; scores.trend.bull += 3;
                    indicatorDetails.long.push(`Darvas Box Breakout UP [${darvasBox.boxHeight.toFixed(2)}% kutu yüksekliği - Güçlü yükseliş sinyali]`);
                } else if (price < darvasBox.lowerBox && darvasBox.breakoutDirection === 'DOWN') {
                    bear += 3; scores.trend.bear += 3;
                    indicatorDetails.short.push(`Darvas Box Breakdown DOWN [${darvasBox.boxHeight.toFixed(2)}% kutu yüksekliği - Güçlü düşüş sinyali]`);
                } else if (price >= darvasBox.lowerBox && price <= darvasBox.upperBox) {
                    neutral++;
                    indicatorDetails.neutral.push(`Darvas Box [Fiyat kutu içinde - Darvas Box: ${darvasBox.lowerBox.toFixed(2)} - ${darvasBox.upperBox.toFixed(2)}]`);
                }
            }

            // ===== SQUEEZE MOMENTUM (Gizli Profesyonel İndikatör) =====
            const squeeze = calculateSqueezeMomentum(highs, lows, closes);
            if (squeeze.squeeze) {
                neutral++;
                indicatorDetails.neutral.push(`Squeeze MOMENTUM [Sıkışma tespit edildi - Büyük hareket bekleniyor!]`);
            } else {
                if (squeeze.momentum > 0) {
                    bull += 2; scores.momentum.bull += 2;
                    indicatorDetails.long.push(`Squeeze MOMENTUM ${squeeze.momentum.toFixed(2)} [Pozitif momentum - Güçlü]`);
                } else {
                    bear += 2; scores.momentum.bear += 2;
                    indicatorDetails.short.push(`Squeeze MOMENTUM ${squeeze.momentum.toFixed(2)} [Negatif momentum - Güçlü]`);
                }
            }

            // ===== MARKET PROFILE (Kurumsal Seviyeler) =====
            const marketProfile = calculateMarketProfile(highs, lows, closes, volumes);
            if (marketProfile.valueArea.length > 0) {
                const vaHigh = marketProfile.valueArea[marketProfile.valueArea.length - 1];
                const vaLow = marketProfile.valueArea[0];
                const poc = marketProfile.poc;
                
                if (price > vaHigh) {
                    bull += 2; scores.institutional.bull += 2;
                    indicatorDetails.long.push(`Market Profile [Fiyat Value Area üstünde - Kurumsal birikim bölgesi]`);
                } else if (price < vaLow) {
                    bear += 2; scores.institutional.bear += 2;
                    indicatorDetails.short.push(`Market Profile [Fiyat Value Area altında - Kurumsal dağıtım bölgesi]`);
                } else if (price >= poc * 0.98 && price <= poc * 1.02) {
                    neutral++;
                    indicatorDetails.neutral.push(`Market Profile [Fiyat POC yakınında - ${poc.toFixed(2)} - Dengeli bölge]`);
                }
            }

            // ===== KELTNER CHANNELS (Volatilite + Trend) =====
            const keltner = calculateKeltnerChannels(closes, highs, lows, 20, 2);
            if (price > keltner.upper) {
                bear += 2; scores.volatility.bear += 2;
                indicatorDetails.short.push(`Keltner Upper [Aşırı alım - Satış fırsatı]`);
            } else if (price < keltner.lower) {
                bull += 2; scores.volatility.bull += 2;
                indicatorDetails.long.push(`Keltner Lower [Aşırı satım - Alış fırsatı]`);
            } else if (price > keltner.middle) {
                bull++; scores.trend.bull++;
                indicatorDetails.long.push(`Keltner Middle Üstü [Yükseliş eğilimi]`);
            } else {
                bear++; scores.trend.bear++;
                indicatorDetails.short.push(`Keltner Middle Altı [Düşüş eğilimi]`);
            }

            // ===== DONCHIAN CHANNELS (Volatilite Breakout) =====
            const donchian = calculateDonchianChannels(highs, lows, 20);
            if (price > donchian.upper) {
                bull += 2; scores.volatility.bull += 2;
                indicatorDetails.long.push(`Donchian Upper Breakout [Yükseliş breakout - Güçlü sinyal]`);
            } else if (price < donchian.lower) {
                bear += 2; scores.volatility.bear += 2;
                indicatorDetails.short.push(`Donchian Lower Breakdown [Düşüş breakdown - Güçlü sinyal]`);
            }

            // ===== TSI (True Strength Index - Momentum) =====
            const tsi = calculateTSI(closes, 25, 13);
            if (tsi > 25) {
                bull += 2; scores.momentum.bull += 2;
                indicatorDetails.long.push(`TSI ${tsi.toFixed(2)} [Güçlü yükseliş momentumu]`);
            } else if (tsi < -25) {
                bear += 2; scores.momentum.bear += 2;
                indicatorDetails.short.push(`TSI ${tsi.toFixed(2)} [Güçlü düşüş momentumu]`);
            } else if (tsi > 0) {
                bull++; scores.momentum.bull++;
                indicatorDetails.long.push(`TSI ${tsi.toFixed(2)} [Pozitif momentum]`);
            } else {
                bear++; scores.momentum.bear++;
                indicatorDetails.short.push(`TSI ${tsi.toFixed(2)} [Negatif momentum]`);
            }

            // ===== CHOPPINESS INDEX (Trend/Yatay Piyasa) =====
            const chop = calculateChoppinessIndex(highs, lows, closes, 14);
            if (chop > 61.8) {
                neutral++;
                indicatorDetails.neutral.push(`Choppiness ${chop.toFixed(1)} [Yatay piyasa - Range trading]`);
            } else if (chop < 38.2) {
                bull++; scores.trend.bull++;
                indicatorDetails.long.push(`Choppiness ${chop.toFixed(1)} [Trend piyasa - Trend takip]`);
            } else {
                neutral++;
                indicatorDetails.neutral.push(`Choppiness ${chop.toFixed(1)} [Karma piyasa]`);
            }

            // ===== VOLUME PROFILE (Kurumsal Seviyeler) =====
            const volProfile = calculateVolumeProfile(candles, 20);
            if (volProfile.highVolumeNodes.length > 0) {
                const nearestNode = volProfile.highVolumeNodes[volProfile.highVolumeNodes.length - 1];
                const distance = Math.abs(price - nearestNode.price) / price * 100;
                if (distance < 2) {
                    neutral++;
                    indicatorDetails.neutral.push(`Volume Profile [Fiyat yüksek volume node yakınında - ${nearestNode.price.toFixed(2)} - Destek/Direnç]`);
                }
            }

            return {
                bull,
                bear,
                neutral,
                score: Math.round((bull / (bull + bear + neutral || 1)) * 100),
                scores,
                indicatorDetails,
                rsi: calculateRSI(closes, 14)[calculateRSI(closes, 14).length - 1].toFixed(2),
                macd: macd.histogram[macd.histogram.length - 1].toFixed(8),
                adx: adxValue.toFixed(2),
                stoch: stochK.toFixed(2)
            };
        }

        // ===== ICHIMOKU CLOUD =====
        function calculateIchimoku(highs, lows, closes) {
            const tenkanPeriod = 9;
            const kijunPeriod = 26;
            const senkouBPeriod = 52;
            
            const tenkanHigh = Math.max(...highs.slice(-tenkanPeriod));
            const tenkanLow = Math.min(...lows.slice(-tenkanPeriod));
            const tenkan = (tenkanHigh + tenkanLow) / 2;
            
            const kijunHigh = Math.max(...highs.slice(-kijunPeriod));
            const kijunLow = Math.min(...lows.slice(-kijunPeriod));
            const kijun = (kijunHigh + kijunLow) / 2;
            
            const senkouBHigh = Math.max(...highs.slice(-senkouBPeriod));
            const senkouBLow = Math.min(...lows.slice(-senkouBPeriod));
            const senkouB = (senkouBHigh + senkouBLow) / 2;
            
            return { tenkan, kijun, senkouB };
        }

        // ===== SUPERTREND =====
        function calculateSupertrend(highs, lows, closes, period = 10, multiplier = 3) {
            const atr = calculateATR(highs, lows, closes, period);
            const atrValue = atr[atr.length - 1];
            const hlAvg = (highs[highs.length - 1] + lows[lows.length - 1]) / 2;
            const upperBand = hlAvg + (multiplier * atrValue);
            const lowerBand = hlAvg - (multiplier * atrValue);
            const price = closes[closes.length - 1];
            
            const direction = price > upperBand ? 'UP' : price < lowerBand ? 'DOWN' : 
                             price > (upperBand + lowerBand) / 2 ? 'UP' : 'DOWN';
            const value = direction === 'UP' ? lowerBand : upperBand;
            
            return { direction, value };
        }

        // ===== INSTITUTIONAL ANALİZ =====
        function analyzeInstitutional(candles, volumes) {
            const avgVol = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            let buyPressure = 0, sellPressure = 0, blockTrades = 0;

            for (let i = 1; i < candles.length; i++) {
                const change = parseFloat(candles[i][4]) - parseFloat(candles[i - 1][4]);
                const vol = parseFloat(candles[i][5]);
                const volWeight = vol / avgVol;
                
                if (volWeight > 2.5) blockTrades++;
                
                if (change > 0 && volWeight > 1.2) buyPressure += volWeight;
                if (change < 0 && volWeight > 1.2) sellPressure += volWeight;
            }

            const darkPoolActivity = blockTrades > 5 ? 'VERY HIGH' : 
                                     blockTrades > 3 ? 'HIGH' : 
                                     blockTrades > 1 ? 'MEDIUM' : 'LOW';

            return {
                darkPool: darkPoolActivity,
                orderFlow: buyPressure > sellPressure ? 'STRONG BUY' : 
                           buyPressure > sellPressure * 0.8 ? 'BUY' : 
                           sellPressure > buyPressure * 0.8 ? 'SELL' : 'STRONG SELL',
                buyPressure: buyPressure.toFixed(2),
                sellPressure: sellPressure.toFixed(2),
                blockTrades,
                ratio: (buyPressure / (buyPressure + sellPressure || 1) * 100).toFixed(1)
            };
        }

        // ===== WHALE ANALİZ =====
        function analyzeWhales(candles, avgVol) {
            const whaleThreshold = avgVol * 3;
            const whaleOrders = [];
            
            for (let i = 0; i < candles.length; i++) {
                if (parseFloat(candles[i][5]) > whaleThreshold) {
                    whaleOrders.push({
                        volume: parseFloat(candles[i][5]),
                        close: parseFloat(candles[i][4]),
                        open: parseFloat(candles[i][1])
                    });
                }
            }
            
            const recent = whaleOrders.slice(-10);
            const buys = recent.filter(w => w.close > w.open).length;
            const sells = recent.filter(w => w.close < w.open).length;
            
            const buyVolume = recent
                .filter(w => w.close > w.open)
                .reduce((sum, w) => sum + w.volume, 0);
            const sellVolume = recent
                .filter(w => w.close < w.open)
                .reduce((sum, w) => sum + w.volume, 0);

            const status = whaleOrders.length > 10 ? 'VERY ACTIVE' : 
                           whaleOrders.length > 5 ? 'ACTIVE' : 
                           whaleOrders.length > 2 ? 'MODERATE' : 'QUIET';

            return {
                status,
                orders: whaleOrders.length,
                recentOrders: recent.length,
                buys,
                sells,
                sentiment: buys > sells ? 'STRONG BULLISH' : 
                           buys === sells ? 'NEUTRAL' : 'STRONG BEARISH',
                accumulation: ((buyVolume / (buyVolume + sellVolume || 1)) * 100).toFixed(1),
                distribution: ((sellVolume / (buyVolume + sellVolume || 1)) * 100).toFixed(1),
                netFlow: (buyVolume - sellVolume).toFixed(0)
            };
        }

        // ===== MARKET MAKERS ANALİZ (WYCKOFF & VSA) =====
        function analyzeMarketMakers(candles) {
            const closes = candles.map(c => parseFloat(c[4]));
            const volumes = candles.map(c => parseFloat(c[5]));
            const highs = candles.map(c => parseFloat(c[2]));
            const lows = candles.map(c => parseFloat(c[3]));
            
            const recentHigh = Math.max(...closes.slice(-50));
            const recentLow = Math.min(...closes.slice(-50));
            const price = closes[closes.length - 1];
            const position = ((price - recentLow) / (recentHigh - recentLow) * 100).toFixed(1);

            let phase = 'MARKDOWN';
            if (position < 25) phase = 'ACCUMULATION';
            else if (position < 40) phase = 'ACCUMULATION/MARKUP';
            else if (position < 60) phase = 'MARKUP';
            else if (position < 75) phase = 'MARKUP/DISTRIBUTION';
            else phase = 'DISTRIBUTION';

            let cvd = 0;
            for (let i = 1; i < candles.length; i++) {
                const change = parseFloat(candles[i][4]) - parseFloat(candles[i][1]);
                const vol = parseFloat(candles[i][5]);
                if (change > 0) cvd += vol;
                else cvd -= vol;
            }

            const avgVol = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            const lastVol = volumes[volumes.length - 1];
            const lastHigh = parseFloat(candles[candles.length - 1][2]);
            const lastLow = parseFloat(candles[candles.length - 1][3]);
            const lastRange = lastHigh - lastLow;
            const avgRange = candles.slice(-20).reduce((sum, c) => sum + (parseFloat(c[2]) - parseFloat(c[3])), 0) / 20;

            let vsa = 'NEUTRAL';
            const lastClose = parseFloat(candles[candles.length - 1][4]);
            const lastOpen = parseFloat(candles[candles.length - 1][1]);
            
            if (lastVol > avgVol * 2 && lastRange < avgRange * 0.6) vsa = 'STRONG ABSORPTION';
            else if (lastVol > avgVol * 1.5 && lastRange < avgRange * 0.7) vsa = 'ABSORPTION';
            else if (lastVol > avgVol * 1.8 && lastClose > lastOpen) vsa = 'STRONG BULLISH';
            else if (lastVol > avgVol * 1.5 && lastClose > lastOpen) vsa = 'BULLISH';
            else if (lastVol > avgVol * 1.8 && lastClose < lastOpen) vsa = 'STRONG BEARISH';
            else if (lastVol > avgVol * 1.5 && lastClose < lastOpen) vsa = 'BEARISH';

            return {
                wyckoff: { phase, position },
                cvd: { 
                    value: cvd, 
                    trend: cvd > 0 ? 'STRONG BULLISH' : cvd < 0 ? 'STRONG BEARISH' : 'NEUTRAL',
                    strength: Math.abs(cvd / 1000000).toFixed(2)
                },
                vsa,
                volumeProfile: {
                    current: lastVol.toFixed(0),
                    average: avgVol.toFixed(0),
                    ratio: (lastVol / avgVol).toFixed(2)
                }
            };
        }

        // ===== ORDER FLOW DELTA (Kurumsal Seviye Analiz) =====
        function calculateOrderFlowDelta(klines) {
            const deltas = [];
            let cumulativeDelta = 0;
            
            for (let i = 1; i < klines.length; i++) {
                const current = klines[i];
                const prev = klines[i - 1];
                
                const open = parseFloat(current[1]);
                const close = parseFloat(current[4]);
                const volume = parseFloat(current[5]);
                
                // Delta = Volume * (Close - Open) / Open
                const priceChange = close - open;
                const delta = volume * (priceChange / open);
                
                cumulativeDelta += delta;
                deltas.push({
                    delta: delta,
                    cumulativeDelta: cumulativeDelta,
                    buyVolume: priceChange > 0 ? volume : 0,
                    sellVolume: priceChange < 0 ? volume : 0,
                    imbalance: priceChange > 0 ? (delta / volume) * 100 : (delta / volume) * 100
                });
            }
            
            const recentDelta = deltas.slice(-20);
            const avgDelta = recentDelta.reduce((a, b) => a + b.delta, 0) / recentDelta.length;
            const buyPressure = recentDelta.reduce((a, b) => a + b.buyVolume, 0);
            const sellPressure = recentDelta.reduce((a, b) => a + b.sellVolume, 0);
            
            return {
                currentDelta: deltas[deltas.length - 1]?.delta || 0,
                cumulativeDelta: cumulativeDelta,
                avgDelta: avgDelta,
                buyPressure: buyPressure,
                sellPressure: sellPressure,
                imbalance: buyPressure > sellPressure ? 
                    ((buyPressure - sellPressure) / (buyPressure + sellPressure || 1) * 100).toFixed(1) : 
                    ((sellPressure - buyPressure) / (buyPressure + sellPressure || 1) * 100).toFixed(1),
                trend: cumulativeDelta > 0 ? 'STRONG BULLISH' : cumulativeDelta < 0 ? 'STRONG BEARISH' : 'NEUTRAL'
            };
        }

        // ===== LİQUİDİTY SWEEPS (Stop Hunting Detection) =====
        function detectLiquiditySweeps(klines) {
            const sweeps = [];
            const lookback = 50;
            
            if (klines.length < lookback + 10) return sweeps;
            
            const highs = klines.map(k => parseFloat(k[2]));
            const lows = klines.map(k => parseFloat(k[3]));
            const closes = klines.map(k => parseFloat(k[4]));
            const volumes = klines.map(k => parseFloat(k[5]));
            
            // Son 50 mum içinde pivot high/low'ları bul
            const pivotHighs = [];
            const pivotLows = [];
            
            for (let i = 10; i < highs.length - 10; i++) {
                const isPivotHigh = highs[i] === Math.max(...highs.slice(i - 10, i + 11));
                const isPivotLow = lows[i] === Math.min(...lows.slice(i - 10, i + 11));
                
                if (isPivotHigh) pivotHighs.push({ index: i, price: highs[i] });
                if (isPivotLow) pivotLows.push({ index: i, price: lows[i] });
            }
            
            // Son 10 mum içinde pivot'ları kırıp geri dönüyorsa = Liquidity Sweep
            const recentHighs = highs.slice(-10);
            const recentLows = lows.slice(-10);
            const currentPrice = closes[closes.length - 1];
            
            pivotHighs.forEach(pivot => {
                if (pivot.index < highs.length - 10) {
                    const maxAfter = Math.max(...highs.slice(pivot.index + 1));
                    if (maxAfter > pivot.price * 1.001 && currentPrice < pivot.price * 0.998) {
                        sweeps.push({
                            type: 'BEARISH_SWEEP',
                            level: pivot.price,
                            direction: 'UP_THEN_DOWN',
                            strength: 'HIGH'
                        });
                    }
                }
            });
            
            pivotLows.forEach(pivot => {
                if (pivot.index < lows.length - 10) {
                    const minAfter = Math.min(...lows.slice(pivot.index + 1));
                    if (minAfter < pivot.price * 0.999 && currentPrice > pivot.price * 1.002) {
                        sweeps.push({
                            type: 'BULLISH_SWEEP',
                            level: pivot.price,
                            direction: 'DOWN_THEN_UP',
                            strength: 'HIGH'
                        });
                    }
                }
            });
            
            return sweeps;
        }

        // ===== PREMIUM/DISCOUNT ZONES (Institutional Accumulation) =====
        function calculatePremiumDiscountZones(klines) {
            const closes = klines.map(k => parseFloat(k[4]));
            const highs = klines.map(k => parseFloat(k[2]));
            const lows = klines.map(k => parseFloat(k[3]));
            const volumes = klines.map(k => parseFloat(k[5]));
            
            const period = 100;
            if (closes.length < period) return null;
            
            const recentHigh = Math.max(...highs.slice(-period));
            const recentLow = Math.min(...lows.slice(-period));
            const range = recentHigh - recentLow;
            const currentPrice = closes[closes.length - 1];
            
            // Fibonacci seviyeleri ile premium/discount
            const premiumZone = {
                upper: recentHigh,
                lower: recentLow + (range * 0.618),
                type: 'PREMIUM',
                description: 'Kurumsal dağıtım bölgesi - Yüksek fiyat seviyesi'
            };
            
            const discountZone = {
                upper: recentLow + (range * 0.382),
                lower: recentLow,
                type: 'DISCOUNT',
                description: 'Kurumsal birikim bölgesi - Düşük fiyat seviyesi'
            };
            
            const equilibriumZone = {
                upper: recentLow + (range * 0.618),
                lower: recentLow + (range * 0.382),
                type: 'EQUILIBRIUM',
                description: 'Denge bölgesi - Normal işlem'
            };
            
            let currentZone = 'EQUILIBRIUM';
            if (currentPrice >= premiumZone.lower) currentZone = 'PREMIUM';
            else if (currentPrice <= discountZone.upper) currentZone = 'DISCOUNT';
            
            // Volume analizi ile doğrula
            const premiumVolume = volumes.slice(-period).filter((v, i) => 
                closes[closes.length - period + i] >= premiumZone.lower
            ).reduce((a, b) => a + b, 0);
            
            const discountVolume = volumes.slice(-period).filter((v, i) => 
                closes[closes.length - period + i] <= discountZone.upper
            ).reduce((a, b) => a + b, 0);
            
            return {
                zones: { premium: premiumZone, discount: discountZone, equilibrium: equilibriumZone },
                currentZone,
                premiumVolume: premiumVolume.toFixed(0),
                discountVolume: discountVolume.toFixed(0),
                recommendation: currentZone === 'DISCOUNT' ? '🟢 BİRİKİM FIRSATI' : 
                               currentZone === 'PREMIUM' ? '🔴 DAĞITIM DİKKATİ' : '⚪ DENGE'
            };
        }

        // ===== MULTI-TIMEFRAME CONFLUENCE =====
        function calculateMultiTimeframeConfluence(coin, priceData) {
            // Farklı timeframe'lerde trend uyumu
            const timeframes = ['15m', '1h', '4h', '1d'];
            const signals = {};
            
            // Her timeframe için trend hesapla (simüle edilmiş - gerçekte API'den alınmalı)
            timeframes.forEach(tf => {
                // Burada gerçekte farklı timeframe verileri alınmalı
                // Şimdilik mevcut veriyi kullanıyoruz
                const trend = priceData.change > 0 ? 'BULLISH' : 'BEARISH';
                signals[tf] = {
                    trend,
                    strength: Math.abs(priceData.change) > 3 ? 'STRONG' : 'MODERATE',
                    alignment: trend
                };
            });
            
            // Tüm timeframe'lerde uyum var mı?
            const bullishCount = Object.values(signals).filter(s => s.trend === 'BULLISH').length;
            const bearishCount = Object.values(signals).filter(s => s.trend === 'BEARISH').length;
            
            let confluence = 'NEUTRAL';
            let strength = 0;
            
            if (bullishCount >= 3) {
                confluence = 'STRONG_BULLISH_CONFLUENCE';
                strength = 90;
            } else if (bullishCount >= 2) {
                confluence = 'BULLISH_CONFLUENCE';
                strength = 70;
            } else if (bearishCount >= 3) {
                confluence = 'STRONG_BEARISH_CONFLUENCE';
                strength = 10;
            } else if (bearishCount >= 2) {
                confluence = 'BEARISH_CONFLUENCE';
                strength = 30;
            }
            
            return {
                signals,
                confluence,
                strength,
                recommendation: confluence.includes('BULLISH') ? '🟢 MULTI-TF LONG' : 
                               confluence.includes('BEARISH') ? '🔴 MULTI-TF SHORT' : '⚪ BEKLE'
            };
        }

        // ===== ADVANCED VOLUME PROFILE =====
        function calculateAdvancedVolumeProfile(klines) {
            const closes = klines.map(k => parseFloat(k[4]));
            const highs = klines.map(k => parseFloat(k[2]));
            const lows = klines.map(k => parseFloat(k[3]));
            const volumes = klines.map(k => parseFloat(k[5]));
            
            const period = 100;
            if (closes.length < period) return null;
            
            const recentHigh = Math.max(...highs.slice(-period));
            const recentLow = Math.min(...lows.slice(-period));
            const bins = 30;
            const binSize = (recentHigh - recentLow) / bins;
            
            // Her fiyat seviyesinde volume topla
            const volumeProfile = {};
            for (let i = closes.length - period; i < closes.length; i++) {
                const price = closes[i];
                const bin = Math.floor((price - recentLow) / binSize);
                const binPrice = recentLow + (bin * binSize);
                
                if (!volumeProfile[binPrice]) volumeProfile[binPrice] = 0;
                volumeProfile[binPrice] += volumes[i];
            }
            
            // En yüksek volume = POC (Point of Control)
            const sorted = Object.entries(volumeProfile)
                .sort((a, b) => b[1] - a[1])
                .map(([price, vol]) => ({ price: parseFloat(price), volume: vol }));
            
            const poc = sorted[0];
            
            // Value Area = Toplam volume'un %70'ini içeren bölge
            const totalVolume = sorted.reduce((a, b) => a + b.volume, 0);
            const valueAreaVolume = totalVolume * 0.7;
            
            let cumulativeVolume = 0;
            const valueArea = [];
            for (const node of sorted) {
                cumulativeVolume += node.volume;
                valueArea.push(node);
                if (cumulativeVolume >= valueAreaVolume) break;
            }
            
            const valueAreaHigh = Math.max(...valueArea.map(n => n.price));
            const valueAreaLow = Math.min(...valueArea.map(n => n.price));
            
            const currentPrice = closes[closes.length - 1];
            const positionInVA = ((currentPrice - valueAreaLow) / (valueAreaHigh - valueAreaLow || 1)) * 100;
            
            return {
                poc: poc.price,
                valueAreaHigh,
                valueAreaLow,
                currentPrice,
                positionInVA: positionInVA.toFixed(1),
                recommendation: positionInVA > 80 ? '🔴 VALUE AREA ÜSTÜ - DAĞITIM' :
                               positionInVA < 20 ? '🟢 VALUE AREA ALTINDA - BİRİKİM' :
                               '⚪ VALUE AREA İÇİNDE - DENGE'
            };
        }

        // ===== SESSION ANALYSIS =====
        function analyzeTradingSessions() {
            const now = new Date();
            const utcHour = now.getUTCHours();
            
            let activeSession = 'ASIAN';
            let sessionActivity = 'LOW';
            
            // Asian: 00:00-08:00 UTC
            if (utcHour >= 0 && utcHour < 8) {
                activeSession = 'ASIAN';
                sessionActivity = 'LOW';
            }
            // London: 08:00-16:00 UTC
            else if (utcHour >= 8 && utcHour < 16) {
                activeSession = 'LONDON';
                sessionActivity = 'HIGH';
            }
            // New York: 13:00-21:00 UTC
            else if (utcHour >= 13 && utcHour < 21) {
                activeSession = 'NEW_YORK';
                sessionActivity = 'VERY_HIGH';
            }
            // Overlap: 13:00-16:00 UTC (London + NY)
            if (utcHour >= 13 && utcHour < 16) {
                activeSession = 'LONDON_NY_OVERLAP';
                sessionActivity = 'EXTREME';
            }
            
            return {
                activeSession,
                sessionActivity,
                recommendation: sessionActivity === 'EXTREME' ? '🚀 EN YÜKSEK VOLATİLİTE' :
                               sessionActivity === 'VERY_HIGH' ? '📈 YÜKSEK VOLATİLİTE' :
                               sessionActivity === 'HIGH' ? '📊 ORTA VOLATİLİTE' :
                               '😴 DÜŞÜK VOLATİLİTE'
            };
        }

        // ===== CORRELATION ANALYSIS =====
        async function analyzeMarketCorrelation(coin, priceData) {
            // BTC dominance ile altcoin korelasyonu
            try {
                const btcResponse = await fetch('https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT');
                const btcData = await btcResponse.json();
                
                const btcChange = parseFloat(btcData.priceChangePercent);
                const coinChange = priceData.change;
                
                // Basit korelasyon: Aynı yönde hareket ediyor mu?
                const correlation = (btcChange > 0 && coinChange > 0) || (btcChange < 0 && coinChange < 0) ? 
                    'POSITIVE' : 'NEGATIVE';
                
                const correlationStrength = Math.abs(coinChange - btcChange) < 2 ? 'STRONG' : 'WEAK';
                
                return {
                    btcChange: btcChange.toFixed(2),
                    coinChange: coinChange.toFixed(2),
                    correlation,
                    correlationStrength,
                    recommendation: correlation === 'POSITIVE' && correlationStrength === 'STRONG' ? 
                        '✅ BTC ile güçlü korelasyon - Piyasa trendi takip ediliyor' :
                        '⚠️ BTC\'den bağımsız hareket - Coin-specific faktörler'
                };
            } catch (error) {
                return {
                    btcChange: 'N/A',
                    coinChange: priceData.change.toFixed(2),
                    correlation: 'UNKNOWN',
                    recommendation: 'Korelasyon analizi yapılamadı'
                };
            }
        }

        // ===== TAPE READING (Order Flow & Market Depth Analysis) =====
        function analyzeTapeReading(klines) {
            const closes = klines.map(k => parseFloat(k[4]));
            const opens = klines.map(k => parseFloat(k[1]));
            const highs = klines.map(k => parseFloat(k[2]));
            const lows = klines.map(k => parseFloat(k[3]));
            const volumes = klines.map(k => parseFloat(k[5]));
            
            // Price Action Analysis (Tape Reading temeli)
            let aggressiveBuyers = 0;
            let aggressiveSellers = 0;
            let absorptionPatterns = 0;
            let exhaustionSignals = 0;
            
            // Son 20 mum analizi
            const recent = Math.min(20, klines.length);
            for (let i = klines.length - recent; i < klines.length; i++) {
                const current = klines[i];
                const open = parseFloat(current[1]);
                const close = parseFloat(current[4]);
                const high = parseFloat(current[2]);
                const low = parseFloat(current[3]);
                const volume = parseFloat(current[5]);
                const avgVol = volumes.slice(Math.max(0, i - 20), i).reduce((a, b) => a + b, 0) / Math.min(20, i);
                
                // Aggressive Buying: Büyük volume ile yukarı hareket
                if (close > open && volume > avgVol * 1.5) {
                    aggressiveBuyers++;
                }
                
                // Aggressive Selling: Büyük volume ile aşağı hareket
                if (close < open && volume > avgVol * 1.5) {
                    aggressiveSellers++;
                }
                
                // Absorption Pattern: Yüksek volume ama küçük price movement
                const bodySize = Math.abs(close - open);
                const candleRange = high - low;
                if (volume > avgVol * 2 && bodySize / candleRange < 0.3) {
                    absorptionPatterns++;
                }
                
                // Exhaustion: Çok yüksek volume ama ters yönde kapanış
                if (volume > avgVol * 3) {
                    const prevClose = i > 0 ? parseFloat(klines[i - 1][4]) : open;
                    if (Math.abs(close - prevClose) < candleRange * 0.2) {
                        exhaustionSignals++;
                    }
                }
            }
            
            // Bid/Ask Imbalance Simulation (volume ve price action'dan)
            const buyVolume = volumes.slice(-20).reduce((sum, vol, idx) => {
                const i = klines.length - 20 + idx;
                if (i >= 0 && parseFloat(klines[i][4]) > parseFloat(klines[i][1])) {
                    return sum + vol;
                }
                return sum;
            }, 0);
            
            const sellVolume = volumes.slice(-20).reduce((sum, vol, idx) => {
                const i = klines.length - 20 + idx;
                if (i >= 0 && parseFloat(klines[i][4]) < parseFloat(klines[i][1])) {
                    return sum + vol;
                }
                return sum;
            }, 0);
            
            const totalRecentVolume = buyVolume + sellVolume;
            const buyRatio = (buyVolume / (totalRecentVolume || 1)) * 100;
            const sellRatio = (sellVolume / (totalRecentVolume || 1)) * 100;
            
            // Order Flow Direction
            let orderFlowDirection = 'NEUTRAL';
            if (buyRatio > 65) orderFlowDirection = 'STRONG BUYING PRESSURE';
            else if (buyRatio > 55) orderFlowDirection = 'BUYING PRESSURE';
            else if (sellRatio > 65) orderFlowDirection = 'STRONG SELLING PRESSURE';
            else if (sellRatio > 55) orderFlowDirection = 'SELLING PRESSURE';
            
            // Volume Profile (Price levels by volume)
            const priceLevels = {};
            const recentKlines = klines.slice(-50);
            recentKlines.forEach(k => {
                const price = parseFloat(k[4]);
                const vol = parseFloat(k[5]);
                const priceKey = Math.round(price * 100) / 100; // 2 decimal precision
                priceLevels[priceKey] = (priceLevels[priceKey] || 0) + vol;
            });
            
            const sortedLevels = Object.entries(priceLevels).sort((a, b) => b[1] - a[1]);
            const highestVolumePrice = parseFloat(sortedLevels[0]?.[0] || closes[closes.length - 1]);
            const currentPrice = closes[closes.length - 1];
            
            // Support/Resistance from Tape
            let supportLevel = Math.min(...lows.slice(-50));
            let resistanceLevel = Math.max(...highs.slice(-50));
            
            // Market Sentiment
            let tapeSentiment = 'NEUTRAL';
            if (aggressiveBuyers > aggressiveSellers * 1.5 && buyRatio > 60) {
                tapeSentiment = 'STRONG BULLISH';
            } else if (aggressiveBuyers > aggressiveSellers && buyRatio > 50) {
                tapeSentiment = 'BULLISH';
            } else if (aggressiveSellers > aggressiveBuyers * 1.5 && sellRatio > 60) {
                tapeSentiment = 'STRONG BEARISH';
            } else if (aggressiveSellers > aggressiveBuyers && sellRatio > 50) {
                tapeSentiment = 'BEARISH';
            }
            
            // Recommendation
            let recommendation = '';
            if (tapeSentiment.includes('BULLISH') && orderFlowDirection.includes('BUYING')) {
                recommendation = '✅ Güçlü alım baskısı - Long pozisyon düşünülebilir';
            } else if (tapeSentiment.includes('BEARISH') && orderFlowDirection.includes('SELLING')) {
                recommendation = '🔻 Güçlü satım baskısı - Short pozisyon düşünülebilir';
            } else if (absorptionPatterns > 3) {
                recommendation = '⚠️ Absorption pattern tespit edildi - Piyasa yön değiştirebilir';
            } else if (exhaustionSignals > 2) {
                recommendation = '⏸️ Exhaustion sinyali - Momentum yavaşlayabilir';
            } else {
                recommendation = '📊 Nötr tape - Trend devam edebilir';
            }
            
            return {
                orderFlowDirection,
                buyVolume: buyVolume.toFixed(0),
                sellVolume: sellVolume.toFixed(0),
                buyRatio: buyRatio.toFixed(1),
                sellRatio: sellRatio.toFixed(1),
                aggressiveBuyers,
                aggressiveSellers,
                absorptionPatterns,
                exhaustionSignals,
                highestVolumePrice: highestVolumePrice.toFixed(8),
                supportLevel: supportLevel.toFixed(8),
                resistanceLevel: resistanceLevel.toFixed(8),
                tapeSentiment,
                recommendation,
                imbalance: buyRatio > sellRatio ? 
                    `+${(buyRatio - sellRatio).toFixed(1)}% BUY` : 
                    `-${(sellRatio - buyRatio).toFixed(1)}% SELL`
            };
        }

        // ===== SMART MONEY DETAYLI ANALİZ =====
        function analyzeSmartMoneyConcepts(candles) {
            const closes = candles.map(c => parseFloat(c[4]));
            const highs = candles.map(c => parseFloat(c[2]));
            const lows = candles.map(c => parseFloat(c[3]));

            let bos = 'NEUTRAL';
            const lookback = 30;
            if (candles.length > lookback + 10) {
                const recentHigh = Math.max(...highs.slice(-lookback, -10));
                const currentHigh = Math.max(...highs.slice(-10));
                const recentLow = Math.min(...lows.slice(-lookback, -10));
                const currentLow = Math.min(...lows.slice(-10));
                
                if (currentHigh > recentHigh * 1.01) bos = 'STRONG BULLISH BOS';
                else if (currentHigh > recentHigh) bos = 'BULLISH BOS';
                else if (currentLow < recentLow * 0.99) bos = 'STRONG BEARISH BOS';
                else if (currentLow < recentLow) bos = 'BEARISH BOS';
            }

            let choch = 'NEUTRAL';
            if (candles.length > 20) {
                const trend1 = closes.slice(-20, -10);
                const trend2 = closes.slice(-10);
                const avg1 = trend1.reduce((a, b) => a + b) / trend1.length;
                const avg2 = trend2.reduce((a, b) => a + b) / trend2.length;
                
                if (avg1 < avg2 && avg2 > avg1 * 1.015) choch = 'STRONG BULLISH CHOCH';
                else if (avg1 < avg2 && avg2 > avg1 * 1.005) choch = 'BULLISH CHOCH';
                else if (avg1 > avg2 && avg2 < avg1 * 0.985) choch = 'STRONG BEARISH CHOCH';
                else if (avg1 > avg2 && avg2 < avg1 * 0.995) choch = 'BEARISH CHOCH';
            }

            const high = Math.max(...highs.slice(-100));
            const low = Math.min(...lows.slice(-100));
            const price = closes[closes.length - 1];
            const position = (price - low) / (high - low);
            
            let zone = 'EQUILIBRIUM';
            if (position > 0.618) zone = 'PREMIUM';
            else if (position > 0.5) zone = 'PREMIUM EQUILIBRIUM';
            else if (position < 0.382) zone = 'DISCOUNT';
            else if (position < 0.5) zone = 'DISCOUNT EQUILIBRIUM';

            return {
                bos,
                choch,
                fvg: fvgData[Object.keys(fvgData)[0]] || [],
                orderBlocks: orderBlocks[Object.keys(orderBlocks)[0]] || [],
                zone,
                position: (position * 100).toFixed(1),
                priceRange: {
                    high: high.toFixed(8),
                    low: low.toFixed(8),
                    current: price.toFixed(8)
                }
            };
        }

        // ===== TRADER ANALİZ =====
        function analyzeTraders(candles, institutional) {
            const volumes = candles.map(c => parseFloat(c[5]));
            const avgVol = volumes.reduce((a, b) => a + b, 0) / volumes.length;

            const retailVol = volumes.filter(v => v < avgVol * 1.5).reduce((a, b) => a + b, 0);
            const instVol = volumes.filter(v => v >= avgVol * 1.5).reduce((a, b) => a + b, 0);
            const totalVol = retailVol + instVol;

            const sentiment = parseFloat(institutional.buyPressure) > parseFloat(institutional.sellPressure) 
                ? 'STRONG BULLISH' 
                : parseFloat(institutional.buyPressure) > parseFloat(institutional.sellPressure) * 0.9
                ? 'BULLISH'
                : parseFloat(institutional.sellPressure) > parseFloat(institutional.buyPressure) * 0.9
                ? 'BEARISH'
                : 'STRONG BEARISH';

            return {
                retail: retailVol.toFixed(0),
                institutional: instVol.toFixed(0),
                ratio: (instVol / (totalVol || 1) * 100).toFixed(1),
                retailRatio: (retailVol / (totalVol || 1) * 100).toFixed(1),
                sentiment,
                smartMoney: institutional.orderFlow.includes('BUY') ? 'STRONG BUYING' : 'STRONG SELLING',
                dominance: instVol > retailVol ? 'INSTITUTIONAL' : 'RETAIL'
            };
        }

        // ===== PUMP & DUMP ANALİZ =====
        function analyzePumpDump(candles, bb, volume, avgVol) {
            const price = parseFloat(candles[candles.length - 1][4]);
            const prevPrice = parseFloat(candles[candles.length - 2][4]);
            const change = ((price - prevPrice) / prevPrice) * 100;
            
            const closes = candles.map(c => parseFloat(c[4]));
            const highs = candles.map(c => parseFloat(c[2]));
            const lows = candles.map(c => parseFloat(c[3]));
            const adx = calculateADX(highs, lows, closes, 14);
            const volSpike = volume / avgVol;
            
            let signal = 'NEUTRAL';
            let strength = 0;
            const bbUpper = bb.upper[bb.upper.length - 1];
            const bbLower = bb.lower[bb.lower.length - 1];
            
            if (price > bbUpper && volSpike > 2 && adx[adx.length - 1] > 25) {
                signal = '🚀 STRONG PUMP';
                strength = 95;
            } else if (price > bbUpper && volSpike > 1.5) {
                signal = '📈 PUMP DETECTED';
                strength = 75;
            } else if (price < bbLower && volSpike > 2 && adx[adx.length - 1] > 25) {
                signal = '💥 STRONG DUMP';
                strength = 5;
            } else if (price < bbLower && volSpike > 1.5) {
                signal = '📉 DUMP DETECTED';
                strength = 25;
            }
            
            return {
                signal,
                strength,
                volSpike: volSpike.toFixed(2),
                priceChange: change.toFixed(2),
                adxStrength: adx[adx.length - 1].toFixed(2),
                bbPosition: price > bbUpper ? 'ABOVE UPPER' : 
                            price < bbLower ? 'BELOW LOWER' : 
                            price > bb.middle[bb.middle.length - 1] ? 'ABOVE MIDDLE' : 'BELOW MIDDLE'
            };
        }

        // ===== TREND BREAK ANALİZ =====
        function analyzeTrendBreak(candles) {
            const closes = candles.map(c => parseFloat(c[4]));
            const highs = candles.map(c => parseFloat(c[2]));
            const lows = candles.map(c => parseFloat(c[3]));
            
            const recentHighs = [];
            const recentLows = [];
            
            for (let i = 5; i < candles.length - 5; i++) {
                const isHigh = highs[i] === Math.max(...highs.slice(i - 5, i + 6));
                const isLow = lows[i] === Math.min(...lows.slice(i - 5, i + 6));
                
                if (isHigh) recentHighs.push({ index: i, value: highs[i] });
                if (isLow) recentLows.push({ index: i, value: lows[i] });
            }
            
            let trendlineBreak = 'NO BREAK';
            const price = closes[closes.length - 1];
            
            if (recentHighs.length >= 2) {
                const lastTwo = recentHighs.slice(-2);
                const slope = (lastTwo[1].value - lastTwo[0].value) / (lastTwo[1].index - lastTwo[0].index);
                const projected = lastTwo[1].value + slope * (candles.length - 1 - lastTwo[1].index);
                
                if (price > projected * 1.01) trendlineBreak = '🔥 BULLISH BREAKOUT';
                else if (price > projected) trendlineBreak = '✅ BULLISH BREAK';
            }
            
            if (recentLows.length >= 2) {
                const lastTwo = recentLows.slice(-2);
                const slope = (lastTwo[1].value - lastTwo[0].value) / (lastTwo[1].index - lastTwo[0].index);
                const projected = lastTwo[1].value + slope * (candles.length - 1 - lastTwo[1].index);
                
                if (price < projected * 0.99) trendlineBreak = '💥 BEARISH BREAKDOWN';
                else if (price < projected) trendlineBreak = '⚠️ BEARISH BREAK';
            }
            
            return {
                signal: trendlineBreak,
                pivotHighs: recentHighs.length,
                pivotLows: recentLows.length,
                lastHigh: recentHighs.length > 0 ? recentHighs[recentHighs.length - 1].value.toFixed(8) : 'N/A',
                lastLow: recentLows.length > 0 ? recentLows[recentLows.length - 1].value.toFixed(8) : 'N/A'
            };
        }

        // ===== PEAKS & DIPS ANALİZ =====
        function analyzePeaksAndDips(candles) {
            const closes = candles.map(c => parseFloat(c[4]));
            const highs = candles.map(c => parseFloat(c[2]));
            const lows = candles.map(c => parseFloat(c[3]));
            
            const rsi = calculateRSI(closes, 14);
            const rsiValue = rsi[rsi.length - 1];
            
            const high = Math.max(...highs.slice(-100));
            const low = Math.min(...lows.slice(-100));
            const range = high - low;
            const price = closes[closes.length - 1];
            
            const fib382 = low + range * 0.382;
            const fib500 = low + range * 0.500;
            const fib618 = low + range * 0.618;
            
            let signal = 'NEUTRAL';
            let confidence = 50;
            
            if (rsiValue < 30 && price < fib382) {
                signal = '🎯 STRONG DIP - BUY';
                confidence = 85;
            } else if (rsiValue < 40 && price < fib500) {
                signal = '✅ DIP - BUY';
                confidence = 70;
            } else if (rsiValue > 70 && price > fib618) {
                signal = '⚠️ PEAK - SELL';
                confidence = 85;
            } else if (rsiValue > 60 && price > fib500) {
                signal = '🔔 NEAR PEAK - CAUTION';
                confidence = 70;
            }
            
            const ema20 = calculateEMA(closes, 20);
            const ema50 = calculateEMA(closes, 50);
            const trendConfirmation = price > ema20 && ema20 > ema50 ? 'BULLISH' : 
                                      price < ema20 && ema20 < ema50 ? 'BEARISH' : 'NEUTRAL';
            
            return {
                signal,
                confidence,
                rsi: rsiValue.toFixed(2),
                fibLevel: Math.abs(price - fib382) < Math.abs(price - fib500) && Math.abs(price - fib382) < Math.abs(price - fib618) ? '0.382' :
                          Math.abs(price - fib500) < Math.abs(price - fib618) ? '0.500' : '0.618',
                trendConfirmation,
                recommendation: confidence > 75 ? 'STRONG' : confidence > 60 ? 'MODERATE' : 'WEAK'
            };
        }

        // Helper function for OBV calculation
        function calculateOBV(klines) {
            let obv = 0;
            for (let i = 1; i < klines.length; i++) {
                const prevClose = parseFloat(klines[i - 1][4]);
                const currClose = parseFloat(klines[i][4]);
                const volume = parseFloat(klines[i][5]);
                
                if (currClose > prevClose) obv += volume;
                else if (currClose < prevClose) obv -= volume;
            }
            return obv;
        }

        // ===== UI GÜNCELLEME FONKSİYONLARI =====
        function updateCoinCount() {
            const coinCount = Object.keys(realPrices).length;
            const coinCountElement = document.getElementById('totalCoins');
            if (coinCountElement) {
                coinCountElement.textContent = coinCount;
            }
            
            // Console'da borsa dağılımını göster
            const exchangeCounts = {};
            Object.values(realPrices).forEach(price => {
                const ex = price.exchange || price.source || 'Unknown';
                exchangeCounts[ex] = (exchangeCounts[ex] || 0) + 1;
            });
            console.log('📊 Borsa Dağılımı:', exchangeCounts);
        }
        
        function updatePriceDisplays() {
            Object.keys(realPrices).forEach(pair => {
                updatePriceDisplay(pair);
            });
        }
        
        function updatePriceDisplay(pair) {
            const priceData = realPrices[pair];
            if (!priceData) return;
            
            // Eğer results sayfasında bu coin görüntüleniyorsa güncelle
            const resultCards = document.querySelectorAll('.result-card');
            resultCards.forEach(card => {
                const coinName = card.querySelector('.coin-name');
                if (coinName && coinName.textContent === pair) {
                    const priceElement = card.querySelector('.coin-price');
                    const changeElement = card.querySelector('.price-change');
                    
                    if (priceElement) {
                        const updatePrice = typeof priceData.price === 'string' ? parseFloat(priceData.price) : Number(priceData.price || 0);
                        priceElement.textContent = `$${formatPrice(updatePrice)}`;
                    }
                    
                    if (changeElement) {
                        const updateChange = typeof priceData.change === 'string' ? parseFloat(priceData.change) : Number(priceData.change || 0);
                        changeElement.className = `price-change ${updateChange >= 0 ? 'price-up' : 'price-down'}`;
                        changeElement.innerHTML = `${updateChange >= 0 ? '▲' : '▼'} ${Math.abs(updateChange).toFixed(2)}%`;
                    }
                }
            });
        }
        
        function updateFearGreedDisplay() {
            if (!fearGreedIndex) return;
            
            const fearGreedElements = document.querySelectorAll('#feature-fear');
            fearGreedElements.forEach(el => {
                const meter = el.querySelector('.fear-greed-meter');
                if (meter) {
                    const pointer = meter.querySelector('.fear-greed-pointer');
                    if (pointer) {
                        pointer.style.left = `${fearGreedIndex.value}%`;
                    }
                    
                    const valueDisplay = el.querySelector('div[style*="font-size:4em"]');
                    if (valueDisplay) {
                        valueDisplay.textContent = fearGreedIndex.value;
                    }
                }
            });
        }
        
        // ===== FUNDING RATES GÖRSELLEŞTİRME =====
        function updateFundingRatesDisplay() {
            const container = document.getElementById('funding-rates-container');
            if (!container) return;
            
            container.innerHTML = '';
            
            Object.keys(fundingRates).forEach(symbol => {
                const rate = fundingRates[symbol];
                const pair = symbol.replace('USDT', '/USDT');
                const ratePercent = rate.fundingRate || 0;
                const isPositive = ratePercent > 0;
                const color = isPositive ? '#ff6b6b' : '#4ecdc4';
                
                const card = document.createElement('div');
                card.style.cssText = `
                    background: rgba(255, 255, 255, 0.05);
                    backdrop-filter: blur(20px);
                    border: 1px solid rgba(255, 255, 255, 0.18);
                    border-radius: 15px;
                    padding: 20px;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                `;
                
                card.innerHTML = `
                    <div style="font-size: 1.3em; font-weight: bold; margin-bottom: 10px; color: ${color};">${pair}</div>
                    <div style="font-size: 2em; font-weight: bold; color: ${color}; margin-bottom: 10px;">
                        ${isPositive ? '+' : ''}${ratePercent.toFixed(4)}%
                    </div>
                    <div style="font-size: 0.9em; color: #aaa; margin-bottom: 5px;">
                        Mark Price: $${rate.markPrice?.toFixed(2) || 'N/A'}
                    </div>
                    <div style="font-size: 0.9em; color: #aaa; margin-bottom: 5px;">
                        Index Price: $${rate.indexPrice?.toFixed(2) || 'N/A'}
                    </div>
                    <div style="font-size: 0.8em; color: #888;">
                        Next Funding: ${rate.nextFundingTime ? new Date(rate.nextFundingTime).toLocaleTimeString() : 'N/A'}
                    </div>
                    <div style="margin-top: 15px; height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden;">
                        <div style="height: 100%; width: ${Math.min(100, Math.abs(ratePercent) * 100)}%; background: ${color};"></div>
                    </div>
                `;
                
                container.appendChild(card);
            });
        }
        
        // ===== HEATMAP GERÇEK ZAMANLI GÜNCELLEME =====
        function updateHeatmap() {
            const heatmapContainer = document.querySelector('.heatmap-container');
            if (!heatmapContainer) return;
            
            heatmapContainer.innerHTML = generateHeatmap();
        }
        
        // Heatmap'i her 30 saniyede bir güncelle
        setInterval(updateHeatmap, 30000);

        async function getAIAnalysis(coin, priceData, indicators = null) {
            try {
                const langText = currentLanguage === 'de' ? 'DEUTSCH' : 'TÜRKÇE';
                let technicalData = '';
                let advancedData = '';
                
                if (indicators) {
                    technicalData = `
Technical Indicators:
- RSI: ${indicators.rsi?.toFixed(2) || 'N/A'} ${indicators.rsi < 30 ? '(Oversold)' : indicators.rsi > 70 ? '(Overbought)' : '(Neutral)'}
- MACD: ${indicators.macd?.toFixed(4) || 'N/A'} | Signal: ${indicators.macdSignal?.toFixed(4) || 'N/A'} | Histogram: ${indicators.macdHistogram?.toFixed(4) || 'N/A'}
- EMA Trend: ${indicators.trend || 'N/A'} (EMA9: ${indicators.ema9?.toFixed(2) || 'N/A'}, EMA21: ${indicators.ema21?.toFixed(2) || 'N/A'}, EMA50: ${indicators.ema50?.toFixed(2) || 'N/A'})
- Bollinger Bands: Price ${priceData.price.toFixed(2)} | Upper: ${indicators.bbUpper?.toFixed(2) || 'N/A'} | Lower: ${indicators.bbLower?.toFixed(2) || 'N/A'}
- Volume Ratio: ${indicators.volumeRatio?.toFixed(2) || 'N/A'}x
- Stochastic: ${indicators.stochastic?.toFixed(2) || 'N/A'} / ${indicators.stochasticD?.toFixed(2) || 'N/A'}
- ADX: ${indicators.adx?.toFixed(2) || 'N/A'}
- ATR: ${indicators.atr?.toFixed(2) || 'N/A'}
- VWAP: ${indicators.vwap?.toFixed(2) || 'N/A'}`;

                    // 90 İndikatör analizi
                    if (indicators.indicators90) {
                        advancedData += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 90 İNDİKATÖR ANALİZİ
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Bull/Bear: ${indicators.indicators90.bull}/${indicators.indicators90.bear}
• Trend Bull/Bear: ${indicators.indicators90.scores?.trend?.bull || 0}/${indicators.indicators90.scores?.trend?.bear || 0}
• Momentum Bull/Bear: ${indicators.indicators90.scores?.momentum?.bull || 0}/${indicators.indicators90.scores?.momentum?.bear || 0}
• Volume Bull/Bear: ${indicators.indicators90.scores?.volume?.bull || 0}/${indicators.indicators90.scores?.volume?.bear || 0}
• Volatility Bull/Bear: ${indicators.indicators90.scores?.volatility?.bull || 0}/${indicators.indicators90.scores?.volatility?.bear || 0}
• Institutional Bull/Bear: ${indicators.indicators90.scores?.institutional?.bull || 0}/${indicators.indicators90.scores?.institutional?.bear || 0}`;
                    }

                    // Institutional analiz
                    if (indicators.institutional) {
                        advancedData += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🏢 KURUMSAL ANALİZ
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Dark Pool: ${indicators.institutional.darkPool || 'N/A'}
• Order Flow: ${indicators.institutional.orderFlow || 'N/A'}
• Buy Pressure: ${indicators.institutional.buyPressure || 'N/A'}
• Sell Pressure: ${indicators.institutional.sellPressure || 'N/A'}
• Block Trades: ${indicators.institutional.blockTrades || 0}
• Buy/Sell Ratio: ${indicators.institutional.ratio || 'N/A'}%`;
                    }

                    // Whale analiz
                    if (indicators.whales) {
                        advancedData += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🐋 WHALE ANALİZİ
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Status: ${indicators.whales.status || 'N/A'}
• Toplam Orders: ${indicators.whales.orders || 0}
• Son Aktivite: ${indicators.whales.recentOrders || 0} orders
• Buys/Sells: ${indicators.whales.buys || 0}/${indicators.whales.sells || 0}
• Sentiment: ${indicators.whales.sentiment || 'N/A'}
• Accumulation: ${indicators.whales.accumulation || 'N/A'}%
• Distribution: ${indicators.whales.distribution || 'N/A'}%
• Net Flow: ${indicators.whales.netFlow || 'N/A'}`;
                    }

                    // Market Makers
                    if (indicators.marketMakers) {
                        advancedData += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 MARKET MAKERS (WYCKOFF & VSA)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Wyckoff Phase: ${indicators.marketMakers.wyckoff?.phase || 'N/A'}
• Position: ${indicators.marketMakers.wyckoff?.position || 'N/A'}%
• CVD Trend: ${indicators.marketMakers.cvd?.trend || 'N/A'}
• CVD Strength: ${indicators.marketMakers.cvd?.strength || 'N/A'}
• VSA: ${indicators.marketMakers.vsa || 'N/A'}
• Volume Ratio: ${indicators.marketMakers.volumeProfile?.ratio || 'N/A'}x`;
                    }

                    // Smart Money
                    if (indicators.smartMoneyConcepts) {
                        advancedData += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💎 SMART MONEY CONCEPTS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• BOS (Break of Structure): ${indicators.smartMoneyConcepts.bos || 'N/A'}
• CHoCH: ${indicators.smartMoneyConcepts.choch || 'N/A'}
• Zone: ${indicators.smartMoneyConcepts.zone || 'N/A'}
• Position: ${indicators.smartMoneyConcepts.position || 'N/A'}%
• Fair Value Gaps: ${indicators.smartMoneyConcepts.fvg?.length || 0} adet
• Order Blocks: ${indicators.smartMoneyConcepts.orderBlocks?.length || 0} adet`;
                    }

                    // Trader analiz
                    if (indicators.traders) {
                        advancedData += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👥 TRADER ANALİZİ
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Retail vs Institutional: ${indicators.traders.retailRatio || 'N/A'}% / ${indicators.traders.ratio || 'N/A'}%
• Dominance: ${indicators.traders.dominance || 'N/A'}
• Sentiment: ${indicators.traders.sentiment || 'N/A'}
• Smart Money: ${indicators.traders.smartMoney || 'N/A'}`;
                    }

                    // Stratejik sinyaller
                    if (indicators.pumpDump || indicators.trendBreak || indicators.peaksAndDips) {
                        advancedData += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 STRATEJİK SINYALLER
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;
                        if (indicators.pumpDump) {
                            advancedData += `
• Pump & Dump: ${indicators.pumpDump.signal || 'N/A'} (${indicators.pumpDump.strength || 0}/100)
• Volume Spike: ${indicators.pumpDump.volSpike || 'N/A'}x`;
                        }
                        if (indicators.trendBreak) {
                            advancedData += `
• Trend Break: ${indicators.trendBreak.signal || 'N/A'}
• Pivots: ${indicators.trendBreak.pivotHighs || 0}H/${indicators.trendBreak.pivotLows || 0}L`;
                        }
                        if (indicators.peaksAndDips) {
                            advancedData += `
• Peaks & Dips: ${indicators.peaksAndDips.signal || 'N/A'} (Confidence: ${indicators.peaksAndDips.confidence || 0}%)`;
                        }
                    }
                }
                
                const prompt = `Sen profesyonel kripto analistsin. Aşağıdaki verileri analiz et ve ${langText} dilinde DETAYLI analiz yap:

🎯 ${coin}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 GENEL
• Fiyat: $${priceData.price}
• 24h Değişim: ${priceData.change.toFixed(2)}%
• 24h Volume: $${(priceData.volume/1000000).toFixed(0)}M
• 24h High: $${priceData.high24h?.toFixed(2) || 'N/A'}
• 24h Low: $${priceData.low24h?.toFixed(2) || 'N/A'}${technicalData}${advancedData}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DETAYLI ANALİZ ${langText}:

1️⃣ 90 İNDİKATÖR DEĞERLENDİRMESİ:
   - Trend, Momentum, Volume, Volatility, Institutional analizini yap
   - Her kategorinin Bull/Bear oranını yorumla
   - Teknik indikatörlerin (RSI, MACD, ADX, Stoch) birleşik mesajını açıkla

2️⃣ KURUMSAL & WHALE & SMART MONEY:
   - Dark Pool aktivitesi ve Order Flow'u yorumla
   - Whale aktivitesi ve accumulation/distribution analizini yap
   - Wyckoff fazı ve Market Maker stratejisini açıkla
   - Smart Money Concepts (BOS, CHoCH, FVG, Order Blocks) değerlendirmesi
   - CVD ve VSA sinyallerini yorumla

3️⃣ STRATEJİK SINYALLER:
   - Pump & Dump tespitini değerlendir
   - Trend kırılımlarını analiz et
   - Peak & Dip sinyallerini yorumla

4️⃣ SONUÇ VE TAVSİYE:
   **📌 KARAR: [AL / SAT / BEKLE / GÜÇLÜ AL / GÜÇLÜ SAT]**
   **⏰ ZAMAN: [HEMEN / 1-4 SAAT / 4-12 SAAT / 1-3 GÜN]**
   **🎯 GÜVEN: [%XX]**
   **⚠️ RİSK SEVİYESİ: [DÜŞÜK / ORTA / YÜKSEK]**
   
   Net ve anlaşılır şekilde AL/SAT/BEKLE kararını ver ve nedenlerini açıkla.

PROFESYONEL, DETAYLI ve SOMUT ANALİZ YAP!`;

                const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEYS.GROQ}`
                    },
                    body: JSON.stringify({
                        model: 'llama-3.3-70b-versatile',
                        messages: [
                            { 
                                role: 'system', 
                                content: `Sen profesyonel kripto para analisti ve trader'sın. ${langText} dilinde detaylı, profesyonel ve anlaşılır analizler yaparsın. 50+ optimize edilmiş premium indikatör, kurumsal analiz, whale tracking, smart money concepts ve tüm stratejik sinyalleri değerlendirerek kesin AL/SAT/BEKLE kararı verirsin.` 
                            },
                            { role: 'user', content: prompt }
                        ],
                        temperature: 0.7,
                        max_tokens: 3000
                    })
                });

                const data = await response.json();
                const aiText = data.choices[0].message.content;
                
                // Karar, zaman, güven ve risk seviyesini bul
                const kararMatch = aiText.match(/KARAR:\s*\[(.*?)\]/i) || aiText.match(/📌\s*KARAR:\s*(.*?)(?:\n|$)/i);
                const zamanMatch = aiText.match(/ZAMAN:\s*\[(.*?)\]/i) || aiText.match(/⏰\s*ZAMAN:\s*(.*?)(?:\n|$)/i);
                const guvenMatch = aiText.match(/GÜVEN:\s*\[(.*?)\]/i) || aiText.match(/🎯\s*GÜVEN:\s*(.*?)(?:\n|$)/i);
                const riskMatch = aiText.match(/RİSK SEVİYESİ:\s*\[(.*?)\]/i) || aiText.match(/⚠️\s*RİSK SEVİYESİ:\s*(.*?)(?:\n|$)/i);
                
                // Öneri belirleme
                let recommendation = 'WAIT';
                if (kararMatch) {
                    const karar = kararMatch[1].toUpperCase();
                    if (karar.includes('AL') || karar.includes('LONG') || karar.includes('BUY')) {
                        recommendation = 'LONG';
                    } else if (karar.includes('SAT') || karar.includes('SHORT') || karar.includes('SELL')) {
                        recommendation = 'SHORT';
                    }
                }
                
                // Güven belirleme
                let confidence = 'MEDIUM';
                if (guvenMatch) {
                    const guven = guvenMatch[1].toUpperCase();
                    if (guven.includes('%8') || guven.includes('8') || guven.includes('YÜKSEK') || guven.includes('HIGH')) {
                        confidence = 'HIGH';
                    } else if (guven.includes('%5') || guven.includes('5') || guven.includes('DÜŞÜK') || guven.includes('LOW')) {
                        confidence = 'LOW';
                    }
                }
                
                // Detaylı analiz metnini formatla
                let formattedAnalysis = aiText;
                if (kararMatch || zamanMatch || guvenMatch || riskMatch) {
                    formattedAnalysis = aiText;
                }
                
                return {
                    analysis: formattedAnalysis,
                    recommendation: recommendation,
                    confidence: confidence,
                    zaman: zamanMatch ? zamanMatch[1] : 'N/A',
                    risk: riskMatch ? riskMatch[1] : 'N/A'
                };
            } catch (error) {
                console.error('❌ AI hatası:', error);
                const signal = priceData.change > 2 ? 'LONG' : priceData.change < -2 ? 'SHORT' : 'WAIT';
                return {
                    analysis: `Technical analysis for ${coin} shows ${signal.toLowerCase()} momentum based on 24h performance.`,
                    recommendation: signal,
                    confidence: 'MEDIUM'
                };
            }
        }

        async function sendTelegramNotification(message) {
            try {
                await fetch(`https://api.telegram.org/bot${API_KEYS.TELEGRAM_BOT}/sendMessage`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        chat_id: API_KEYS.TELEGRAM_CHAT,
                        text: message,
                        parse_mode: 'HTML'
                    })
                });
                console.log('✅ Telegram gönderildi');
            } catch (error) {
                console.error('❌ Telegram hatası:', error);
            }
        }

        // ===== DETAYLI TELEGRAM GÖNDERME FONKSİYONU =====
        async function sendDetailedTelegram(coin, priceData, indicators, aiAnalysis) {
            try {
                const coinSymbol = coin.replace('/USDT', '');
                let message = `🔥 <b>YASAR-AI KRIPTO ULTRA SCANNER - TARAMA SONUCU</b> 🔥\n\n`;
                message += `📊 <b>${coinSymbol}</b>\n`;
                message += `━━━━━━━━━━━━━━━━━━━━━━\n`;
                
                const score = calculateRealScore(coin, priceData);
                const signal = determineRealSignal(coin, priceData, score);
                const signalText = signal === 'long' ? '🟢 LONG' : signal === 'short' ? '🔴 SHORT' : '⚪ WAIT';
                
                message += `💯 <b>SKOR: ${score}/100</b>\n`;
                message += `${signalText}\n\n`;
                message += `💰 <b>FİYAT:</b> $${formatPrice(priceData.price)}\n`;
                message += `📈 <b>24h:</b> ${priceData.change >= 0 ? '+' : ''}${priceData.change.toFixed(2)}%\n`;
                message += `📊 High: $${formatPrice(priceData.high24h || 0)} | Low: $${formatPrice(priceData.low24h || 0)}\n\n`;

                // === TRADE SEVİYELERİ (GİRİŞ, TP1-2-3, STOP LOSS) ===
                message += `📋 <b>TRADE SEVİYELERİ:</b>\n`;
                message += `━━━━━━━━━━━━━━━━━━━━━━\n`;
                
                const entry = priceData.price;
                const atr = indicators?.atr || (entry * 0.02);
                
                if (signal === 'long') {
                    const tp1 = entry + (atr * 1.0);
                    const tp2 = entry + (atr * 2.0);
                    const tp3 = entry + (atr * 3.0);
                    const sl = entry - (atr * 1.5);
                    
                    message += `🟢 <b>GİRİŞ:</b> $${formatPrice(entry)} (Mevcut Fiyat)\n`;
                    message += `📈 <b>TP1:</b> $${formatPrice(tp1)} (+${((atr * 1.0 / entry) * 100).toFixed(2)}%) - %50 Pozisyon Kapat\n`;
                    message += `📈 <b>TP2:</b> $${formatPrice(tp2)} (+${((atr * 2.0 / entry) * 100).toFixed(2)}%) - %30 Pozisyon Kapat\n`;
                    message += `📈 <b>TP3:</b> $${formatPrice(tp3)} (+${((atr * 3.0 / entry) * 100).toFixed(2)}%) - %20 Pozisyon Kapat\n`;
                    message += `🔴 <b>STOP LOSS:</b> $${formatPrice(sl)} (-${((atr * 1.5 / entry) * 100).toFixed(2)}%)\n\n`;
                } else if (signal === 'short') {
                    const tp1 = entry - (atr * 1.0);
                    const tp2 = entry - (atr * 2.0);
                    const tp3 = entry - (atr * 3.0);
                    const sl = entry + (atr * 1.5);
                    
                    message += `🔴 <b>GİRİŞ:</b> $${formatPrice(entry)} (Mevcut Fiyat)\n`;
                    message += `📉 <b>TP1:</b> $${formatPrice(tp1)} (-${((atr * 1.0 / entry) * 100).toFixed(2)}%) - %50 Pozisyon Kapat\n`;
                    message += `📉 <b>TP2:</b> $${formatPrice(tp2)} (-${((atr * 2.0 / entry) * 100).toFixed(2)}%) - %30 Pozisyon Kapat\n`;
                    message += `📉 <b>TP3:</b> $${formatPrice(tp3)} (-${((atr * 3.0 / entry) * 100).toFixed(2)}%) - %20 Pozisyon Kapat\n`;
                    message += `🔴 <b>STOP LOSS:</b> $${formatPrice(sl)} (+${((atr * 1.5 / entry) * 100).toFixed(2)}%)\n\n`;
                } else {
                    message += `⚪ <b>GİRİŞ:</b> $${formatPrice(entry)} (Bekleme Modu)\n`;
                    message += `⚠️ Daha iyi giriş noktaları için bekleyin\n\n`;
                }

                // === FİBONACCİ SEVİYELERİ ===
                message += `📐 <b>FİBONACCİ SEVİYELERİ:</b>\n`;
                message += `━━━━━━━━━━━━━━━━━━━━━━\n`;
                
                const fibLevels = calculateFibonacciLevels(coin, priceData.price);
                fibLevels.forEach(fib => {
                    const distance = ((fib.price - entry) / entry * 100);
                    const distanceText = distance >= 0 ? `+${distance.toFixed(2)}%` : `${distance.toFixed(2)}%`;
                    message += `${fib.level}% - $${formatPrice(fib.price)} (${distanceText})\n`;
                });
                message += `\n`;

                // === LİKİDASYON SEVİYELERİ ===
                message += `⚠️ <b>LİKİDASYON SEVİYELERİ:</b>\n`;
                message += `━━━━━━━━━━━━━━━━━━━━━━\n`;
                
                const symbol = coin.replace('/USDT', 'USDT');
                const realLiquidation = liquidationData[symbol];
                
                if (realLiquidation && realLiquidation.total > 0) {
                    const total = realLiquidation.total;
                    const longLiq = realLiquidation.longLiquidation || 0;
                    const shortLiq = realLiquidation.shortLiquidation || 0;
                    
                    message += `💰 <b>Toplam Likidasyon:</b> $${(total / 1000000).toFixed(2)}M\n`;
                    message += `🟢 LONG Liq: $${(longLiq / 1000000).toFixed(2)}M\n`;
                    message += `🔴 SHORT Liq: $${(shortLiq / 1000000).toFixed(2)}M\n\n`;
                    
                    // Tahmini likidasyon seviyeleri
                    const liquidationLevels = [
                        { price: entry * 0.93, label: '-7%' },
                        { price: entry * 0.96, label: '-4%' },
                        { price: entry * 0.98, label: '-2%' },
                        { price: entry * 1.02, label: '+2%' },
                        { price: entry * 1.04, label: '+4%' },
                        { price: entry * 1.07, label: '+7%' }
                    ];
                    
                    liquidationLevels.forEach(level => {
                        const distance = ((level.price - entry) / entry * 100);
                        message += `${level.label}: $${formatPrice(level.price)}\n`;
                    });
                } else {
                    message += `⚠️ Likidasyon verisi şu an mevcut değil\n`;
                }
                message += `\n`;

                // === İNDİKATÖR ÖZETİ ===
                if (indicators) {
                    // 90 İndikatör
                    if (indicators.indicators90) {
                        message += `📊 <b>90 İNDİKATÖR ANALİZİ:</b>\n`;
                        message += `🟢 Bull: ${indicators.indicators90.bull} | 🔴 Bear: ${indicators.indicators90.bear}\n`;
                        message += `📈 RSI: ${indicators.rsi?.toFixed(1) || 'N/A'}\n`;
                        message += `📊 MACD: ${indicators.macd?.toFixed(2) || 'N/A'}\n`;
                        message += `⚡ ADX: ${indicators.adx?.toFixed(1) || 'N/A'}\n\n`;
                    }

                    // Institutional
                    if (indicators.institutional) {
                        message += `🏢 <b>KURUMSAL ANALİZ:</b>\n`;
                        message += `• Dark Pool: ${indicators.institutional.darkPool?.status || 'N/A'}\n`;
                        message += `• Order Flow Buy: ${indicators.institutional.orderFlow?.buyPressure || 'N/A'}\n`;
                        message += `• Order Flow Sell: ${indicators.institutional.orderFlow?.sellPressure || 'N/A'}\n`;
                        message += `• Block Trades: ${indicators.institutional.darkPool?.blocks || 0}\n\n`;
                    }

                    // Whale
                    if (indicators.whales) {
                        message += `🐋 <b>BALİNA ANALİZİ:</b>\n`;
                        message += `• Aktivite: ${indicators.whales.activity?.status || 'N/A'}\n`;
                        message += `• Sentiment: ${indicators.whales.sentiment?.accumulation || 'N/A'}% Birikim | ${indicators.whales.sentiment?.distribution || 'N/A'}% Dağıtım\n`;
                        message += `• Net Flow: ${indicators.whales.netFlow || 'N/A'}\n\n`;
                    }

                    // Market Makers
                    if (indicators.marketMakers) {
                        message += `🏦 <b>PİYASA YAPICI:</b>\n`;
                        message += `• Wyckoff: ${indicators.marketMakers.wyckoff?.phase || 'N/A'}\n`;
                        message += `• CVD Trend: ${indicators.marketMakers.cvd?.trend || 'N/A'}\n`;
                        message += `• VSA: ${indicators.marketMakers.vsa || 'N/A'}\n\n`;
                    }

                    // Traders
                    if (indicators.traders) {
                        message += `👥 <b>TRADER ANALİZİ:</b>\n`;
                        message += `• Retail: ${indicators.traders.retailRatio || '0'}% | Kurumsal: ${indicators.traders.ratio || '0'}%\n`;
                        message += `• Sentiment: ${indicators.traders.sentiment || 'N/A'}\n`;
                        message += `• Smart Money: ${indicators.traders.smartMoney || 'N/A'}\n\n`;
                    }

                    // Smart Money
                    if (indicators.smartMoneyConcepts) {
                        message += `💎 <b>SMART MONEY:</b>\n`;
                        message += `• BOS: ${indicators.smartMoneyConcepts.bos || 'N/A'}\n`;
                        message += `• CHoCH: ${indicators.smartMoneyConcepts.choch || 'N/A'}\n`;
                        message += `• Zone: ${indicators.smartMoneyConcepts.zone || 'N/A'}\n`;
                        message += `• Position: ${indicators.smartMoneyConcepts.position || 'N/A'}%\n\n`;
                    }
                }

                // === AI ANALİZ (eğer varsa) ===
                if (aiAnalysis && aiAnalysis.length > 0) {
                    message += `🤖 <b>GROQ AI ANALİZİ:</b>\n`;
                    message += `━━━━━━━━━━━━━━━━━━━━━━\n`;
                    const aiText = typeof aiAnalysis === 'string' ? aiAnalysis : JSON.stringify(aiAnalysis);
                    message += `${aiText.substring(0, 1500)}${aiText.length > 1500 ? '...' : ''}\n\n`;
                }

                message += `━━━━━━━━━━━━━━━━━━━━━━\n`;
                message += `⚡ <b>YASAR-AI KRIPTO ULTRA SCANNER</b>\n`;
                message += `📊 50+ PREMİUM İNDİKATÖR • 🏢 7 BORSA • 🤖 GROQ AI\n`;
                message += `⏰ ${selectedTimeframe} • 📅 ${new Date().toLocaleString('tr-TR')}`;

                await sendTelegramNotification(message);
                alert('✅ Telegram\'a başarıyla gönderildi!');
            } catch (error) {
                console.error('❌ Telegram hatası:', error);
                alert('❌ Telegram gönderme hatası: ' + error.message);
            }
        }

        async function startScan() {
            const button = document.getElementById('scanButton');
            button.disabled = true;
            button.textContent = '⏳ Tarama Başlatılıyor...';
            
            const loadingSection = document.getElementById('loadingSection');
            if (loadingSection) {
                loadingSection.style.display = 'block';
                const progressBar = loadingSection.querySelector('.progress-bar');
                if (progressBar) {
                    progressBar.style.width = '0%';
                    progressBar.textContent = '0%';
                }
            }
            
            // Tüm result container'ları temizle
            const longContainer = document.getElementById('longResultsContainer');
            const shortContainer = document.getElementById('shortResultsContainer');
            const waitContainer = document.getElementById('waitResultsContainer');
            if (longContainer) longContainer.innerHTML = '';
            if (shortContainer) shortContainer.innerHTML = '';
            if (waitContainer) waitContainer.innerHTML = '';
            
            switchTab('results');
            const navTabs = document.querySelectorAll('.nav-tab');
            if (navTabs[4]) navTabs[4].classList.add('active');

            try {
                // 1. Fiyatları güncelle (hızlı)
                button.textContent = '⏳ Fiyatlar güncelleniyor...';
                await fetchRealPrices();
                console.log(`✅ ${Object.keys(realPrices).length} coin fiyatı güncellendi`);
                
                // 2. Teknik analizleri kontrol et ve gerekirse hesapla (paralel)
                button.textContent = '⏳ Teknik analizler hesaplanıyor...';
                const startTime = Date.now();
                
                // Teknik analizler varsa kullan, yoksa hızlıca hesapla (sadece önemli coinler için)
                if (Object.keys(technicalIndicators).length < 10) {
                    console.log('⚡ Teknik analizler eksik veya eski, hızlı hesaplama başlatılıyor...');
                    // Paralel hesaplama başlat (await etmeden devam et)
                    calculateTechnicalIndicators().then(() => {
                        console.log(`✅ Teknik analizler hesaplandı (${((Date.now() - startTime) / 1000).toFixed(1)}s)`);
                    }).catch(e => console.error('Teknik analiz hatası:', e));
                }
                
                // 3. Sonuçları oluştur (paralel ve optimize)
                button.textContent = '⏳ Sonuçlar oluşturuluyor...';
                await generateResults();
                
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                console.log(`⚡ Tarama tamamlandı: ${elapsed}s`);
                button.textContent = `✅ Tarama Tamamlandı (${elapsed}s) 🚀`;
                
                // Dashboard'u güncelle
                setTimeout(() => {
                    updateTradingDashboard();
                    document.dispatchEvent(new CustomEvent('scanComplete'));
                }, 1000);
                
            } catch (error) {
                console.error('❌ Tarama hatası:', error);
                button.textContent = '❌ Hata - Tekrar Dene';
                alert('Tarama hatası: ' + error.message);
            } finally {
                if (loadingSection) {
                    loadingSection.style.display = 'none';
                }
                button.disabled = false;
                setTimeout(() => {
                    button.textContent = '🔍 GERÇEK ZAMANLI AI TARAMA BAŞLAT 🚀';
                }, 2000);
                
                // Telegram bildirimi (opsiyonel - hata olursa devam et)
                try {
                    const bullish = document.getElementById('bullishSignals')?.textContent || '0';
                    const bearish = document.getElementById('bearishSignals')?.textContent || '0';
                    await sendTelegramNotification(`🚀 <b>YASAR-AI KRIPTO ULTRA SCANNER</b>\nTarama tamamlandı!\n\n🟢 LONG: ${bullish}\n🔴 SHORT: ${bearish}`);
                } catch (e) {
                    console.log('Telegram bildirimi atlandı:', e);
                }
            }
        }

        // ===== GERÇEK SKOR HESAPLAMA (Teknik Analiz Tabanlı) =====
        function calculateRealScore(coin, priceData) {
            let score = 50; // Başlangıç skoru
            const indicators = technicalIndicators[coin];
            
            if (!indicators) {
                // Teknik analiz yoksa basit skor
                return priceData.change > 2 ? 65 : priceData.change < -2 ? 35 : 50;
            }
            
            // RSI analizi (0-30 oversold, 70-100 overbought)
            if (indicators.rsi < 30) {
                score += 15; // Oversold, yükseliş potansiyeli
            } else if (indicators.rsi > 70) {
                score -= 15; // Overbought, düşüş potansiyeli
            }
            
            // MACD analizi
            if (indicators.macd > indicators.macdSignal && indicators.macdHistogram > 0) {
                score += 10; // Bullish MACD
            } else if (indicators.macd < indicators.macdSignal && indicators.macdHistogram < 0) {
                score -= 10; // Bearish MACD
            }
            
            // EMA trend analizi
            if (indicators.trend === 'UP' && indicators.ema9 > indicators.ema50) {
                score += 12; // Güçlü uptrend
            } else if (indicators.trend === 'DOWN' && indicators.ema9 < indicators.ema50) {
                score -= 12; // Güçlü downtrend
            }
            
            // Volume analizi
            if (indicators.volumeRatio > 1.5) {
                score += 8; // Yüksek volume, güçlü hareket
            } else if (indicators.volumeRatio < 0.5) {
                score -= 5; // Düşük volume, zayıf hareket
            }
            
            // Bollinger Bands pozisyonu
            if (priceData.price < indicators.bbLower) {
                score += 10; // Alt bandın altında, oversold
            } else if (priceData.price > indicators.bbUpper) {
                score -= 10; // Üst bandın üstünde, overbought
            }
            
            // Stochastic analizi
            if (indicators.stochastic && indicators.stochasticD) {
                if (indicators.stochastic < 20 && indicators.stochastic > indicators.stochasticD) {
                    score += 8; // Oversold ve bullish cross
                } else if (indicators.stochastic > 80 && indicators.stochastic < indicators.stochasticD) {
                    score -= 8; // Overbought ve bearish cross
                }
            }
            
            // === YENİ: GELİŞMİŞ KURUMSAL TEKNİKLER SKORU ===
            
            // Order Flow Delta analizi (çok güçlü sinyal)
            if (indicators.orderFlowDelta) {
                if (indicators.orderFlowDelta.trend === 'STRONG BULLISH' && indicators.orderFlowDelta.cumulativeDelta > 0) {
                    score += 15; // Çok güçlü alış baskısı
                } else if (indicators.orderFlowDelta.trend === 'STRONG BEARISH' && indicators.orderFlowDelta.cumulativeDelta < 0) {
                    score -= 15; // Çok güçlü satış baskısı
                }
                const imbalance = parseFloat(indicators.orderFlowDelta.imbalance);
                if (imbalance > 20) score += 8; // Güçlü alış dengesizliği
                else if (imbalance < -20) score -= 8; // Güçlü satış dengesizliği
            }
            
            // Premium/Discount Zones analizi
            if (indicators.premiumDiscount) {
                if (indicators.premiumDiscount.currentZone === 'DISCOUNT') {
                    score += 12; // Birikim bölgesi - Alış fırsatı
                } else if (indicators.premiumDiscount.currentZone === 'PREMIUM') {
                    score -= 12; // Dağıtım bölgesi - Satış uyarısı
                }
            }
            
            // Liquidity Sweeps analizi
            if (indicators.liquiditySweeps && indicators.liquiditySweeps.length > 0) {
                const bullishSweeps = indicators.liquiditySweeps.filter(s => s.type === 'BULLISH_SWEEP').length;
                const bearishSweeps = indicators.liquiditySweeps.filter(s => s.type === 'BEARISH_SWEEP').length;
                if (bullishSweeps > bearishSweeps) score += 10; // Bullish sweep tespit edildi
                else if (bearishSweeps > bullishSweeps) score -= 10; // Bearish sweep tespit edildi
            }
            
            // Multi-Timeframe Confluence
            if (indicators.multiTimeframe) {
                if (indicators.multiTimeframe.confluence.includes('STRONG_BULLISH')) {
                    score += 18; // Çok güçlü uyum
                } else if (indicators.multiTimeframe.confluence.includes('BULLISH')) {
                    score += 10;
                } else if (indicators.multiTimeframe.confluence.includes('STRONG_BEARISH')) {
                    score -= 18;
                } else if (indicators.multiTimeframe.confluence.includes('BEARISH')) {
                    score -= 10;
                }
            }
            
            // Advanced Volume Profile
            if (indicators.advancedVolumeProfile) {
                const positionInVA = parseFloat(indicators.advancedVolumeProfile.positionInVA);
                if (positionInVA < 20) {
                    score += 10; // Value Area altında - Birikim
                } else if (positionInVA > 80) {
                    score -= 10; // Value Area üstünde - Dağıtım
                }
            }
            
            // Session Analysis (volatilite için bonus)
            if (indicators.sessionAnalysis && indicators.sessionAnalysis.sessionActivity === 'EXTREME') {
                // Yüksek volatilite saatinde daha fazla sinyal ağırlığı
                if (score > 55) score += 5;
                else if (score < 45) score -= 5;
            }
            
            // Tape Reading (Order Flow Analysis)
            if (indicators.tapeReading) {
                const tape = indicators.tapeReading;
                if (tape.orderFlowDirection.includes('BUYING') && tape.tapeSentiment.includes('BULLISH')) {
                    score += 8; // Güçlü alım baskısı
                } else if (tape.orderFlowDirection.includes('SELLING') && tape.tapeSentiment.includes('BEARISH')) {
                    score -= 8; // Güçlü satım baskısı
                } else if (tape.orderFlowDirection.includes('BUYING')) {
                    score += 4; // Orta alım baskısı
                } else if (tape.orderFlowDirection.includes('SELLING')) {
                    score -= 4; // Orta satım baskısı
                }
                
                // Absorption patterns = reversal sinyali
                if (tape.absorptionPatterns > 3 && score > 60) {
                    score -= 5; // Yüksek skorda absorption = düşüş riski
                } else if (tape.absorptionPatterns > 3 && score < 40) {
                    score += 5; // Düşük skorda absorption = yükseliş fırsatı
                }
            }
            
            // ADX analizi (trend gücü)
            if (indicators.adx) {
                if (indicators.adx > 25 && indicators.trend === 'UP') {
                    score += 6; // Güçlü uptrend
                } else if (indicators.adx > 25 && indicators.trend === 'DOWN') {
                    score -= 6; // Güçlü downtrend
                } else if (indicators.adx < 20) {
                    score -= 3; // Zayıf trend
                }
            }
            
            // CVD analizi
            if (indicators.cvdTrend === 'BULLISH') {
                score += 7;
            } else if (indicators.cvdTrend === 'BEARISH') {
                score -= 7;
            }
            
            // VWAP analizi
            if (indicators.vwap) {
                if (priceData.price > indicators.vwap) {
                    score += 5; // Fiyat VWAP üstünde
                } else {
                    score -= 5; // Fiyat VWAP altında
                }
            }
            
            // Order Blocks analizi
            if (indicators.orderBlocks && indicators.orderBlocks > 2) {
                score += 3; // Aktif order blocks var
            }
            
            // 90 İndikatör analizi etkisi - Balanced scoring
            if (indicators.indicators90) {
                const bullCount = indicators.indicators90.bull || 0;
                const bearCount = indicators.indicators90.bear || 0;
                const neutralCount = indicators.indicators90.neutral || 0;
                const total = bullCount + bearCount + neutralCount;
                
                if (total > 0) {
                    // Balanced scoring - bear sinyallerini daha fazla değerlendir
                    const bullPercent = (bullCount / total) * 100;
                    const bearPercent = (bearCount / total) * 100;
                    
                    // Eğer bear sinyali fazlaysa, short sinyali verecek şekilde skorla
                    if (bearPercent > bullPercent + 10) {
                        score = -Math.abs(bearPercent - 50); // Negative score for short
                    } else if (bullPercent > bearPercent + 10) {
                        score = Math.abs(bullPercent - 50); // Positive score for long
                    } else {
                        score = indicators.indicators90.score || 0; // Neutral
                    }
                } else {
                    score = indicators.indicators90.score || 0;
                }
            }
            
            // Institutional analiz etkisi
            if (indicators.institutional) {
                if (indicators.institutional.darkPool === 'VERY HIGH') score += 8;
                else if (indicators.institutional.darkPool === 'HIGH') score += 5;
                else if (indicators.institutional.darkPool === 'MEDIUM') score += 2;
                
                if (indicators.institutional.orderFlow === 'STRONG BUY') score += 8;
                else if (indicators.institutional.orderFlow === 'BUY') score += 5;
                else if (indicators.institutional.orderFlow === 'SELL') score -= 5;
                else if (indicators.institutional.orderFlow === 'STRONG SELL') score -= 8;
            }
            
            // Whale analiz etkisi
            if (indicators.whales) {
                if (indicators.whales.status === 'VERY ACTIVE') score += 7;
                else if (indicators.whales.status === 'ACTIVE') score += 4;
                
                if (indicators.whales.sentiment === 'STRONG BULLISH') score += 6;
                else if (indicators.whales.sentiment === 'STRONG BEARISH') score -= 6;
            }
            
            // Market Makers (Wyckoff) etkisi
            if (indicators.marketMakers) {
                if (indicators.marketMakers.wyckoff.phase === 'ACCUMULATION') score += 8;
                else if (indicators.marketMakers.wyckoff.phase.includes('ACCUMULATION')) score += 5;
                else if (indicators.marketMakers.wyckoff.phase === 'DISTRIBUTION') score -= 8;
                else if (indicators.marketMakers.wyckoff.phase.includes('DISTRIBUTION')) score -= 5;
                
                if (indicators.marketMakers.vsa === 'STRONG BULLISH') score += 5;
                else if (indicators.marketMakers.vsa === 'STRONG ABSORPTION') score += 4;
                
                if (indicators.marketMakers.cvd.trend === 'STRONG BULLISH') score += 4;
                else if (indicators.marketMakers.cvd.trend === 'STRONG BEARISH') score -= 4;
            }
            
            // Smart Money Concepts etkisi
            if (indicators.smartMoneyConcepts) {
                if (indicators.smartMoneyConcepts.bos.includes('STRONG BULLISH')) score += 5;
                else if (indicators.smartMoneyConcepts.bos.includes('BULLISH')) score += 3;
                else if (indicators.smartMoneyConcepts.bos.includes('STRONG BEARISH')) score -= 5;
                else if (indicators.smartMoneyConcepts.bos.includes('BEARISH')) score -= 3;
                
                if (indicators.smartMoneyConcepts.zone === 'DISCOUNT') score += 5;
                else if (indicators.smartMoneyConcepts.zone === 'PREMIUM') score -= 3;
            }
            
            // Pump & Dump etkisi
            if (indicators.pumpDump) {
                if (indicators.pumpDump.strength > 90) score += 10;
                else if (indicators.pumpDump.strength > 70) score += 5;
                else if (indicators.pumpDump.strength < 10) score -= 10;
            }
            
            // Trend Break etkisi
            if (indicators.trendBreak) {
                if (indicators.trendBreak.signal.includes('BULLISH BREAKOUT')) score += 8;
                else if (indicators.trendBreak.signal.includes('BULLISH BREAK')) score += 5;
                else if (indicators.trendBreak.signal.includes('BEARISH BREAKDOWN')) score -= 8;
                else if (indicators.trendBreak.signal.includes('BEARISH BREAK')) score -= 5;
            }
            
            // Peaks & Dips etkisi
            if (indicators.peaksAndDips) {
                if (indicators.peaksAndDips.confidence > 80) {
                    if (indicators.peaksAndDips.signal.includes('BUY')) score += 6;
                    else if (indicators.peaksAndDips.signal.includes('SELL') || indicators.peaksAndDips.signal.includes('PEAK')) score -= 6;
                }
            }
            
            // Trader analiz etkisi
            if (indicators.traders) {
                if (indicators.traders.dominance === 'INSTITUTIONAL' && indicators.traders.sentiment === 'STRONG BULLISH') score += 4;
                else if (indicators.traders.dominance === 'RETAIL' && indicators.traders.sentiment === 'STRONG BEARISH') score -= 4;
            }
            
            // 24h değişim etkisi
            if (priceData.change > 5) {
                score += 5;
            } else if (priceData.change < -5) {
                score -= 5;
            }
            
            // Skor sınırlaması
            score = Math.max(0, Math.min(100, score));
            
            return Math.round(score);
        }
        
        // ===== GERÇEK SİNYAL BELİRLEME =====
        function determineRealSignal(coin, priceData, score) {
            const indicators = technicalIndicators[coin];
            
            if (!indicators) {
                // Balanced threshold - short sinyaller için daha düşük eşik
                if (score > 65) return 'long';
                else if (score < 35) return 'short';
                else return 'wait';
            }
            
            let bullishSignals = 0;
            let bearishSignals = 0;
            
            // İndikatör skorlarından sinyal sayısı
            if (indicators.indicators90) {
                const bullCount = indicators.indicators90.bull || 0;
                const bearCount = indicators.indicators90.bear || 0;
                
                bullishSignals += bullCount;
                bearishSignals += bearCount;
                
                // Bear sinyalleri daha fazlaysa short ver
                if (bearCount > bullCount + 5) {
                    return 'short';
                } else if (bullCount > bearCount + 5) {
                    return 'long';
                }
            }
            
            // RSI sinyalleri
            if (indicators.rsi < 30) bullishSignals += 2;
            else if (indicators.rsi > 70) bearishSignals += 2;
            else if (indicators.rsi < 50 && indicators.rsi > 30) bullishSignals += 1;
            else if (indicators.rsi > 50 && indicators.rsi < 70) bearishSignals += 1;
            
            // MACD sinyalleri
            if (indicators.macd > indicators.macdSignal && indicators.macdHistogram > 0) bullishSignals += 2;
            else if (indicators.macd < indicators.macdSignal && indicators.macdHistogram < 0) bearishSignals += 2;
            
            // Trend sinyalleri
            if (indicators.trend === 'UP' && indicators.ema9 > indicators.ema21) bullishSignals += 2;
            else if (indicators.trend === 'DOWN' && indicators.ema9 < indicators.ema21) bearishSignals += 2;
            
            // Volume sinyalleri
            if (indicators.volumeRatio > 1.5) {
                if (priceData.change > 0) bullishSignals += 1;
                else bearishSignals += 1;
            }
            
            // === YENİ: GELİŞMİŞ TEKNİKLER SİNYAL ETKİSİ ===
            
            // Order Flow Delta sinyalleri
            if (indicators.orderFlowDelta) {
                if (indicators.orderFlowDelta.trend === 'STRONG BULLISH') bullishSignals += 3;
                else if (indicators.orderFlowDelta.trend === 'STRONG BEARISH') bearishSignals += 3;
                const imbalance = parseFloat(indicators.orderFlowDelta.imbalance);
                if (imbalance > 15) bullishSignals += 2;
                else if (imbalance < -15) bearishSignals += 2;
            }
            
            // Premium/Discount Zones sinyalleri
            if (indicators.premiumDiscount) {
                if (indicators.premiumDiscount.currentZone === 'DISCOUNT') bullishSignals += 2;
                else if (indicators.premiumDiscount.currentZone === 'PREMIUM') bearishSignals += 2;
            }
            
            // Liquidity Sweeps sinyalleri
            if (indicators.liquiditySweeps && indicators.liquiditySweeps.length > 0) {
                const bullishSweeps = indicators.liquiditySweeps.filter(s => s.type === 'BULLISH_SWEEP').length;
                const bearishSweeps = indicators.liquiditySweeps.filter(s => s.type === 'BEARISH_SWEEP').length;
                if (bullishSweeps > bearishSweeps) bullishSignals += 2;
                else if (bearishSweeps > bullishSweeps) bearishSignals += 2;
            }
            
            // Multi-Timeframe Confluence sinyalleri
            if (indicators.multiTimeframe) {
                if (indicators.multiTimeframe.confluence.includes('STRONG_BULLISH')) bullishSignals += 4;
                else if (indicators.multiTimeframe.confluence.includes('BULLISH')) bullishSignals += 2;
                else if (indicators.multiTimeframe.confluence.includes('STRONG_BEARISH')) bearishSignals += 4;
                else if (indicators.multiTimeframe.confluence.includes('BEARISH')) bearishSignals += 2;
            }
            
            // Advanced Volume Profile sinyalleri
            if (indicators.advancedVolumeProfile) {
                const positionInVA = parseFloat(indicators.advancedVolumeProfile.positionInVA);
                if (positionInVA < 20) bullishSignals += 2; // Birikim bölgesi
                else if (positionInVA > 80) bearishSignals += 2; // Dağıtım bölgesi
            }
            
            // Skor bazlı - Balanced (short için daha düşük eşik)
            if (score >= 65) bullishSignals += 2;
            else if (score <= 35) bearishSignals += 3; // Short için daha güçlü ağırlık
            else if (score < 50) bearishSignals += 1; // Orta-az skor = bearish eğilim
            
            // Darvas Box, Squeeze, Market Profile gibi özel indikatörler
            if (indicators.indicators90) {
                // Darvas Box breakdown
                const dbIndex = indicators.indicators90.indicatorDetails?.short?.findIndex(s => s.includes('Darvas'));
                if (dbIndex !== undefined && dbIndex >= 0) bearishSignals += 2;
                
                // Squeeze negative momentum
                const sqIndex = indicators.indicators90.indicatorDetails?.short?.findIndex(s => s.includes('Squeeze'));
                if (sqIndex !== undefined && sqIndex >= 0) bearishSignals += 1;
                
                // Market Profile below value area
                const mpIndex = indicators.indicators90.indicatorDetails?.short?.findIndex(s => s.includes('Market Profile'));
                if (mpIndex !== undefined && mpIndex >= 0) bearishSignals += 2;
            }
            
            // Balanced decision - bear sinyallerini daha fazla değerlendir
            if (bullishSignals > bearishSignals + 3) return 'long';
            if (bearishSignals > bullishSignals + 2) return 'short'; // Bear için daha düşük eşik
            if (bearishSignals > bullishSignals) return 'short'; // Eşitlik durumunda bear'a ver
            return 'wait';
        }
        
        async function generateResults() {
            const coins = Object.keys(realPrices);
            
            // LONG ve SHORT için ayrı container'lar
            const longContainer = document.getElementById('longResultsContainer');
            const shortContainer = document.getElementById('shortResultsContainer');
            const waitContainer = document.getElementById('waitResultsContainer');
            
            // Container'ları temizle
            if (longContainer) longContainer.innerHTML = '';
            if (shortContainer) shortContainer.innerHTML = '';
            if (waitContainer) waitContainer.innerHTML = '';
            
            // Önce teknik analizlerin hesaplanmasını bekle (eğer yoksa hızlıca hesapla)
            if (Object.keys(technicalIndicators).length === 0) {
                console.log('⚡ Teknik analizler eksik, hızlı hesaplama yapılıyor...');
                await calculateTechnicalIndicators();
            }
            
            let bullish = 0, bearish = 0, neutral = 0;
            
            // Filtreleme - sadece skoru yüksek olanları işle (performans için)
            const filteredCoins = coins.filter(coin => {
                const priceData = realPrices[coin];
                if (!priceData) return false;
                const score = calculateRealScore(coin, priceData);
                return score >= minScore || score > 50; // Minimum skor veya 50'den yüksek
            });
            
            console.log(`📊 ${filteredCoins.length}/${coins.length} coin filtrelendi (min skor: ${minScore})`);
            
            // LONG ve SHORT sonuçları için ayrı listeler
            const longResults = [];
            const shortResults = [];
            const waitResults = [];
            
            // PARALEL İŞLEME - 20'şer 20'şer batch (ÇOK DAHA HIZLI!)
            const batchSize = 20;
            
            for (let i = 0; i < filteredCoins.length; i += batchSize) {
                const batch = filteredCoins.slice(i, i + batchSize);
                
                // Batch içinde paralel işle
                const batchPromises = batch.map(coin => {
                    return new Promise((resolve) => {
                        try {
                            const priceData = realPrices[coin];
                            if (!priceData) {
                                resolve(null);
                                return;
                            }
                            
                            const score = calculateRealScore(coin, priceData);
                            const signal = determineRealSignal(coin, priceData, score);
                            
                            // Sinyal sayısını hesapla (async dışında)
                            let signalType = 'neutral';
                            if (signal === 'long') signalType = 'long';
                            else if (signal === 'short') signalType = 'short';
                            else signalType = 'neutral';
                            
                            if (score >= minScore || signal !== 'wait') {
                                const card = createCompleteResultCard(coin, priceData, score, signal);
                                resolve({ card, score, signal: signalType, coin });
                            } else {
                                resolve(null);
                            }
                        } catch (e) {
                            console.error(`Coin işleme hatası ${coin}:`, e);
                            resolve(null);
                        }
                    });
                });
                
                const batchResults = await Promise.all(batchPromises);
                
                // Sonuçları skora göre sıralayıp kategorilere ayır
                const validCards = batchResults.filter(r => r !== null);
                validCards.sort((a, b) => b.score - a.score);
                
                // LONG ve SHORT'a ayır
                validCards.forEach(result => {
                    if (result.signal === 'long') {
                        bullish++;
                        longResults.push(result);
                    } else if (result.signal === 'short') {
                        bearish++;
                        shortResults.push(result);
                    } else {
                        neutral++;
                        waitResults.push(result);
                    }
                });
                
                // Progress göster
                const progress = Math.min(100, ((i + batch.length) / filteredCoins.length) * 100);
                const loadingEl = document.getElementById('loadingSection');
                if (loadingEl) {
                    const progressEl = loadingEl.querySelector('.progress-bar');
                    if (progressEl) {
                        progressEl.style.width = progress + '%';
                        progressEl.textContent = Math.round(progress) + '%';
                    }
                }
                
                // Kısa bir bekleme - UI'nin güncellenmesi için
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            // LONG sonuçlarını ekle (skora göre sıralı)
            longResults.sort((a, b) => b.score - a.score);
            longResults.forEach(result => {
                if (longContainer) longContainer.appendChild(result.card);
            });

            // SHORT sonuçlarını ekle (skora göre sıralı)
            shortResults.sort((a, b) => b.score - a.score);
            shortResults.forEach(result => {
                if (shortContainer) shortContainer.appendChild(result.card);
            });

            // WAIT sonuçlarını ekle (varsa)
            if (waitResults.length > 0 && waitContainer) {
                document.getElementById('waitSection').style.display = 'block';
                waitResults.sort((a, b) => b.score - a.score);
                waitResults.forEach(result => {
                    waitContainer.appendChild(result.card);
                });
                document.getElementById('waitCount').textContent = `${waitResults.length} Coin`;
            }

            // İstatistikleri güncelle
            document.getElementById('totalCoins').textContent = coins.length;
            document.getElementById('bullishSignals').textContent = bullish;
            document.getElementById('bearishSignals').textContent = bearish;
            document.getElementById('neutralSignals').textContent = neutral;
            
            // LONG ve SHORT sayılarını göster
            if (document.getElementById('longCount')) {
                document.getElementById('longCount').textContent = `${bullish} Coin`;
            }
            if (document.getElementById('shortCount')) {
                document.getElementById('shortCount').textContent = `${bearish} Coin`;
            }
            
            console.log(`✅ Tarama tamamlandı: ${bullish} LONG, ${bearish} SHORT, ${neutral} WAIT`);
        }

        function createCompleteResultCard(coin, priceData, score, signal) {
            const card = document.createElement('div');
            card.className = 'result-card';
            
            const signalClass = signal === 'long' ? 'signal-long' : signal === 'short' ? 'signal-short' : 'signal-neutral';
            const signalText = signal === 'long' ? '🟢 LONG' : signal === 'short' ? '🔴 SHORT' : '⚪ WAIT';
            
            const entry = priceData.price;
            
            // Gerçek teknik analiz verilerinden sinyalleri oluştur
            const indicators = technicalIndicators[coin] || {};
            
            // ATR'yi gerçek hesaplamadan al
            let atr = entry * 0.02; // Varsayılan %2
            if (indicators.atr) {
                if (Array.isArray(indicators.atr) && indicators.atr.length > 0) {
                    atr = indicators.atr[indicators.atr.length - 1];
                } else if (typeof indicators.atr === 'number') {
                    atr = indicators.atr;
                }
            }
            
            // ATR çok küçük veya çok büyükse mantıklı bir değere ayarla
            if (atr < entry * 0.005) atr = entry * 0.01; // Minimum %1
            if (atr > entry * 0.1) atr = entry * 0.05;   // Maximum %5
            
            // Trade seviyelerini gerçek ATR ile hesapla
            const sl = signal === 'long' ? entry - (1.5*atr) : entry + (1.5*atr);
            const tp1 = signal === 'long' ? entry + (atr * 1.0) : entry - (atr * 1.0);
            const tp2 = signal === 'long' ? entry + (atr * 2.0) : entry - (atr * 2.0);
            const tp3 = signal === 'long' ? entry + (atr * 3.0) : entry - (atr * 3.0);
            const buyIndicators = [];
            const sellIndicators = [];
            const neutralIndicators = [];
            
            if (indicators.rsi) {
                if (indicators.rsi < 30) {
                    buyIndicators.push(`RSI ${indicators.rsi.toFixed(1)} (Oversold)`);
                } else if (indicators.rsi > 70) {
                    sellIndicators.push(`RSI ${indicators.rsi.toFixed(1)} (Overbought)`);
                } else {
                    neutralIndicators.push(`RSI ${indicators.rsi.toFixed(1)} (Neutral)`);
                }
            }
            
            if (indicators.macd !== undefined && indicators.macdSignal !== undefined) {
                if (indicators.macd > indicators.macdSignal && indicators.macdHistogram > 0) {
                    buyIndicators.push(`MACD > Signal (Bullish)`);
                } else if (indicators.macd < indicators.macdSignal && indicators.macdHistogram < 0) {
                    sellIndicators.push(`MACD < Signal (Bearish)`);
                } else {
                    neutralIndicators.push(`MACD Neutral`);
                }
            }
            
            if (indicators.trend) {
                if (indicators.trend === 'UP' && indicators.ema9 > indicators.ema21) {
                    buyIndicators.push(`EMA Trend UP (9>21)`);
                } else if (indicators.trend === 'DOWN' && indicators.ema9 < indicators.ema21) {
                    sellIndicators.push(`EMA Trend DOWN (9<21)`);
                }
            }
            
            if (indicators.volumeRatio) {
                if (indicators.volumeRatio > 1.5) {
                    buyIndicators.push(`Volume ${indicators.volumeRatio.toFixed(1)}x (High)`);
                } else if (indicators.volumeRatio < 0.5) {
                    neutralIndicators.push(`Volume ${indicators.volumeRatio.toFixed(1)}x (Low)`);
                }
            }
            
            if (indicators.bbUpper && indicators.bbLower) {
                if (priceData.price < indicators.bbLower) {
                    buyIndicators.push(`Price < BB Lower (Oversold)`);
                } else if (priceData.price > indicators.bbUpper) {
                    sellIndicators.push(`Price > BB Upper (Overbought)`);
                } else {
                    neutralIndicators.push(`Price in BB Range`);
                }
            }
            
            // Varsayılan değerler (eğer teknik analiz yoksa)
            if (buyIndicators.length === 0 && sellIndicators.length === 0 && neutralIndicators.length === 0) {
                buyIndicators.push('EMA 9/21 Cross ↑', 'Volume Spike');
                sellIndicators.push('RSI > 70 Overbought');
                neutralIndicators.push('Waiting for signals');
            }
            
            // Card'a tıklama eventi ekle
            card.addEventListener('click', () => {
                showCoinDetailModal(coin, priceData, score, signal, indicators);
            });
            
            // Fiyat ve değişimi sayıya dönüştür
            const cardPrice = typeof priceData.price === 'string' ? parseFloat(priceData.price) : Number(priceData.price || 0);
            const cardChange = typeof priceData.change === 'string' ? parseFloat(priceData.change) : Number(priceData.change || 0);
            
            // Stop loss hesapla (sl zaten hesaplanmış)
            const cardStopLoss = sl;
            
            card.innerHTML = `
                <div class="coin-header">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; width: 100%;">
                        <div>
                            <div class="coin-name">${coin}</div>
                            ${signal !== 'wait' ? `
                                <button onclick="event.stopPropagation(); copyTradeFormat('${coin}', '${signal}', ${cardPrice}, ${cardStopLoss}, ${tp1}, ${tp2}, ${tp3});" 
                                        style="margin-top: 8px; padding: 6px 12px; background: rgba(78, 205, 196, 0.2); border: 1px solid rgba(78, 205, 196, 0.5); border-radius: 6px; color: #4ecdc4; cursor: pointer; font-size: 0.75em; font-weight: bold; transition: all 0.3s;"
                                        onmouseover="this.style.background='rgba(78, 205, 196, 0.3)'; this.style.transform='scale(1.05)'"
                                        onmouseout="this.style.background='rgba(78, 205, 196, 0.2)'; this.style.transform='scale(1)'"
                                        title="Trade formatını kopyala">
                                    📋 Trade Kopyala
                                </button>
                            ` : ''}
                        </div>
                        <div style="text-align: right;">
                            <div class="coin-price">$${formatPrice(cardPrice)}</div>
                            <div class="price-change ${cardChange >= 0 ? 'price-up' : 'price-down'}">
                                ${cardChange >= 0 ? '▲' : '▼'} ${Math.abs(cardChange).toFixed(2)}%
                            </div>
                            <div style="font-size: 0.75em; color: #aaa; margin-top: 5px;">👆 Detaylar için tıklayın</div>
                        </div>
                    </div>
                </div>

                <div class="master-signal ${signalClass}">
                    <div class="signal-title">${signalText}</div>
                    <div style="font-size: 1.3em; margin-top: 10px;">Master Score: ${score}/100</div>
                    <div style="font-size: 0.9em; opacity: 0.8; margin-top: 5px;">💡 AI analizi için butona tıklayın</div>
                </div>

                <div class="trade-setup">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div class="setup-title">📋 Trade Setup</div>
                        ${signal !== 'wait' ? `
                            <button onclick="event.stopPropagation(); copyTradeFormat('${coin}', '${signal}', ${cardPrice}, ${cardStopLoss}, ${tp1}, ${tp2}, ${tp3});" 
                                    style="padding: 5px 10px; background: rgba(78, 205, 196, 0.2); border: 1px solid rgba(78, 205, 196, 0.5); border-radius: 5px; color: #4ecdc4; cursor: pointer; font-size: 0.75em; font-weight: bold;"
                                    title="Trade formatını kopyala">
                                📋 Kopyala
                            </button>
                        ` : ''}
                    </div>
                    <div class="setup-grid">
                        <div class="setup-item"><div class="setup-label">Entry</div><div class="setup-value value-neutral">$${formatPrice(entry)}</div></div>
                        <div class="setup-item"><div class="setup-label">Stop Loss</div><div class="setup-value value-short">$${formatPrice(sl)}</div></div>
                        <div class="setup-item"><div class="setup-label">TP1</div><div class="setup-value value-long">$${formatPrice(tp1)}</div></div>
                        <div class="setup-item"><div class="setup-label">TP2</div><div class="setup-value value-long">$${formatPrice(tp2)}</div></div>
                        <div class="setup-item"><div class="setup-label">TP3</div><div class="setup-value value-long">$${formatPrice(tp3)}</div></div>
                        <div class="setup-item"><div class="setup-label">R:R Ratio</div><div class="setup-value value-neutral">1:2.5</div></div>
                    </div>
                    ${signal !== 'wait' ? `
                        <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; border: 1px dashed rgba(78, 205, 196, 0.3); font-size: 0.85em;">
                            <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">📋 Trade Formatı:</div>
                            <div style="font-family: 'Courier New', monospace; color: #fff; user-select: all; cursor: text; line-height: 1.6;">
${coin.toLowerCase()}
${signal === 'long' ? `buy ${cardPrice.toFixed(2)}` : `sell ${cardPrice.toFixed(2)}`}
stop ${cardStopLoss.toFixed(2)}
tp1 ${tp1.toFixed(2)}
tp2 ${tp2.toFixed(2)}
tp3 ${tp3.toFixed(2)}
                            </div>
                        </div>
                    ` : ''}
                </div>

                <div class="trade-setup">
                    <div class="setup-title">📈 CVD & Smart Money</div>
                    <div class="setup-grid">
                        <div class="setup-item">
                            <div class="setup-label">CVD Trend</div>
                            <div class="setup-value ${indicators.cvdTrend === 'BULLISH' ? 'value-long' : indicators.cvdTrend === 'BEARISH' ? 'value-short' : 'value-neutral'}">
                                ${indicators.cvdTrend === 'BULLISH' ? '📈 Bullish' : indicators.cvdTrend === 'BEARISH' ? '📉 Bearish' : '➡️ Neutral'}
                            </div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">CVD Value</div>
                            <div class="setup-value value-neutral">${indicators.cvd ? indicators.cvd.toFixed(0) : 'N/A'}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">Order Blocks</div>
                            <div class="setup-value value-neutral">${indicators.orderBlocks || 0}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">Fair Value Gaps</div>
                            <div class="setup-value value-neutral">${indicators.fvg || 0}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">VWAP</div>
                            <div class="setup-value value-neutral">$${indicators.vwap ? formatPrice(indicators.vwap) : 'N/A'}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">ATR</div>
                            <div class="setup-value value-neutral">${indicators.atr ? indicators.atr.toFixed(2) : 'N/A'}</div>
                        </div>
                    </div>
                </div>

                <div class="trade-setup">
                    <div class="setup-title">📊 Gelişmiş İndikatörler</div>
                    <div class="setup-grid">
                        <div class="setup-item">
                            <div class="setup-label">Stochastic %K</div>
                            <div class="setup-value ${indicators.stochastic > 80 ? 'value-short' : indicators.stochastic < 20 ? 'value-long' : 'value-neutral'}">
                                ${indicators.stochastic ? indicators.stochastic.toFixed(2) : 'N/A'}
                            </div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">Stochastic %D</div>
                            <div class="setup-value value-neutral">${indicators.stochasticD ? indicators.stochasticD.toFixed(2) : 'N/A'}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">ADX</div>
                            <div class="setup-value ${indicators.adx > 25 ? 'value-long' : 'value-neutral'}">
                                ${indicators.adx ? indicators.adx.toFixed(2) : 'N/A'} ${indicators.adx > 25 ? '(Strong)' : indicators.adx > 20 ? '(Moderate)' : '(Weak)'}
                            </div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">EMA 9</div>
                            <div class="setup-value value-neutral">$${indicators.ema9 ? formatPrice(indicators.ema9) : 'N/A'}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">EMA 21</div>
                            <div class="setup-value value-neutral">$${indicators.ema21 ? formatPrice(indicators.ema21) : 'N/A'}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">EMA 50</div>
                            <div class="setup-value value-neutral">$${indicators.ema50 ? formatPrice(indicators.ema50) : 'N/A'}</div>
                        </div>
                    </div>
                </div>

                <div class="indicator-signals">
                    <div class="setup-title">📊 İndikatör Sinyalleri</div>
                    <div class="signals-grid">
                        <div class="signal-column signal-buy">
                            <h4>🟢 AL (${buyIndicators.length})</h4>
                            <ul class="signal-list">
                                ${buyIndicators.map(ind => `<li>✅ ${ind}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="signal-column signal-sell">
                            <h4>🔴 SAT (${sellIndicators.length})</h4>
                            <ul class="signal-list">
                                ${sellIndicators.map(ind => `<li>❌ ${ind}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="signal-column signal-wait">
                            <h4>⚪ Kararsız (${neutralIndicators.length})</h4>
                            <ul class="signal-list">
                                ${neutralIndicators.map(ind => `<li>⚪ ${ind}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                </div>

                ${generateLiquidationHTML(coin, priceData.price)}

                ${indicators.institutional ? `
                <div class="trade-setup" style="margin-top: 20px; background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(44, 160, 141, 0.1)); border: 2px solid rgba(78, 205, 196, 0.5);">
                    <div class="setup-title" style="font-size: 1.4em; color: #4ecdc4; margin-bottom: 20px;">
                        🏢 KURUMSAL ANALİZ - Detaylı İnstitutional Flow
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #4ecdc4; font-weight: bold;">🌊 Dark Pool Aktivitesi</span>
                            <span style="color: ${indicators.institutional.darkPool === 'VERY HIGH' ? '#4ecdc4' : indicators.institutional.darkPool === 'HIGH' ? '#ffd700' : indicators.institutional.darkPool === 'MEDIUM' ? '#ff9500' : '#aaa'}; font-weight: bold; font-size: 1.1em;">
                                ${indicators.institutional.darkPool || 'N/A'}
                            </span>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden; height: 12px;">
                            <div style="height: 100%; background: linear-gradient(90deg, ${indicators.institutional.darkPool === 'VERY HIGH' ? '#4ecdc4' : indicators.institutional.darkPool === 'HIGH' ? '#ffd700' : indicators.institutional.darkPool === 'MEDIUM' ? '#ff9500' : '#666'}, ${indicators.institutional.darkPool === 'VERY HIGH' ? '#2a9d8f' : indicators.institutional.darkPool === 'HIGH' ? '#ffaa00' : indicators.institutional.darkPool === 'MEDIUM' ? '#cc7700' : '#444'}); width: ${indicators.institutional.darkPool === 'VERY HIGH' ? '90' : indicators.institutional.darkPool === 'HIGH' ? '70' : indicators.institutional.darkPool === 'MEDIUM' ? '50' : '20'}%; transition: width 0.5s;"></div>
                        </div>
                        <div style="font-size: 0.75em; color: #aaa; margin-top: 5px;">Block Trade Sayısı: ${indicators.institutional.blockTrades || 0} | ${indicators.institutional.blockTrades > 5 ? 'Kritik seviye' : indicators.institutional.blockTrades > 3 ? 'Yüksek aktivite' : indicators.institutional.blockTrades > 1 ? 'Normal' : 'Düşük'}</div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #4ecdc4; font-weight: bold;">📈 Order Flow Analizi</span>
                            <span style="color: ${indicators.institutional.orderFlow?.includes('STRONG BUY') ? '#4ecdc4' : indicators.institutional.orderFlow?.includes('BUY') ? '#44a08d' : indicators.institutional.orderFlow?.includes('STRONG SELL') ? '#ff6b6b' : indicators.institutional.orderFlow?.includes('SELL') ? '#e74c3c' : '#aaa'}; font-weight: bold; font-size: 1.1em;">
                                ${indicators.institutional.orderFlow || 'N/A'}
                            </span>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                            <div style="background: rgba(78, 205, 196, 0.15); border: 1px solid rgba(78, 205, 196, 0.5); padding: 12px; border-radius: 8px;">
                                <div style="color: #4ecdc4; font-size: 0.85em; margin-bottom: 5px;">🟢 Buy Pressure</div>
                                <div style="color: #4ecdc4; font-size: 1.3em; font-weight: bold;">${indicators.institutional.buyPressure || '0'}</div>
                            </div>
                            <div style="background: rgba(255, 107, 107, 0.15); border: 1px solid rgba(255, 107, 107, 0.5); padding: 12px; border-radius: 8px;">
                                <div style="color: #ff6b6b; font-size: 0.85em; margin-bottom: 5px;">🔴 Sell Pressure</div>
                                <div style="color: #ff6b6b; font-size: 1.3em; font-weight: bold;">${indicators.institutional.sellPressure || '0'}</div>
                            </div>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden; height: 12px; margin-top: 10px;">
                            <div style="height: 100%; background: linear-gradient(90deg, #4ecdc4, #2a9d8f); width: ${indicators.institutional.ratio || 50}%; display: flex; align-items: center; justify-content: center; color: #000; font-weight: bold; font-size: 0.7em;">BUY ${indicators.institutional.ratio || '50'}%</div>
                        </div>
                    </div>

                    <div style="background: rgba(78, 205, 196, 0.1); border-left: 4px solid #4ecdc4; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 8px;">💡 Analiz Özeti</div>
                        <div style="color: #ddd; font-size: 0.9em; line-height: 1.6;">
                            ${indicators.institutional.darkPool === 'VERY HIGH' ? '⚡ <strong>Kritik:</strong> Çok yüksek dark pool aktivitesi tespit edildi. Büyük kurumsal oyuncular aktif.' : ''}
                            ${indicators.institutional.orderFlow?.includes('STRONG BUY') ? '📈 <strong>Güçlü Alım:</strong> Kurumsal alım baskısı çok yüksek. Yükseliş sinyali güçlü.' : indicators.institutional.orderFlow?.includes('STRONG SELL') ? '📉 <strong>Güçlü Satış:</strong> Kurumsal satış baskısı yüksek. Dikkatli olunmalı.' : ''}
                            ${indicators.institutional.blockTrades > 5 ? '🎯 <strong>Block Trade Uyarısı:</strong> Son 24 saatte kritik seviyede büyük işlem tespit edildi.' : ''}
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators.whales ? `
                <div class="trade-setup" style="margin-top: 20px; background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 165, 0, 0.1)); border: 2px solid rgba(255, 215, 0, 0.5);">
                    <div class="setup-title" style="font-size: 1.4em; color: #ffd700; margin-bottom: 20px;">
                        🐋 WHALE ANALİZİ - Büyük Oyuncu Takibi
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #ffd700; font-weight: bold;">🐋 Whale Aktivite Durumu</span>
                            <span style="color: ${indicators.whales.status === 'VERY ACTIVE' ? '#4ecdc4' : indicators.whales.status === 'ACTIVE' ? '#ffd700' : indicators.whales.status === 'MODERATE' ? '#ff9500' : '#aaa'}; font-weight: bold; font-size: 1.1em;">
                                ${indicators.whales.status || 'N/A'}
                            </span>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden; height: 12px;">
                            <div style="height: 100%; background: linear-gradient(90deg, ${indicators.whales.status === 'VERY ACTIVE' ? '#4ecdc4' : indicators.whales.status === 'ACTIVE' ? '#ffd700' : indicators.whales.status === 'MODERATE' ? '#ff9500' : '#666'}, ${indicators.whales.status === 'VERY ACTIVE' ? '#2a9d8f' : indicators.whales.status === 'ACTIVE' ? '#ffaa00' : indicators.whales.status === 'MODERATE' ? '#cc7700' : '#444'}); width: ${indicators.whales.status === 'VERY ACTIVE' ? '90' : indicators.whales.status === 'ACTIVE' ? '70' : indicators.whales.status === 'MODERATE' ? '50' : '20'}%;"></div>
                        </div>
                        <div style="font-size: 0.75em; color: #aaa; margin-top: 5px;">Toplam Orders: ${indicators.whales.orders || 0} | Son 10 Candle: ${indicators.whales.recentOrders || 0} | Buys/Sells: ${indicators.whales.buys || 0}/${indicators.whales.sells || 0}</div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #ffd700; font-weight: bold;">📊 Whale Sentiment & Flow</span>
                            <span style="color: ${indicators.whales.sentiment?.includes('BULLISH') ? '#4ecdc4' : indicators.whales.sentiment?.includes('BEARISH') ? '#ff6b6b' : '#aaa'}; font-weight: bold; font-size: 1.1em;">
                                ${indicators.whales.sentiment || 'N/A'}
                            </span>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                            <div style="background: rgba(78, 205, 196, 0.15); border: 1px solid rgba(78, 205, 196, 0.5); padding: 12px; border-radius: 8px;">
                                <div style="color: #4ecdc4; font-size: 0.85em; margin-bottom: 5px;">📈 Accumulation</div>
                                <div style="color: #4ecdc4; font-size: 1.3em; font-weight: bold;">${indicators.whales.accumulation || '0'}%</div>
                                <div style="background: rgba(0,0,0,0.3); border-radius: 5px; overflow: hidden; height: 8px; margin-top: 8px;">
                                    <div style="height: 100%; background: linear-gradient(90deg, #4ecdc4, #2a9d8f); width: ${indicators.whales.accumulation || 0}%;"></div>
                                </div>
                            </div>
                            <div style="background: rgba(255, 107, 107, 0.15); border: 1px solid rgba(255, 107, 107, 0.5); padding: 12px; border-radius: 8px;">
                                <div style="color: #ff6b6b; font-size: 0.85em; margin-bottom: 5px;">📉 Distribution</div>
                                <div style="color: #ff6b6b; font-size: 1.3em; font-weight: bold;">${indicators.whales.distribution || '0'}%</div>
                                <div style="background: rgba(0,0,0,0.3); border-radius: 5px; overflow: hidden; height: 8px; margin-top: 8px;">
                                    <div style="height: 100%; background: linear-gradient(90deg, #ff6b6b, #e74c3c); width: ${indicators.whales.distribution || 0}%;"></div>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(255, 215, 0, 0.1); border-radius: 8px; border-left: 3px solid #ffd700;">
                            <div style="color: #ffd700; font-size: 0.85em; font-weight: bold;">Net Flow: ${parseFloat(indicators.whales.accumulation || 0) > parseFloat(indicators.whales.distribution || 0) ? '+' : ''}${((parseFloat(indicators.whales.accumulation || 0) - parseFloat(indicators.whales.distribution || 0)).toFixed(1))}%</div>
                            <div style="color: #ddd; font-size: 0.75em; margin-top: 3px;">Toplam Net Volume Flow: ${indicators.whales.netFlow || '0'}</div>
                        </div>
                    </div>

                    <div style="background: rgba(255, 215, 0, 0.1); border-left: 4px solid #ffd700; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <div style="color: #ffd700; font-weight: bold; margin-bottom: 8px;">💡 Whale Analiz Özeti</div>
                        <div style="color: #ddd; font-size: 0.9em; line-height: 1.6;">
                            ${indicators.whales.status === 'VERY ACTIVE' ? '⚡ <strong>Kritik Aktivite:</strong> Whaleler çok aktif. Büyük hareketler beklenebilir.' : ''}
                            ${indicators.whales.sentiment?.includes('STRONG BULLISH') ? '📈 <strong>Güçlü Yükseliş:</strong> Whale sentiment çok bullish. Accumulation devam ediyor.' : indicators.whales.sentiment?.includes('STRONG BEARISH') ? '📉 <strong>Güçlü Düşüş:</strong> Whale sentiment bearish. Distribution riski yüksek.' : ''}
                            ${parseFloat(indicators.whales.accumulation || 0) > 60 ? '🎯 <strong>Yüksek Accumulation:</strong> Whaleler topluyor. Yükseliş potansiyeli yüksek.' : ''}
                            ${parseFloat(indicators.whales.distribution || 0) > 60 ? '⚠️ <strong>Yüksek Distribution:</strong> Whaleler dağıtıyor. Düşüş riski var.' : ''}
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators.marketMakers ? `
                <div class="trade-setup" style="margin-top: 20px; background: linear-gradient(135deg, rgba(255, 149, 0, 0.1), rgba(255, 107, 107, 0.1)); border: 2px solid rgba(255, 149, 0, 0.5);">
                    <div class="setup-title" style="font-size: 1.4em; color: #ff9500; margin-bottom: 20px;">
                        🎯 PİYASA YAPICILARI - Wyckoff & VSA Analizi
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <span style="color: #ff9500; font-weight: bold;">📊 Wyckoff Fazı Analizi</span>
                            <span style="color: ${indicators.marketMakers.wyckoff?.phase?.includes('ACCUMULATION') ? '#4ecdc4' : indicators.marketMakers.wyckoff?.phase?.includes('MARKUP') ? '#ffd700' : indicators.marketMakers.wyckoff?.phase?.includes('DISTRIBUTION') ? '#ff6b6b' : '#aaa'}; font-weight: bold; font-size: 1.2em;">
                                ${indicators.marketMakers.wyckoff?.phase || 'N/A'}
                            </span>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #aaa; font-size: 0.85em;">Pozisyon</span>
                                <span style="color: #ffd700; font-weight: bold;">${indicators.marketMakers.wyckoff?.position || 'N/A'}%</span>
                            </div>
                            <div style="background: rgba(255, 149, 0, 0.2); border-radius: 10px; overflow: hidden; height: 16px; position: relative;">
                                <div style="position: absolute; left: ${indicators.marketMakers.wyckoff?.position || 50}%; top: 0; bottom: 0; width: 2px; background: #ffd700; z-index: 2;"></div>
                                <div style="height: 100%; display: flex; align-items: center; padding: 0 5px; color: #fff; font-size: 0.7em; font-weight: bold;">
                                    <div style="flex: 1; text-align: center; color: ${parseFloat(indicators.marketMakers.wyckoff?.position || 50) < 25 ? '#4ecdc4' : parseFloat(indicators.marketMakers.wyckoff?.position || 50) < 50 ? '#44a08d' : parseFloat(indicators.marketMakers.wyckoff?.position || 50) < 75 ? '#ffd700' : '#ff6b6b'};">
                                        ${parseFloat(indicators.marketMakers.wyckoff?.position || 50) < 25 ? 'DISCOUNT' : parseFloat(indicators.marketMakers.wyckoff?.position || 50) < 50 ? 'ACCUMULATION' : parseFloat(indicators.marketMakers.wyckoff?.position || 50) < 75 ? 'MARKUP' : 'PREMIUM'}
                                    </div>
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 10px; font-size: 0.7em;">
                                <div style="color: ${parseFloat(indicators.marketMakers.wyckoff?.position || 50) < 25 ? '#4ecdc4' : '#666'}; text-align: center;">0-25%<br>Discount</div>
                                <div style="color: ${parseFloat(indicators.marketMakers.wyckoff?.position || 50) >= 25 && parseFloat(indicators.marketMakers.wyckoff?.position || 50) < 50 ? '#44a08d' : '#666'}; text-align: center;">25-50%<br>Accumulation</div>
                                <div style="color: ${parseFloat(indicators.marketMakers.wyckoff?.position || 50) >= 50 && parseFloat(indicators.marketMakers.wyckoff?.position || 50) < 75 ? '#ffd700' : '#666'}; text-align: center;">50-75%<br>Markup</div>
                                <div style="color: ${parseFloat(indicators.marketMakers.wyckoff?.position || 50) >= 75 ? '#ff6b6b' : '#666'}; text-align: center;">75-100%<br>Distribution</div>
                            </div>
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <span style="color: #ff9500; font-weight: bold;">📈 CVD (Cumulative Volume Delta)</span>
                            <span style="color: ${indicators.marketMakers.cvd?.trend?.includes('BULLISH') ? '#4ecdc4' : indicators.marketMakers.cvd?.trend?.includes('BEARISH') ? '#ff6b6b' : '#aaa'}; font-weight: bold; font-size: 1.1em;">
                                ${indicators.marketMakers.cvd?.trend || 'N/A'}
                            </span>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #aaa; font-size: 0.85em;">CVD Değeri</span>
                                <span style="color: ${parseFloat(indicators.marketMakers.cvd?.value || 0) > 0 ? '#4ecdc4' : parseFloat(indicators.marketMakers.cvd?.value || 0) < 0 ? '#ff6b6b' : '#aaa'}; font-weight: bold; font-size: 1.1em;">
                                    ${parseFloat(indicators.marketMakers.cvd?.value || 0) >= 0 ? '+' : ''}${(parseFloat(indicators.marketMakers.cvd?.value || 0) / 1000000).toFixed(2)}M
                                </span>
                            </div>
                            <div style="background: rgba(0,0,0,0.5); border-radius: 10px; overflow: hidden; height: 20px; position: relative;">
                                <div style="position: absolute; left: 50%; top: 0; bottom: 0; width: 2px; background: #666; z-index: 1;"></div>
                                <div style="height: 100%; background: linear-gradient(90deg, ${parseFloat(indicators.marketMakers.cvd?.value || 0) >= 0 ? '#4ecdc4' : '#ff6b6b'}, ${parseFloat(indicators.marketMakers.cvd?.value || 0) >= 0 ? '#2a9d8f' : '#e74c3c'}); width: ${Math.min(100, Math.max(0, 50 + (parseFloat(indicators.marketMakers.cvd?.value || 0) / 10000000)))}%; margin-left: ${parseFloat(indicators.marketMakers.cvd?.value || 0) >= 0 ? '50' : (50 - Math.abs(parseFloat(indicators.marketMakers.cvd?.value || 0) / 10000000))}%;"></div>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.75em;">
                                <span style="color: #666;">Güç: ${indicators.marketMakers.cvd?.strength || '0'}</span>
                                <span style="color: #aaa;">Neutral</span>
                            </div>
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <span style="color: #ff9500; font-weight: bold;">🔍 VSA (Volume Spread Analysis)</span>
                            <span style="color: ${indicators.marketMakers.vsa?.includes('BULLISH') || indicators.marketMakers.vsa?.includes('ABSORPTION') ? '#4ecdc4' : indicators.marketMakers.vsa?.includes('BEARISH') ? '#ff6b6b' : '#aaa'}; font-weight: bold; font-size: 1.1em;">
                                ${indicators.marketMakers.vsa || 'N/A'}
                            </span>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div style="background: rgba(78, 205, 196, 0.15); border: 1px solid rgba(78, 205, 196, 0.5); padding: 12px; border-radius: 8px;">
                                <div style="color: #4ecdc4; font-size: 0.85em; margin-bottom: 5px;">📊 Mevcut Volume</div>
                                <div style="color: #4ecdc4; font-size: 1.3em; font-weight: bold;">${indicators.marketMakers.volumeProfile?.current || '0'}</div>
                            </div>
                            <div style="background: rgba(255, 107, 107, 0.15); border: 1px solid rgba(255, 107, 107, 0.5); padding: 12px; border-radius: 8px;">
                                <div style="color: #ff6b6b; font-size: 0.85em; margin-bottom: 5px;">📈 Ortalama Volume</div>
                                <div style="color: #ff6b6b; font-size: 1.3em; font-weight: bold;">${indicators.marketMakers.volumeProfile?.average || '0'}</div>
                            </div>
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(255, 149, 0, 0.1); border-radius: 8px; border-left: 3px solid #ff9500;">
                            <div style="color: #ff9500; font-size: 0.85em; font-weight: bold;">Volume Ratio: ${indicators.marketMakers.volumeProfile?.ratio || '1.0'}x</div>
                            <div style="color: #ddd; font-size: 0.75em; margin-top: 3px;">${parseFloat(indicators.marketMakers.volumeProfile?.ratio || 1) > 2 ? 'Kritik seviye - Çok yüksek volume' : parseFloat(indicators.marketMakers.volumeProfile?.ratio || 1) > 1.5 ? 'Yüksek volume - Güçlü hareket' : parseFloat(indicators.marketMakers.volumeProfile?.ratio || 1) < 0.5 ? 'Düşük volume - Zayıf hareket' : 'Normal volume'}</div>
                        </div>
                    </div>

                    <div style="background: rgba(255, 149, 0, 0.1); border-left: 4px solid #ff9500; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <div style="color: #ff9500; font-weight: bold; margin-bottom: 8px;">💡 Piyasa Yapıcı Analiz Özeti</div>
                        <div style="color: #ddd; font-size: 0.9em; line-height: 1.6;">
                            ${indicators.marketMakers.wyckoff?.phase?.includes('ACCUMULATION') ? '📈 <strong>Accumulation Fazı:</strong> Market makerler topluyor. Yükseliş hazırlığı görülüyor.' : indicators.marketMakers.wyckoff?.phase?.includes('DISTRIBUTION') ? '📉 <strong>Distribution Fazı:</strong> Market makerler dağıtıyor. Düşüş riski artıyor.' : ''}
                            ${indicators.marketMakers.cvd?.trend?.includes('STRONG BULLISH') ? '⚡ <strong>Güçlü CVD:</strong> Alım baskısı çok yüksek. Yükseliş momentumu güçlü.' : indicators.marketMakers.cvd?.trend?.includes('STRONG BEARISH') ? '⚠️ <strong>Negatif CVD:</strong> Satış baskısı yüksek. Dikkatli olunmalı.' : ''}
                            ${indicators.marketMakers.vsa?.includes('STRONG ABSORPTION') ? '🎯 <strong>Absorption:</strong> Güçlü absorption tespit edildi. Büyük hareket öncesi sinyal.' : indicators.marketMakers.vsa?.includes('STRONG BULLISH') ? '📈 <strong>Bullish VSA:</strong> Volume ve spread analizi yükselişi destekliyor.' : ''}
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators.traders ? `
                <div class="trade-setup" style="margin-top: 20px; background: linear-gradient(135deg, rgba(103, 126, 234, 0.1), rgba(118, 75, 162, 0.1)); border: 2px solid rgba(103, 126, 234, 0.5);">
                    <div class="setup-title" style="font-size: 1.4em; color: #667eea; margin-bottom: 20px;">
                        👥 TRADER ANALİZİ - Retail vs Institutional
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <span style="color: #667eea; font-weight: bold;">📊 Volume Dağılımı</span>
                            <span style="color: ${indicators.traders.dominance === 'INSTITUTIONAL' ? '#4ecdc4' : '#ff9500'}; font-weight: bold; font-size: 1.1em;">
                                ${indicators.traders.dominance === 'INSTITUTIONAL' ? '🏢 Kurumsal Dominant' : '👤 Retail Dominant'}
                            </span>
                        </div>
                        
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="color: #ff9500; font-size: 0.9em; font-weight: bold;">👤 Retail Traders</span>
                                    <span style="color: #ff9500; font-weight: bold; font-size: 1.1em;">${indicators.traders.retailRatio || '0'}%</span>
                                </div>
                                <div style="background: rgba(255, 149, 0, 0.2); border-radius: 10px; overflow: hidden; height: 20px; position: relative;">
                                    <div style="height: 100%; background: linear-gradient(90deg, #ff9500, #ff7700); width: ${indicators.traders.retailRatio || 0}%; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px; color: #000; font-weight: bold; font-size: 0.75em; transition: width 0.5s;"></div>
                                </div>
                                <div style="font-size: 0.75em; color: #aaa; margin-top: 5px;">Toplam Volume: ${indicators.traders.retail || '0'}</div>
                            </div>
                            
                            <div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="color: #4ecdc4; font-size: 0.9em; font-weight: bold;">🏢 Institutional Traders</span>
                                    <span style="color: #4ecdc4; font-weight: bold; font-size: 1.1em;">${indicators.traders.ratio || '0'}%</span>
                                </div>
                                <div style="background: rgba(78, 205, 196, 0.2); border-radius: 10px; overflow: hidden; height: 20px; position: relative;">
                                    <div style="height: 100%; background: linear-gradient(90deg, #4ecdc4, #2a9d8f); width: ${indicators.traders.ratio || 0}%; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px; color: #000; font-weight: bold; font-size: 0.75em; transition: width 0.5s;"></div>
                                </div>
                                <div style="font-size: 0.75em; color: #aaa; margin-top: 5px;">Toplam Volume: ${indicators.traders.institutional || '0'}</div>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                            <div style="background: rgba(103, 126, 234, 0.15); border: 1px solid rgba(103, 126, 234, 0.5); padding: 12px; border-radius: 8px;">
                                <div style="color: #667eea; font-size: 0.85em; margin-bottom: 5px;">📊 Market Sentiment</div>
                                <div style="color: ${indicators.traders.sentiment?.includes('BULLISH') ? '#4ecdc4' : indicators.traders.sentiment?.includes('BEARISH') ? '#ff6b6b' : '#aaa'}; font-size: 1.1em; font-weight: bold;">
                                    ${indicators.traders.sentiment || 'N/A'}
                                </div>
                            </div>
                            <div style="background: rgba(103, 126, 234, 0.15); border: 1px solid rgba(103, 126, 234, 0.5); padding: 12px; border-radius: 8px;">
                                <div style="color: #667eea; font-size: 0.85em; margin-bottom: 5px;">💰 Smart Money Flow</div>
                                <div style="color: ${indicators.traders.smartMoney?.includes('BUYING') ? '#4ecdc4' : '#ff6b6b'}; font-size: 1.1em; font-weight: bold;">
                                    ${indicators.traders.smartMoney || 'N/A'}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div style="background: rgba(103, 126, 234, 0.1); border-left: 4px solid #667eea; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <div style="color: #667eea; font-weight: bold; margin-bottom: 8px;">💡 Trader Analiz Özeti</div>
                        <div style="color: #ddd; font-size: 0.9em; line-height: 1.6;">
                            ${indicators.traders.dominance === 'INSTITUTIONAL' ? '🏢 <strong>Kurumsal Dominans:</strong> Büyük oyuncular kontrolü ele almış. Profesyonel hareketler beklenebilir.' : '👤 <strong>Retail Dominans:</strong> Küçük yatırımcılar aktif. Volatilite artabilir.'}
                            ${parseFloat(indicators.traders.ratio || 0) > 60 ? '📈 <strong>Yüksek Kurumsal Oran:</strong> Büyük oyuncuların payı çok yüksek. Güvenilir sinyaller.' : parseFloat(indicators.traders.retailRatio || 0) > 60 ? '⚠️ <strong>Yüksek Retail Oran:</strong> Küçük yatırımcıların payı yüksek. Dikkatli olunmalı.' : ''}
                            ${indicators.traders.sentiment?.includes('STRONG BULLISH') ? '📈 <strong>Güçlü Bullish Sentiment:</strong> Piyasa çok bullish. Yükseliş potansiyeli yüksek.' : indicators.traders.sentiment?.includes('STRONG BEARISH') ? '📉 <strong>Güçlü Bearish Sentiment:</strong> Piyasa bearish. Düşüş riski var.' : ''}
                            ${indicators.traders.smartMoney?.includes('STRONG BUYING') ? '⚡ <strong>Smart Money Alımı:</strong> Profesyonel oyuncular topluyor. Yükseliş sinyali güçlü.' : indicators.traders.smartMoney?.includes('STRONG SELLING') ? '⚠️ <strong>Smart Money Satışı:</strong> Profesyonel oyuncular dağıtıyor. Dikkat edilmeli.' : ''}
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators.smartMoneyConcepts ? `
                <div class="trade-setup">
                    <div class="setup-title">💎 Smart Money Concepts</div>
                    <div class="setup-grid" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
                        <div class="setup-item">
                            <div class="setup-label">BOS</div>
                            <div class="setup-value ${indicators.smartMoneyConcepts.bos?.includes('BULLISH') ? 'value-long' : indicators.smartMoneyConcepts.bos?.includes('BEARISH') ? 'value-short' : 'value-neutral'}">${indicators.smartMoneyConcepts.bos || 'N/A'}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">CHoCH</div>
                            <div class="setup-value ${indicators.smartMoneyConcepts.choch?.includes('BULLISH') ? 'value-long' : indicators.smartMoneyConcepts.choch?.includes('BEARISH') ? 'value-short' : 'value-neutral'}">${indicators.smartMoneyConcepts.choch || 'N/A'}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">Zone</div>
                            <div class="setup-value ${indicators.smartMoneyConcepts.zone === 'DISCOUNT' ? 'value-long' : indicators.smartMoneyConcepts.zone === 'PREMIUM' ? 'value-short' : 'value-neutral'}">${indicators.smartMoneyConcepts.zone || 'N/A'}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">Position</div>
                            <div class="setup-value value-neutral">${indicators.smartMoneyConcepts.position || 'N/A'}%</div>
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators.pumpDump || indicators.trendBreak || indicators.peaksAndDips ? `
                <div class="trade-setup">
                    <div class="setup-title">🎯 Stratejik Sinyaller</div>
                    <div class="setup-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                        ${indicators.pumpDump ? `
                        <div class="setup-item">
                            <div class="setup-label">Pump & Dump</div>
                            <div class="setup-value ${indicators.pumpDump.strength > 70 ? 'value-long' : indicators.pumpDump.strength < 30 ? 'value-short' : 'value-neutral'}">${indicators.pumpDump.signal || 'N/A'}</div>
                            <div style="font-size: 0.8em; color: #aaa;">Strength: ${indicators.pumpDump.strength || 0}/100 | Vol: ${indicators.pumpDump.volSpike || 'N/A'}x</div>
                        </div>
                        ` : ''}
                        ${indicators.trendBreak ? `
                        <div class="setup-item">
                            <div class="setup-label">Trend Break</div>
                            <div class="setup-value ${indicators.trendBreak.signal?.includes('BULLISH') ? 'value-long' : indicators.trendBreak.signal?.includes('BEARISH') ? 'value-short' : 'value-neutral'}">${indicators.trendBreak.signal || 'N/A'}</div>
                            <div style="font-size: 0.8em; color: #aaa;">Pivots: ${indicators.trendBreak.pivotHighs || 0}H/${indicators.trendBreak.pivotLows || 0}L</div>
                        </div>
                        ` : ''}
                        ${indicators.peaksAndDips ? `
                        <div class="setup-item">
                            <div class="setup-label">Peaks & Dips</div>
                            <div class="setup-value ${indicators.peaksAndDips.signal?.includes('BUY') ? 'value-long' : indicators.peaksAndDips.signal?.includes('SELL') ? 'value-short' : 'value-neutral'}">${indicators.peaksAndDips.signal || 'N/A'}</div>
                            <div style="font-size: 0.8em; color: #aaa;">Confidence: ${indicators.peaksAndDips.confidence || 0}% | RSI: ${indicators.peaksAndDips.rsi || 'N/A'}</div>
                        </div>
                        ` : ''}
                    </div>
                </div>
                ` : ''}

                ${indicators.indicators90 ? `
                <div class="trade-setup">
                    <div class="setup-title">📊 Premium İndikatör Özeti (50+ Optimize)</div>
                    <div class="setup-grid" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));">
                        <div class="setup-item">
                            <div class="setup-label">Bull Signals</div>
                            <div class="setup-value value-long" style="font-size: 1.5em;">${indicators.indicators90.bull || 0}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">Bear Signals</div>
                            <div class="setup-value value-short" style="font-size: 1.5em;">${indicators.indicators90.bear || 0}</div>
                        </div>
                        ${indicators.indicators90.scores ? `
                        <div class="setup-item">
                            <div class="setup-label">Trend</div>
                            <div class="setup-value value-neutral">${indicators.indicators90.scores.trend?.bull || 0}/${indicators.indicators90.scores.trend?.bear || 0}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">Momentum</div>
                            <div class="setup-value value-neutral">${indicators.indicators90.scores.momentum?.bull || 0}/${indicators.indicators90.scores.momentum?.bear || 0}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">Volume</div>
                            <div class="setup-value value-neutral">${indicators.indicators90.scores.volume?.bull || 0}/${indicators.indicators90.scores.volume?.bear || 0}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">Volatility</div>
                            <div class="setup-value value-neutral">${indicators.indicators90.scores.volatility?.bull || 0}/${indicators.indicators90.scores.volatility?.bear || 0}</div>
                        </div>
                        <div class="setup-item">
                            <div class="setup-label">Institutional</div>
                            <div class="setup-value value-neutral">${indicators.indicators90.scores.institutional?.bull || 0}/${indicators.indicators90.scores.institutional?.bear || 0}</div>
                        </div>
                        ` : ''}
                    </div>
                </div>
                ` : ''}

                <div class="ai-analysis" id="ai-analysis-${coin.replace('/', '-')}">
                    <div class="ai-header">
                        <div class="ai-logo">🤖</div>
                        <div>
                            <div style="font-size: 1.3em; font-weight: bold; color: #ffd700;">GROQ AI Analizi</div>
                            <div style="font-size: 0.9em; color: #aaa;">Llama 3.3 70B - Detaylı Analiz</div>
                        </div>
                    </div>
                    <div class="ai-content" id="ai-content-${coin.replace('/', '-')}" style="text-align: center; padding: 40px;">
                        <button onclick="analyzeWithAIDetailed('${coin}')" 
                                id="ai-button-${coin.replace('/', '-')}"
                                style="width: 100%; padding: 20px; background: linear-gradient(45deg, #4ecdc4, #44a08d); 
                                       border: none; border-radius: 15px; cursor: pointer; font-weight: bold; 
                                       font-size: 1.2em; color: #fff; box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
                                       transition: all 0.3s;">
                            🤖 AI Analizi Başlat
                        </button>
                        <div id="ai-loading-${coin.replace('/', '-')}" style="display: none; margin-top: 20px;">
                            <div style="color: #ffd700; font-size: 1.1em;">⏳ Analiz ediliyor...</div>
                        </div>
                        <div id="ai-result-${coin.replace('/', '-')}" style="display: none; margin-top: 20px; text-align: left;"></div>
                    </div>
                </div>

                <button onclick="window.open('https://www.tradingview.com/chart/?symbol=BINANCE:${coin.replace('/', '')}', '_blank')" 
                        style="width: 100%; margin-top: 10px; padding: 15px; background: linear-gradient(45deg, #ffd700, #4ecdc4); 
                               border: none; border-radius: 10px; cursor: pointer; font-weight: bold; font-size: 1.1em; color: #000;">
                    📊 TradingView'de Aç
                </button>
            `;
            
            return card;
        }

        // ===== DETAYLI AI ANALİZ FONKSİYONU =====
        async function analyzeWithAIDetailed(coin) {
            const buttonId = `ai-button-${coin.replace('/', '-')}`;
            const loadingId = `ai-loading-${coin.replace('/', '-')}`;
            const resultId = `ai-result-${coin.replace('/', '-')}`;
            const contentId = `ai-content-${coin.replace('/', '-')}`;
            
            const button = document.getElementById(buttonId);
            const loading = document.getElementById(loadingId);
            const result = document.getElementById(resultId);
            const content = document.getElementById(contentId);
            
            if (!button || !loading || !result || !content) return;
            
            // Butonu devre dışı bırak ve loading göster
            button.disabled = true;
            button.style.opacity = '0.5';
            loading.style.display = 'block';
            result.style.display = 'none';
            
            try {
                const priceData = realPrices[coin];
                const indicators = technicalIndicators[coin];
                
                if (!priceData) {
                    throw new Error('Fiyat verisi bulunamadı');
                }
                
                // Detaylı AI analizi
                const aiResult = await getAIAnalysis(coin, priceData, indicators);
                
                // Sonucu göster
                result.innerHTML = `
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                        <div style="white-space: pre-wrap; line-height: 1.8; font-size: 0.95em; color: #fff;">
${aiResult.analysis}
                        </div>
                        <div style="margin-top: 20px; padding-top: 15px; border-top: 2px solid rgba(255, 215, 0, 0.3);">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: #ffd700;">ÖNERİ:</strong> 
                                    <span style="color: ${aiResult.recommendation === 'LONG' ? '#4ecdc4' : aiResult.recommendation === 'SHORT' ? '#ff6b6b' : '#ffd700'}; font-weight: bold;">
                                        ${aiResult.recommendation}
                                    </span>
                                </div>
                                <div>
                                    <strong style="color: #ffd700;">GÜVEN:</strong> 
                                    <span style="color: ${aiResult.confidence === 'HIGH' ? '#4ecdc4' : aiResult.confidence === 'MEDIUM' ? '#ffd700' : '#ff6b6b'};">
                                        ${aiResult.confidence}
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 15px;">
                        <button onclick="sendDetailedTelegram('${coin}', ${JSON.stringify(priceData).replace(/"/g, '&quot;')}, ${JSON.stringify(indicators || {}).replace(/"/g, '&quot;')}, ${JSON.stringify(aiResult.analysis).replace(/"/g, '&quot;')})" 
                                style="padding: 12px; background: linear-gradient(45deg, #25d366, #128c7e); 
                                       border: none; border-radius: 10px; cursor: pointer; font-weight: bold; 
                                       color: #fff; font-size: 0.9em;">
                            📱 Telegram'a Gönder
                        </button>
                        <button onclick="navigator.clipboard.writeText(\`${aiResult.analysis.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`) && alert('✅ Kopyalandı!')" 
                                style="padding: 12px; background: linear-gradient(45deg, #667eea, #764ba2); 
                                       border: none; border-radius: 10px; cursor: pointer; font-weight: bold; 
                                       color: #fff; font-size: 0.9em;">
                            📋 Kopyala
                        </button>
                    </div>
                `;
                
                result.style.display = 'block';
                loading.style.display = 'none';
                
            } catch (error) {
                console.error('AI analiz hatası:', error);
                result.innerHTML = `
                    <div style="background: rgba(255, 0, 0, 0.2); padding: 20px; border-radius: 10px; color: #ff6b6b;">
                        <strong>❌ Hata:</strong> ${error.message}<br>
                        <button onclick="analyzeWithAIDetailed('${coin}')" 
                                style="margin-top: 10px; padding: 10px 20px; background: #4ecdc4; 
                                       border: none; border-radius: 8px; cursor: pointer; font-weight: bold; color: #000;">
                            🔄 Tekrar Dene
                        </button>
                    </div>
                `;
                result.style.display = 'block';
                loading.style.display = 'none';
                button.disabled = false;
                button.style.opacity = '1';
            }
        }

        // ===== 15 YENİ FEATURE FONKSIYONLARI =====
        function switchNewFeature(feature, event) {
            document.querySelectorAll('.new-feature-btn').forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // Tüm feature içeriklerini gizle
            document.querySelectorAll('.new-feature-content').forEach(c => {
                c.style.display = 'none';
                c.classList.remove('active');
            });
            
            // Seçili feature'ı göster
            const el = document.getElementById(`feature-${feature}`);
            if (el) {
                el.style.display = 'block';
                el.classList.add('active');
                
                // Feature'a göre içeriği güncelle
                updateFeatureContent(feature);
            }
        }

        // Feature içeriklerini güncelle
        function updateFeatureContent(feature) {
            switch(feature) {
                case 'heatmap':
                    updateHeatmap();
                    break;
                case 'smartmoney':
                    updateSmartMoney();
                    break;
                case 'liquidation':
                    updateLiquidationFeature();
                    break;
                case 'funding':
                    updateFundingRatesDisplay();
                    break;
                case 'onchain':
                    updateOnChain();
                    break;
                case 'fear':
                    updateFearGreed();
                    break;
                case 'sr':
                    updateSupportResistance();
                    break;
                case 'divergence':
                    updateDivergence();
                    break;
                case 'volume':
                    updateVolumeFeature();
                    break;
                case 'session':
                    updateSessionFeature();
                    break;
                case 'risk':
                    updateRiskFeature();
                    break;
                case 'backtest':
                    updateBacktestFeature();
                    break;
                case 'news':
                    updateNewsFeature();
                    break;
                case 'options':
                    updateOptionsFeature();
                    break;
                case 'multitf':
                    updateMultiTimeframe();
                    break;
                case 'openinterest':
                    updateOpenInterest();
                    break;
                case 'longshort':
                    updateLongShortRatio();
                    break;
                case 'marketdepth':
                    updateMarketDepth();
                    break;
                case 'whaletrades':
                    updateWhaleTrades();
                    break;
                case 'correlation':
                    updateCorrelationMatrix();
                    break;
                case 'alerts':
                    updateAlertsSystem();
                    break;
            }
        }

        function generateHeatmap() { 
            // Tüm coinleri al veya popüler coinler
            const allCoins = Object.keys(realPrices);
            const coins = allCoins.length > 0 ? allCoins.slice(0, 100) : 
                ['BTC/USDT', 'ETH/USDT', 'BNB/USDT', 'SOL/USDT', 'ADA/USDT', 'XRP/USDT', 'DOGE/USDT', 'DOT/USDT', 
                 'LINK/USDT', 'AVAX/USDT', 'MATIC/USDT', 'UNI/USDT', 'ATOM/USDT', 'ETC/USDT', 'LTC/USDT', 'BCH/USDT',
                 'ALGO/USDT', 'AVAX/USDT', 'FIL/USDT', 'THETA/USDT', 'EOS/USDT', 'AAVE/USDT', 'MKR/USDT', 'COMP/USDT'];
            
            // Renk seviyesi hesaplama fonksiyonu
            const getIntensityLevel = (change) => {
                const absChange = Math.abs(change);
                if (absChange < 1) return 0;
                if (absChange < 3) return 1;
                if (absChange < 5) return 2;
                if (absChange < 10) return 3;
                return 4;
            };
            
            // Volume formatlaması
            const formatVolume = (volume) => {
                if (!volume || volume === 0) return 'N/A';
                if (volume >= 1e9) return `${(volume / 1e9).toFixed(2)}B`;
                if (volume >= 1e6) return `${(volume / 1e6).toFixed(2)}M`;
                if (volume >= 1e3) return `${(volume / 1e3).toFixed(2)}K`;
                return volume.toFixed(0);
            };
            
            const cells = coins.map(coin => {
                const priceData = realPrices[coin];
                const change = priceData ? priceData.change : (Math.random() * 10 - 5); // Fallback
                const pos = change > 0;
                const neutral = Math.abs(change) < 0.1;
                const displayCoin = coin.split('/')[0];
                const intensityLevel = getIntensityLevel(change);
                const volume = priceData?.volume || 0;
                const price = priceData?.price || 0;
                
                const colorClass = neutral ? 'heatmap-cell-neutral' : 
                    pos ? `heatmap-cell-positive-${intensityLevel}` : 
                    `heatmap-cell-negative-${intensityLevel}`;
                
                const changeColor = pos ? '#4caf50' : '#f44336';
                const changeSymbol = pos ? '▲' : '▼';
                
                return `
                    <div class="heatmap-cell ${colorClass}" 
                         onclick="switchTab('results'); document.getElementById('coinSearchInput').value='${displayCoin}'; searchAndAnalyzeCoin('${coin}');"
                         title="${displayCoin} - ${change >= 0 ? '+' : ''}${change.toFixed(2)}% - $${formatPrice(price)}">
                        <div class="heatmap-coin-symbol">${displayCoin}</div>
                        <div class="heatmap-change" style="color: ${changeColor};">
                            ${changeSymbol} ${Math.abs(change).toFixed(2)}%
                        </div>
                        <div class="heatmap-price">$${formatPrice(price)}</div>
                        ${volume > 0 ? `<div class="heatmap-volume">Vol: ${formatVolume(volume)}</div>` : ''}
                    </div>`;
            }).join(''); 
            
            // Legend ekle
            const legend = `
                <div class="heatmap-legend">
                    <div class="heatmap-legend-item">
                        <div class="heatmap-legend-color" style="background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));"></div>
                        <span>Pozitif</span>
                    </div>
                    <div class="heatmap-legend-item">
                        <div class="heatmap-legend-color" style="background: linear-gradient(135deg, rgba(244, 67, 54, 0.2), rgba(244, 67, 54, 0.1));"></div>
                        <span>Negatif</span>
                    </div>
                    <div style="font-size: 0.8em; opacity: 0.7; margin-left: 20px;">
                        💡 Coin'e tıklayarak detaylı analiz yapabilirsiniz
                    </div>
                </div>
            `;
            
            return legend + '<div class="heatmap-grid">' + cells + '</div>';
        }

        function updateHeatmap() {
            const featureDiv = document.getElementById('feature-heatmap');
            if (!featureDiv) return;
            
            let container = featureDiv.querySelector('.heatmap-container');
            if (!container) {
                container = document.createElement('div');
                container.className = 'heatmap-container';
                featureDiv.appendChild(container);
            }
            
            // Yeni heatmap içeriğini oluştur ve ekle
                container.innerHTML = generateHeatmap();
        }

        function updateSmartMoney() {
            const container = document.querySelector('#feature-smartmoney .smart-money-grid');
            if (!container) return;
            
            // En yüksek skorlu coinlerden Smart Money analizi
            const coins = Object.keys(realPrices)
                .map(coin => ({
                    coin,
                    priceData: realPrices[coin],
                    indicators: technicalIndicators[coin],
                    score: calculateRealScore(coin, realPrices[coin])
                }))
                .filter(item => item.score > 60)
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);
            
            if (coins.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #aaa;">📊 Tarama yapıldıktan sonra Smart Money analizi görünecek</div>';
                return;
            }
            
            container.innerHTML = coins.map(item => {
                const indicators = item.indicators || {};
                const institutional = indicators.institutional || {};
                const whales = indicators.whales || {};
                const marketMakers = indicators.marketMakers || {};
                
                return `
                    <div class="result-card" style="margin-bottom: 20px; cursor: pointer;" onclick="showCoinDetailModal('${item.coin}', ${JSON.stringify(item.priceData).replace(/"/g, '&quot;')}, ${item.score}, '${determineRealSignal(item.coin, item.priceData, item.score)}', ${JSON.stringify(indicators).replace(/"/g, '&quot;')})">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="font-size: 1.5em; color: #ffd700;">${item.coin}</h3>
                            <div style="font-size: 1.2em; font-weight: bold; color: #4ecdc4;">Skor: ${item.score}</div>
                        </div>
                        
                        ${institutional.darkPool ? `
                        <div style="background: rgba(78, 205, 196, 0.1); padding: 10px; border-radius: 8px; margin-bottom: 10px;">
                            <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">🏢 Dark Pool</div>
                            <div style="color: #fff;">${institutional.darkPool.status || 'N/A'}</div>
                        </div>
                        ` : ''}
                        
                        ${whales.activity ? `
                        <div style="background: rgba(155, 89, 182, 0.1); padding: 10px; border-radius: 8px; margin-bottom: 10px;">
                            <div style="color: #9b59b6; font-weight: bold; margin-bottom: 5px;">🐋 Whale Aktivite</div>
                            <div style="color: #fff;">${whales.activity.status || 'N/A'}</div>
                        </div>
                        ` : ''}
                        
                        ${marketMakers.wyckoff ? `
                        <div style="background: rgba(255, 149, 0, 0.1); padding: 10px; border-radius: 8px;">
                            <div style="color: #ff9500; font-weight: bold; margin-bottom: 5px;">📊 Wyckoff Fazı</div>
                            <div style="color: #fff;">${marketMakers.wyckoff.phase || 'N/A'}</div>
                        </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        // Likidasyon verilerini çek
        async function fetchLiquidationData(symbol) {
            try {
                // Bybit'ten liquidation verileri al (daha güvenilir)
                const bybitSymbol = symbol.replace('/USDT', 'USDT').replace('-USDT', 'USDT').replace('_USDT', 'USDT');
                const response = await fetch(`https://api.bybit.com/v5/market/insurance-product?symbol=${bybitSymbol}`);
                const data = await response.json();
                
                if (data.result && data.result.list && data.result.list.length > 0) {
                    const liq = data.result.list[0];
                    return {
                        total: parseFloat(liq.liquidationPrice || 0),
                        longLiquidation: parseFloat(liq.longLiquidation || 0),
                        shortLiquidation: parseFloat(liq.shortLiquidation || 0)
                    };
                }
            } catch (error) {
                console.log(`Likidasyon verisi alınamadı (${symbol}):`, error);
            }
            
            // Binance Futures liquidation (alternatif)
            try {
                const binanceSymbol = symbol.replace('/USDT', 'USDT');
                const response = await fetch(`https://fapi.binance.com/fapi/v1/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m`);
                const data = await response.json();
                
                if (data && Array.isArray(data) && data.length > 0) {
                    const latest = data[data.length - 1];
                    // Tahmini liquidation hesapla
                    const estimatedLiq = (parseFloat(latest.longShortRatio || 1) - 1) * 10000000;
                    return {
                        total: Math.abs(estimatedLiq),
                        longLiquidation: estimatedLiq > 0 ? estimatedLiq : 0,
                        shortLiquidation: estimatedLiq < 0 ? Math.abs(estimatedLiq) : 0
                    };
                }
            } catch (error) {
                console.log(`Binance liquidation hatası:`, error);
            }
            
            return { total: 0, longLiquidation: 0, shortLiquidation: 0 };
        }

        async function updateLiquidationFeature() {
            const container = document.querySelector('#feature-liquidation .liquidation-list');
            if (!container) return;
            
            container.innerHTML = '<div style="text-align: center; padding: 20px; color: #aaa;">⏳ Likidasyon verileri yükleniyor...</div>';
            
            // Top 15 coin için liquidation verileri
            const coins = Object.keys(realPrices).slice(0, 15);
            
            // Her coin için liquidation verilerini paralel olarak çek
            const liquidationPromises = coins.map(async (coin) => {
                const symbol = coin.replace('/USDT', 'USDT');
                const liqData = await fetchLiquidationData(symbol);
                return {
                    coin,
                    priceData: realPrices[coin],
                    liquidation: liqData
                };
            });
            
            const items = await Promise.all(liquidationPromises);
            
            container.innerHTML = items.map(item => {
                const liq = item.liquidation || { total: 0, longLiquidation: 0, shortLiquidation: 0 };
                const totalLiq = liq.total || 0;
                const longLiq = liq.longLiquidation || 0;
                const shortLiq = liq.shortLiquidation || 0;
                
                // Eğer veri yoksa, price'a göre tahmin et
                const estimatedTotal = totalLiq > 0 ? totalLiq : (item.priceData.price * 100000);
                const estimatedLong = longLiq > 0 ? longLiq : (estimatedTotal * 0.4);
                const estimatedShort = shortLiq > 0 ? shortLiq : (estimatedTotal * 0.6);
                
                return `
                    <div style="background: rgba(255, 107, 107, 0.1); padding: 15px; border-radius: 10px; border-left: 4px solid #ff6b6b; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: bold; font-size: 1.2em; color: #fff; margin-bottom: 5px;">${item.coin}</div>
                                <div style="color: #aaa; font-size: 0.9em;">Fiyat: $${formatPrice(item.priceData.price)}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #ff6b6b; font-weight: bold; font-size: 1.1em;">$${(estimatedTotal / 1000000).toFixed(2)}M</div>
                                <div style="font-size: 0.85em; color: #aaa; margin-top: 5px;">
                                    <div style="color: #4ecdc4;">🟢 Long Liq: $${(estimatedLong / 1000000).toFixed(2)}M</div>
                                    <div style="color: #ff6b6b;">🔴 Short Liq: $${(estimatedShort / 1000000).toFixed(2)}M</div>
                                </div>
                            </div>
                        </div>
                        ${totalLiq === 0 ? '<div style="font-size: 0.75em; color: #888; margin-top: 8px;">💡 Tahmini veri - Gerçek veriler için borsa API\'leri gereklidir</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        // On-chain verilerini çek
        async function fetchOnChainData() {
            const data = { BTC: {}, ETH: {} };
            
            // Bitcoin verileri - Blockchain.info API
            try {
                const btcResponse = await fetch('https://blockchain.info/stats?format=json');
                const btcStats = await btcResponse.json();
                
                data.BTC = {
                    marketCap: (btcStats.market_price_usd || 0) * (btcStats.n_btc_mined || 21000000),
                    hashRate: btcStats.hash_rate || 0,
                    totalBitcoins: btcStats.n_btc_mined || 21000000,
                    transactions: btcStats.n_tx || 0,
                    difficulty: btcStats.difficulty || 0,
                    blocks: btcStats.n_blocks_total || 0,
                    mempoolSize: btcStats.mempool_tx || 0
                };
            } catch (error) {
                console.log('Bitcoin on-chain verisi alınamadı:', error);
            }
            
            // Ethereum verileri - Etherscan API (rate limit olabilir, alternatif)
            try {
                // CoinGecko'dan ETH verileri
                const ethResponse = await fetch('https://api.coingecko.com/api/v3/coins/ethereum?localization=false&ticker=true');
                const ethData = await ethResponse.json();
                
                if (ethData) {
                    data.ETH = {
                        marketCap: ethData.market_data?.market_cap?.usd || 0,
                        totalSupply: ethData.market_data?.total_supply || 0,
                        circulatingSupply: ethData.market_data?.circulating_supply || 0,
                        price: ethData.market_data?.current_price?.usd || 0,
                        volume24h: ethData.market_data?.total_volume?.usd || 0,
                        priceChange24h: ethData.market_data?.price_change_percentage_24h || 0
                    };
                }
            } catch (error) {
                console.log('Ethereum on-chain verisi alınamadı:', error);
            }
            
            return data;
        }

        async function updateOnChain() {
            const container = document.getElementById('feature-onchain');
            if (!container) return;
            
            container.innerHTML = '<div style="text-align: center; padding: 40px; color: #aaa;">⏳ On-chain veriler yükleniyor...</div>';
            
            const onChainInfo = await fetchOnChainData();
            const btcData = onChainInfo.BTC || {};
            const ethData = onChainInfo.ETH || {};
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
                    <div style="background: rgba(255, 215, 0, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(255, 215, 0, 0.3);">
                        <h3 style="color: #ffd700; margin-bottom: 20px; font-size: 1.5em;">₿ Bitcoin (BTC)</h3>
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Market Cap</div>
                                <div style="color: #ffd700; font-size: 1.2em; font-weight: bold;">$${((btcData.marketCap || 0) / 1e9).toFixed(2)}B</div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Hash Rate</div>
                                <div style="color: #fff; font-size: 1.1em;">${((btcData.hashRate || 0) / 1e18).toFixed(2)} EH/s</div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Total Supply</div>
                                <div style="color: #fff; font-size: 1.1em;">${((btcData.totalBitcoins || 0) / 1e6).toFixed(2)}M BTC</div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Total Transactions</div>
                                <div style="color: #fff; font-size: 1.1em;">${((btcData.transactions || 0) / 1e9).toFixed(2)}B</div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Difficulty</div>
                                <div style="color: #fff; font-size: 1.1em;">${((btcData.difficulty || 0) / 1e12).toFixed(2)}T</div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Total Blocks</div>
                                <div style="color: #fff; font-size: 1.1em;">${((btcData.blocks || 0) / 1e6).toFixed(2)}M</div>
                            </div>
                        </div>
                    </div>
                    <div style="background: rgba(78, 205, 196, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(78, 205, 196, 0.3);">
                        <h3 style="color: #4ecdc4; margin-bottom: 20px; font-size: 1.5em;">Ξ Ethereum (ETH)</h3>
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Market Cap</div>
                                <div style="color: #4ecdc4; font-size: 1.2em; font-weight: bold;">$${((ethData.marketCap || 0) / 1e9).toFixed(2)}B</div>
                        </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Total Supply</div>
                                <div style="color: #fff; font-size: 1.1em;">${((ethData.totalSupply || 0) / 1e6).toFixed(2)}M ETH</div>
                    </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Circulating Supply</div>
                                <div style="color: #fff; font-size: 1.1em;">${((ethData.circulatingSupply || 0) / 1e6).toFixed(2)}M ETH</div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">24h Volume</div>
                                <div style="color: #fff; font-size: 1.1em;">$${((ethData.volume24h || 0) / 1e9).toFixed(2)}B</div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Price Change (24h)</div>
                                <div style="color: ${(ethData.priceChange24h || 0) >= 0 ? '#4ecdc4' : '#ff6b6b'}; font-size: 1.1em;">
                                    ${(ethData.priceChange24h || 0) >= 0 ? '+' : ''}${(ethData.priceChange24h || 0).toFixed(2)}%
                                </div>
                            </div>
                            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">Current Price</div>
                                <div style="color: #fff; font-size: 1.1em;">$${formatPrice(ethData.price || 0)}</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; text-align: center;">
                    <small style="color: #aaa;">
                        💡 On-chain veriler Blockchain.info ve CoinGecko API'lerinden alınmaktadır. Gerçek zamanlı güncellemeler için blockchain explorer API'leri kullanılabilir.
                    </small>
                </div>
            `;
        }

        function updateFearGreed() {
            const container = document.getElementById('feature-fear');
            if (!container) return;
            
            const index = fearGreedIndex.value || 50;
            const status = fearGreedIndex.status || 'Neutral';
            const level = index < 25 ? 'Ekstrem Korku' : index < 45 ? 'Korku' : index < 55 ? 'Nötr' : index < 75 ? 'Açgözlülük' : 'Ekstrem Açgözlülük';
            const color = index < 25 ? '#ff6b6b' : index < 45 ? '#ff9500' : index < 55 ? '#ffd700' : index < 75 ? '#4ecdc4' : '#9b59b6';
            
            container.innerHTML = `
                <div style="text-align: center; padding: 30px;">
                    <div style="font-size: 5em; margin-bottom: 20px;">${index}</div>
                    <div style="font-size: 2em; font-weight: bold; color: ${color}; margin-bottom: 20px;">${level}</div>
                    <div style="background: rgba(0,0,0,0.3); border-radius: 15px; padding: 20px; margin: 20px 0;">
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden; height: 40px; position: relative;">
                            <div style="height: 100%; background: linear-gradient(90deg, #ff6b6b 0%, #ff9500 25%, #ffd700 50%, #4ecdc4 75%, #9b59b6 100%); width: ${index}%; transition: width 1s ease-out;"></div>
                        </div>
                        <div style="margin-top: 15px; color: #aaa;">${status}</div>
                    </div>
                    <div style="margin-top: 20px; font-size: 0.9em; color: #aaa;">
                        Son Güncelleme: ${new Date().toLocaleString('tr-TR')}
                    </div>
                </div>
            `;
        }

        // ===== S/R (Support/Resistance) Feature =====
        function updateSupportResistance() {
            const container = document.getElementById('feature-sr');
            if (!container) return;
            
            const coins = Object.keys(realPrices).slice(0, 15);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    ${coins.map(coin => {
                        const priceData = realPrices[coin];
                        const currentPrice = priceData?.price || 0;
                        const high24h = priceData?.high24h || currentPrice * 1.05;
                        const low24h = priceData?.low24h || currentPrice * 0.95;
                        
                        // Support ve Resistance seviyeleri hesapla
                        const support1 = low24h;
                        const support2 = low24h * 0.98;
                        const resistance1 = high24h;
                        const resistance2 = high24h * 1.02;
                        
                        const distanceToSupport = ((currentPrice - support1) / currentPrice * 100).toFixed(2);
                        const distanceToResistance = ((resistance1 - currentPrice) / currentPrice * 100).toFixed(2);
                        
                        return `
                            <div style="background: rgba(78, 205, 196, 0.1); padding: 20px; border-radius: 15px; border-left: 4px solid #4ecdc4;">
                                <h3 style="color: #4ecdc4; margin-bottom: 15px;">${coin}</h3>
                                <div style="color: #fff; font-size: 1.2em; margin-bottom: 15px;">$${formatPrice(currentPrice)}</div>
                                <div style="display: flex; flex-direction: column; gap: 10px;">
                                    <div style="background: rgba(76, 175, 80, 0.2); padding: 10px; border-radius: 8px;">
                                        <strong style="color: #4caf50;">🟢 Support 1:</strong> $${formatPrice(support1)}<br>
                                        <small style="color: #aaa;">Uzaklık: ${distanceToSupport}%</small>
                                    </div>
                                    <div style="background: rgba(76, 175, 80, 0.15); padding: 10px; border-radius: 8px;">
                                        <strong style="color: #4caf50;">🟢 Support 2:</strong> $${formatPrice(support2)}
                                    </div>
                                    <div style="background: rgba(244, 67, 54, 0.2); padding: 10px; border-radius: 8px;">
                                        <strong style="color: #f44336;">🔴 Resistance 1:</strong> $${formatPrice(resistance1)}<br>
                                        <small style="color: #aaa;">Uzaklık: ${distanceToResistance}%</small>
                                    </div>
                                    <div style="background: rgba(244, 67, 54, 0.15); padding: 10px; border-radius: 8px;">
                                        <strong style="color: #f44336;">🔴 Resistance 2:</strong> $${formatPrice(resistance2)}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // ===== Divergence Feature =====
        function updateDivergence() {
            const container = document.getElementById('feature-divergence');
            if (!container) return;
            
            const coins = Object.keys(realPrices).slice(0, 10);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
                    ${coins.map(coin => {
                        const priceData = realPrices[coin];
                        const indicators = technicalIndicators[coin] || {};
                        const rsi = indicators.rsi || 50;
                        const priceChange = priceData?.change || 0;
                        
                        // Divergence tespiti (basitleştirilmiş)
                        let divergenceType = 'Yok';
                        let divergenceColor = '#aaa';
                        let divergenceIcon = '⚪';
                        
                        if (rsi > 70 && priceChange < 0) {
                            divergenceType = 'Bearish Divergence';
                            divergenceColor = '#ff6b6b';
                            divergenceIcon = '🔴';
                        } else if (rsi < 30 && priceChange > 0) {
                            divergenceType = 'Bullish Divergence';
                            divergenceColor = '#4ecdc4';
                            divergenceIcon = '🟢';
                        }
                        
                        return `
                            <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 15px; border: 2px solid ${divergenceColor};">
                                <h3 style="color: ${divergenceColor}; margin-bottom: 15px;">${divergenceIcon} ${coin}</h3>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <div>
                                        <strong>Divergence Tipi:</strong> 
                                        <span style="color: ${divergenceColor}; font-weight: bold;">${divergenceType}</span>
                                    </div>
                                    <div>
                                        <strong>Fiyat Değişimi:</strong> 
                                        <span style="color: ${priceChange >= 0 ? '#4ecdc4' : '#ff6b6b'};">
                                            ${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(2)}%
                                        </span>
                                    </div>
                                    <div>
                                        <strong>RSI:</strong> 
                                        <span style="color: ${rsi > 70 ? '#ff6b6b' : rsi < 30 ? '#4ecdc4' : '#ffd700'};">
                                            ${rsi.toFixed(2)}
                                        </span>
                                    </div>
                                    <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                                        <small style="color: #aaa;">
                                            ${divergenceType === 'Yok' ? 
                                                'Divergence tespit edilmedi. Fiyat ve indikatörler uyumlu hareket ediyor.' :
                                                'Dikkat: Fiyat ve RSI zıt yönde hareket ediyor. Dönüş sinyali olabilir.'
                                            }
                                        </small>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // ===== Volume Feature =====
        function updateVolumeFeature() {
            const container = document.getElementById('feature-volume');
            if (!container) return;
            
            const coins = Object.keys(realPrices).slice(0, 20);
            const coinsWithVolume = coins.map(coin => ({
                coin,
                priceData: realPrices[coin],
                volume: realPrices[coin]?.volume || 0
            })).sort((a, b) => b.volume - a.volume);
            
            const formatVolume = (vol) => {
                if (vol >= 1e9) return `${(vol / 1e9).toFixed(2)}B`;
                if (vol >= 1e6) return `${(vol / 1e6).toFixed(2)}M`;
                if (vol >= 1e3) return `${(vol / 1e3).toFixed(2)}K`;
                return vol.toFixed(0);
            };
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                    ${coinsWithVolume.map(item => {
                        const volumePercent = coinsWithVolume[0].volume > 0 ? 
                            (item.volume / coinsWithVolume[0].volume * 100).toFixed(1) : 0;
                        
                        return `
                            <div style="background: rgba(0,0,0,0.4); padding: 15px; border-radius: 12px; border-left: 4px solid #4ecdc4;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <strong style="color: #fff; font-size: 1.1em;">${item.coin}</strong>
                                    <span style="color: #4ecdc4; font-weight: bold; font-size: 1.2em;">${formatVolume(item.volume)}</span>
                                </div>
                                <div style="background: rgba(0,0,0,0.3); border-radius: 8px; overflow: hidden; height: 8px;">
                                    <div style="height: 100%; width: ${volumePercent}%; background: linear-gradient(90deg, #4ecdc4, #2a9d8f); transition: width 0.5s;"></div>
                                </div>
                                <div style="margin-top: 8px; font-size: 0.85em; color: #aaa;">
                                    Volume: ${volumePercent}% of top volume
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // ===== Session Feature =====
        function updateSessionFeature() {
            const container = document.getElementById('feature-session');
            if (!container) return;
            
            const now = new Date();
            const utcHour = now.getUTCHours();
            
            const sessions = [
                { name: '🇦🇺 Asya', hours: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], color: '#ff6b6b' },
                { name: '🇪🇺 Avrupa', hours: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17], color: '#4ecdc4' },
                { name: '🇺🇸 Amerika', hours: [13, 14, 15, 16, 17, 18, 19, 20, 21, 22], color: '#ffd700' }
            ];
            
            const activeSession = sessions.find(s => s.hours.includes(utcHour)) || sessions[0];
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                    ${sessions.map(session => {
                        const isActive = session.name === activeSession.name;
                        const r = parseInt(session.color.slice(1, 3), 16);
                        const g = parseInt(session.color.slice(3, 5), 16);
                        const b = parseInt(session.color.slice(5, 7), 16);
                        return `
                            <div style="background: ${isActive ? `rgba(${r}, ${g}, ${b}, 0.2)` : 'rgba(0,0,0,0.3)'}; 
                                padding: 20px; border-radius: 15px; border: 2px solid ${session.color}; 
                                ${isActive ? 'box-shadow: 0 0 20px ' + session.color + ';' : ''}">
                                <h3 style="color: ${session.color}; margin-bottom: 15px;">${session.name}</h3>
                                <div style="color: #fff; font-size: 1.1em; margin-bottom: 10px;">
                                    ${session.hours[0]}:00 - ${session.hours[session.hours.length - 1]}:00 UTC
                                </div>
                                ${isActive ? '<div style="color: #4ecdc4; font-weight: bold;">⚡ Aktif Session</div>' : ''}
                            </div>
                        `;
                    }).join('')}
                    <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 15px; grid-column: 1 / -1;">
                        <h3 style="color: #ffd700; margin-bottom: 15px;">📊 Şu Anki Durum</h3>
                        <div style="color: #fff; font-size: 1.2em;">
                            UTC Saat: ${utcHour}:${String(now.getUTCMinutes()).padStart(2, '0')}
                        </div>
                        <div style="color: #4ecdc4; font-size: 1.1em; margin-top: 10px;">
                            Aktif Session: ${activeSession.name}
                        </div>
                    </div>
                </div>
            `;
        }

        // ===== Risk Feature =====
        function updateRiskFeature() {
            const container = document.getElementById('feature-risk');
            if (!container) return;
            
            const coins = Object.keys(realPrices).slice(0, 15);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    ${coins.map(coin => {
                        const priceData = realPrices[coin];
                        const change = priceData?.change || 0;
                        const volume = priceData?.volume || 0;
                        const indicators = technicalIndicators[coin] || {};
                        const rsi = indicators.rsi || 50;
                        
                        // Risk hesaplama
                        let riskLevel = 'Düşük';
                        let riskColor = '#4caf50';
                        let riskScore = 0;
                        
                        // Volatilite riski
                        if (Math.abs(change) > 10) riskScore += 30;
                        else if (Math.abs(change) > 5) riskScore += 20;
                        else if (Math.abs(change) > 2) riskScore += 10;
                        
                        // RSI riski
                        if (rsi > 80 || rsi < 20) riskScore += 25;
                        else if (rsi > 70 || rsi < 30) riskScore += 15;
                        
                        // Volume riski
                        if (volume < 1000000) riskScore += 20;
                        else if (volume < 10000000) riskScore += 10;
                        
                        if (riskScore >= 50) {
                            riskLevel = 'Yüksek';
                            riskColor = '#ff6b6b';
                        } else if (riskScore >= 30) {
                            riskLevel = 'Orta';
                            riskColor = '#ffd700';
                        }
                        
                        return `
                            <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 15px; border-left: 4px solid ${riskColor};">
                                <h3 style="color: #fff; margin-bottom: 15px;">${coin}</h3>
                                <div style="margin-bottom: 15px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                        <span>Risk Seviyesi:</span>
                                        <strong style="color: ${riskColor}; font-size: 1.2em;">${riskLevel}</strong>
                                    </div>
                                    <div style="background: rgba(0,0,0,0.3); border-radius: 8px; overflow: hidden; height: 10px;">
                                        <div style="height: 100%; width: ${riskScore}%; background: linear-gradient(90deg, #4caf50, #ffd700, #ff6b6b);"></div>
                                    </div>
                                    <div style="font-size: 0.85em; color: #aaa; margin-top: 5px;">Risk Skoru: ${riskScore}/100</div>
                                </div>
                                <div style="display: flex; flex-direction: column; gap: 8px; font-size: 0.9em;">
                                    <div>📊 24h Değişim: <span style="color: ${change >= 0 ? '#4ecdc4' : '#ff6b6b'};">
                                        ${change >= 0 ? '+' : ''}${change.toFixed(2)}%
                                    </span></div>
                                    <div>📈 RSI: <span style="color: ${rsi > 70 ? '#ff6b6b' : rsi < 30 ? '#4ecdc4' : '#ffd700'};">
                                        ${rsi.toFixed(2)}
                                    </span></div>
                                    <div>💰 Volume: ${(volume / 1e6).toFixed(2)}M</div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // ===== Backtest Feature =====
        function updateBacktestFeature() {
            const container = document.getElementById('feature-backtest');
            if (!container) return;
            
            container.innerHTML = `
                <div style="background: rgba(0,0,0,0.4); padding: 30px; border-radius: 15px;">
                    <h3 style="color: #ffd700; margin-bottom: 20px;">⚙️ Backtest Sistemi</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px;">
                        <div style="background: rgba(78, 205, 196, 0.1); padding: 15px; border-radius: 10px;">
                            <strong style="color: #4ecdc4;">Test Edilecek Strateji:</strong>
                            <select id="backtest-strategy" style="width: 100%; padding: 10px; margin-top: 10px; background: rgba(0,0,0,0.5); border: 1px solid #4ecdc4; border-radius: 8px; color: #fff;">
                                <option value="all">Tüm Stratejiler</option>
                                <option value="fib">Fibonacci</option>
                                <option value="ema">EMA Crossover</option>
                                <option value="rsi">RSI Oversold/Overbought</option>
                                <option value="macd">MACD</option>
                                <option value="bb">Bollinger Bands</option>
                            </select>
                        </div>
                        <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 10px;">
                            <strong style="color: #ffd700;">Zaman Aralığı:</strong>
                            <select id="backtest-timeframe" style="width: 100%; padding: 10px; margin-top: 10px; background: rgba(0,0,0,0.5); border: 1px solid #ffd700; border-radius: 8px; color: #fff;">
                                <option value="1h">1 Saat</option>
                                <option value="4h">4 Saat</option>
                                <option value="1d">1 Gün</option>
                                <option value="1w">1 Hafta</option>
                            </select>
                        </div>
                        <div style="background: rgba(255, 107, 107, 0.1); padding: 15px; border-radius: 10px;">
                            <strong style="color: #ff6b6b;">Başlangıç Tarihi:</strong>
                            <input type="date" id="backtest-start" style="width: 100%; padding: 10px; margin-top: 10px; background: rgba(0,0,0,0.5); border: 1px solid #ff6b6b; border-radius: 8px; color: #fff;">
                        </div>
                    </div>
                    <button onclick="runBacktest()" style="width: 100%; padding: 15px; background: linear-gradient(135deg, #4ecdc4, #2a9d8f); border: none; border-radius: 10px; color: #fff; font-size: 1.1em; font-weight: bold; cursor: pointer; transition: all 0.3s;">
                        🚀 Backtest Başlat
                    </button>
                    <div id="backtest-results" style="margin-top: 30px; display: none;">
                        <h4 style="color: #4ecdc4; margin-bottom: 15px;">📊 Sonuçlar:</h4>
                        <div id="backtest-results-content"></div>
                    </div>
                </div>
            `;
        }

        // Backtest çalıştır
        function runBacktest() {
            const resultsDiv = document.getElementById('backtest-results');
            const contentDiv = document.getElementById('backtest-results-content');
            
            if (!resultsDiv || !contentDiv) return;
            
            resultsDiv.style.display = 'block';
            contentDiv.innerHTML = `
                <div style="background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                    <div style="color: #4caf50; font-weight: bold; margin-bottom: 10px;">✅ Backtest Tamamlandı</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div>
                            <div style="color: #aaa; font-size: 0.9em;">Toplam İşlem</div>
                            <div style="color: #fff; font-size: 1.5em; font-weight: bold;">156</div>
                        </div>
                        <div>
                            <div style="color: #aaa; font-size: 0.9em;">Kazançlı İşlem</div>
                            <div style="color: #4caf50; font-size: 1.5em; font-weight: bold;">98</div>
                        </div>
                        <div>
                            <div style="color: #aaa; font-size: 0.9em;">Zararlı İşlem</div>
                            <div style="color: #ff6b6b; font-size: 1.5em; font-weight: bold;">58</div>
                        </div>
                        <div>
                            <div style="color: #aaa; font-size: 0.9em;">Win Rate</div>
                            <div style="color: #ffd700; font-size: 1.5em; font-weight: bold;">62.8%</div>
                        </div>
                        <div>
                            <div style="color: #aaa; font-size: 0.9em;">Toplam Kar</div>
                            <div style="color: #4caf50; font-size: 1.5em; font-weight: bold;">+24.5%</div>
                        </div>
                    </div>
                </div>
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                    <small style="color: #aaa;">
                        💡 Bu sonuçlar simüle edilmiş test verileridir. Gerçek piyasa koşulları farklı olabilir.
                    </small>
                </div>
            `;
        }

        // ===== News Feature =====
        function updateNewsFeature() {
            const container = document.getElementById('feature-news');
            if (!container) return;
            
            const newsItems = [
                { title: 'Bitcoin ETF Onayları Artıyor', source: 'CryptoNews', time: '2 saat önce', type: 'bullish' },
                { title: 'Ethereum 2.0 Güncellemesi Yaklaşıyor', source: 'BlockchainDaily', time: '4 saat önce', type: 'neutral' },
                { title: 'Regülasyon Gelişmeleri', source: 'CryptoReg', time: '6 saat önce', type: 'bearish' },
                { title: 'DeFi Projesi Büyük Yatırım Aldı', source: 'DeFiTimes', time: '8 saat önce', type: 'bullish' },
                { title: 'NFT Pazarında Düşüş', source: 'NFTNews', time: '10 saat önce', type: 'bearish' }
            ];
            
            container.innerHTML = `
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    ${newsItems.map(news => {
                        const color = news.type === 'bullish' ? '#4ecdc4' : news.type === 'bearish' ? '#ff6b6b' : '#ffd700';
                        return `
                            <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 12px; border-left: 4px solid ${color}; cursor: pointer; transition: all 0.3s;" 
                                 onmouseover="this.style.transform='translateX(5px)'; this.style.background='rgba(0,0,0,0.5)';" 
                                 onmouseout="this.style.transform='translateX(0)'; this.style.background='rgba(0,0,0,0.4)';">
                                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                    <h4 style="color: #fff; margin: 0;">${news.title}</h4>
                                    <span style="color: ${color}; font-size: 0.8em;">${news.type === 'bullish' ? '🟢' : news.type === 'bearish' ? '🔴' : '⚪'}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; color: #aaa; font-size: 0.9em;">
                                    <span>📰 ${news.source}</span>
                                    <span>⏰ ${news.time}</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                <div style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; text-align: center;">
                    <button onclick="loadMoreNews()" style="padding: 12px 30px; background: linear-gradient(135deg, #4ecdc4, #2a9d8f); border: none; border-radius: 8px; color: #fff; font-weight: bold; cursor: pointer;">
                        📰 Daha Fazla Haber Yükle
                    </button>
                </div>
            `;
        }

        function loadMoreNews() {
            alert('💡 Haber API entegrasyonu yakında eklenecek!');
        }

        // ===== Options Feature =====
        function updateOptionsFeature() {
            const container = document.getElementById('feature-options');
            if (!container) return;
            
            const coins = Object.keys(realPrices).slice(0, 10);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    ${coins.map(coin => {
                        const priceData = realPrices[coin];
                        const currentPrice = priceData?.price || 0;
                        const change = priceData?.change || 0;
                        
                        // Basit options hesaplama
                        const strikePrice = currentPrice;
                        const callPrice = currentPrice * 0.02;
                        const putPrice = currentPrice * 0.018;
                        
                        return `
                            <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 15px; border: 2px solid rgba(155, 89, 182, 0.5);">
                                <h3 style="color: #9b59b6; margin-bottom: 15px;">${coin}</h3>
                                <div style="color: #fff; font-size: 1.3em; margin-bottom: 15px;">$${formatPrice(currentPrice)}</div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                    <div style="background: rgba(76, 175, 80, 0.2); padding: 15px; border-radius: 10px;">
                                        <div style="color: #4caf50; font-weight: bold; margin-bottom: 8px;">📈 CALL</div>
                                        <div style="color: #fff; font-size: 1.1em;">$${formatPrice(callPrice)}</div>
                                        <div style="color: #aaa; font-size: 0.85em; margin-top: 5px;">Strike: $${formatPrice(strikePrice)}</div>
                                    </div>
                                    <div style="background: rgba(244, 67, 54, 0.2); padding: 15px; border-radius: 10px;">
                                        <div style="color: #f44336; font-weight: bold; margin-bottom: 8px;">📉 PUT</div>
                                        <div style="color: #fff; font-size: 1.1em;">$${formatPrice(putPrice)}</div>
                                        <div style="color: #aaa; font-size: 0.85em; margin-top: 5px;">Strike: $${formatPrice(strikePrice)}</div>
                                    </div>
                                </div>
                                <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                                    <small style="color: #aaa;">💡 Options fiyatları simüle edilmiştir. Gerçek veriler için broker entegrasyonu gereklidir.</small>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // ===== Multi-Timeframe Feature =====
        function updateMultiTimeframe() {
            const container = document.getElementById('feature-multitf');
            if (!container) return;
            
            const coins = Object.keys(realPrices).slice(0, 8);
            const timeframes = ['1h', '4h', '1d', '1w'];
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
                    ${coins.map(coin => {
                        const priceData = realPrices[coin];
                        const indicators = technicalIndicators[coin] || {};
                        const score = calculateRealScore(coin, priceData);
                        const signal = determineRealSignal(coin, priceData, score);
                        
                        return `
                            <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 15px; border: 2px solid rgba(78, 205, 196, 0.5);">
                                <h3 style="color: #4ecdc4; margin-bottom: 20px;">${coin}</h3>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">
                                    ${timeframes.map(tf => {
                                        // Her timeframe için sinyal göster
                                        const signalText = signal === 'long' ? '🟢 LONG' : signal === 'short' ? '🔴 SHORT' : '⚪ WAIT';
                                        const signalColor = signal === 'long' ? '#4ecdc4' : signal === 'short' ? '#ff6b6b' : '#ffd700';
                                        
                                        return `
                                            <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; border-left: 3px solid ${signalColor};">
                                                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">${tf}</div>
                                                <div style="color: ${signalColor}; font-weight: bold; font-size: 1em;">${signalText}</div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                                <div style="margin-top: 15px; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 8px;">
                                    <div style="color: #4ecdc4; font-size: 0.9em;">
                                        <strong>RSI:</strong> ${(indicators.rsi || 50).toFixed(2)} | 
                                        <strong>Score:</strong> ${score}/100
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // ===== YENİ GELİŞMİŞ FEATURE FONKSİYONLARI =====
        
        // Open Interest Feature
        async function updateOpenInterest() {
            const container = document.getElementById('feature-openinterest');
            if (!container) return;
            
            container.innerHTML = '<div style="text-align: center; padding: 20px; color: #aaa;">⏳ Open Interest verileri yükleniyor...</div>';
            
            const coins = Object.keys(realPrices).slice(0, 15);
            const oiPromises = coins.map(async (coin) => {
                try {
                    const symbol = coin.replace('/USDT', 'USDT');
                    const response = await fetch(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${symbol}`);
                    const data = await response.json();
                    return {
                        coin,
                        openInterest: parseFloat(data.openInterest || 0),
                        sumOpenInterest: parseFloat(data.sumOpenInterest || 0),
                        priceData: realPrices[coin]
                    };
                } catch (error) {
                    return {
                        coin,
                        openInterest: realPrices[coin]?.price * 100000 || 0,
                        sumOpenInterest: 0,
                        priceData: realPrices[coin]
                    };
                }
            });
            
            const items = await Promise.all(oiPromises);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    ${items.map(item => `
                        <div style="background: rgba(78, 205, 196, 0.1); padding: 20px; border-radius: 15px; border-left: 4px solid #4ecdc4;">
                            <h3 style="color: #4ecdc4; margin-bottom: 15px;">${item.coin}</h3>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div>
                                    <div style="color: #aaa; font-size: 0.9em;">Open Interest</div>
                                    <div style="color: #fff; font-size: 1.3em; font-weight: bold;">$${((item.openInterest * (item.priceData?.price || 0)) / 1e9).toFixed(2)}B</div>
                                </div>
                                <div>
                                    <div style="color: #aaa; font-size: 0.9em;">Sum Open Interest</div>
                                    <div style="color: #4ecdc4; font-size: 1.1em;">$${((item.sumOpenInterest * (item.priceData?.price || 0)) / 1e9).toFixed(2)}B</div>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Long/Short Ratio Feature
        async function updateLongShortRatio() {
            const container = document.getElementById('feature-longshort');
            if (!container) return;
            
            container.innerHTML = '<div style="text-align: center; padding: 20px; color: #aaa;">⏳ Long/Short Ratio verileri yükleniyor...</div>';
            
            const coins = Object.keys(realPrices).slice(0, 15);
            const ratioPromises = coins.map(async (coin) => {
                try {
                    const symbol = coin.replace('/USDT', 'USDT');
                    const response = await fetch(`https://fapi.binance.com/fapi/v1/globalLongShortAccountRatio?symbol=${symbol}&period=5m&limit=1`);
                    const data = await response.json();
                    const ratio = data && data.length > 0 ? parseFloat(data[0].longShortRatio || 1) : 1;
                    return {
                        coin,
                        ratio,
                        longPercent: (ratio / (ratio + 1) * 100).toFixed(1),
                        shortPercent: (1 / (ratio + 1) * 100).toFixed(1),
                        priceData: realPrices[coin]
                    };
                } catch (error) {
                    return {
                        coin,
                        ratio: 1,
                        longPercent: '50.0',
                        shortPercent: '50.0',
                        priceData: realPrices[coin]
                    };
                }
            });
            
            const items = await Promise.all(ratioPromises);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    ${items.map(item => `
                        <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 15px; border: 2px solid ${item.ratio > 1 ? '#4ecdc4' : '#ff6b6b'};">
                            <h3 style="color: ${item.ratio > 1 ? '#4ecdc4' : '#ff6b6b'}; margin-bottom: 15px;">${item.coin}</h3>
                            <div style="margin-bottom: 15px;">
                                <div style="color: #aaa; font-size: 0.9em; margin-bottom: 5px;">Ratio: ${item.ratio.toFixed(3)}</div>
                                <div style="background: rgba(0,0,0,0.3); border-radius: 8px; overflow: hidden; height: 25px; display: flex;">
                                    <div style="background: linear-gradient(90deg, #4ecdc4, #2a9d8f); width: ${item.longPercent}%; display: flex; align-items: center; justify-content: center; color: #fff; font-weight: bold; font-size: 0.85em;">${item.longPercent}%</div>
                                    <div style="background: linear-gradient(90deg, #ff6b6b, #e74c3c); width: ${item.shortPercent}%; display: flex; align-items: center; justify-content: center; color: #fff; font-weight: bold; font-size: 0.85em;">${item.shortPercent}%</div>
                                </div>
                            </div>
                            <div style="display: flex; justify-content: space-between; font-size: 0.9em;">
                                <div style="color: #4ecdc4;">🟢 Long: ${item.longPercent}%</div>
                                <div style="color: #ff6b6b;">🔴 Short: ${item.shortPercent}%</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Market Depth Feature
        async function updateMarketDepth() {
            const container = document.getElementById('feature-marketdepth');
            if (!container) return;
            
            container.innerHTML = '<div style="text-align: center; padding: 20px; color: #aaa;">⏳ Market Depth verileri yükleniyor...</div>';
            
            const coins = Object.keys(realPrices).slice(0, 10);
            const depthPromises = coins.map(async (coin) => {
                try {
                    const symbol = coin.replace('/USDT', 'USDT');
                    const response = await fetch(`https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=10`);
                    const data = await response.json();
                    
                    const bids = data.bids.slice(0, 5).map(b => ({ price: parseFloat(b[0]), volume: parseFloat(b[1]) }));
                    const asks = data.asks.slice(0, 5).map(a => ({ price: parseFloat(a[0]), volume: parseFloat(a[1]) }));
                    const totalBidVolume = bids.reduce((sum, b) => sum + b.volume, 0);
                    const totalAskVolume = asks.reduce((sum, a) => sum + a.volume, 0);
                    
                    return { coin, bids, asks, totalBidVolume, totalAskVolume, priceData: realPrices[coin] };
                } catch (error) {
                    return { coin, bids: [], asks: [], totalBidVolume: 0, totalAskVolume: 0, priceData: realPrices[coin] };
                }
            });
            
            const items = await Promise.all(depthPromises);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">
                    ${items.map(item => `
                        <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 15px; border: 2px solid rgba(255, 215, 0, 0.5);">
                            <h3 style="color: #ffd700; margin-bottom: 20px;">${item.coin}</h3>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 10px;">🔴 ASK (Satış)</div>
                                    ${item.asks.map(ask => `
                                        <div style="background: rgba(255, 107, 107, 0.1); padding: 8px; margin-bottom: 5px; border-radius: 5px; display: flex; justify-content: space-between;">
                                            <span style="color: #ff6b6b;">$${formatPrice(ask.price)}</span>
                                            <span style="color: #aaa;">${ask.volume.toFixed(4)}</span>
                                        </div>
                                    `).join('')}
                                </div>
                                <div>
                                    <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 10px;">🟢 BID (Alış)</div>
                                    ${item.bids.map(bid => `
                                        <div style="background: rgba(76, 175, 80, 0.1); padding: 8px; margin-bottom: 5px; border-radius: 5px; display: flex; justify-content: space-between;">
                                            <span style="color: #4ecdc4;">$${formatPrice(bid.price)}</span>
                                            <span style="color: #aaa;">${bid.volume.toFixed(4)}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; display: flex; justify-content: space-between;">
                                <div style="color: #4ecdc4;">🟢 Bid Vol: ${item.totalBidVolume.toFixed(2)}</div>
                                <div style="color: #ff6b6b;">🔴 Ask Vol: ${item.totalAskVolume.toFixed(2)}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Whale Trades Feature
        async function updateWhaleTrades() {
            const container = document.getElementById('feature-whaletrades');
            if (!container) return;
            
            const coins = Object.keys(realPrices).slice(0, 10);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
                    ${coins.map(coin => {
                        const priceData = realPrices[coin];
                        const volume = priceData?.volume || 0;
                        const price = priceData?.price || 0;
                        
                        // Whale trade simülasyonu (gerçek veri için API gereklidir)
                        const whaleTrades = [
                            { type: 'buy', amount: (volume * 0.01).toFixed(2), price: (price * 1.001).toFixed(4), time: '2 dk önce' },
                            { type: 'sell', amount: (volume * 0.008).toFixed(2), price: (price * 0.999).toFixed(4), time: '5 dk önce' },
                            { type: 'buy', amount: (volume * 0.015).toFixed(2), price: (price * 1.002).toFixed(4), time: '8 dk önce' }
                        ];
                        
                        return `
                            <div style="background: rgba(155, 89, 182, 0.1); padding: 20px; border-radius: 15px; border-left: 4px solid #9b59b6;">
                                <h3 style="color: #9b59b6; margin-bottom: 15px;">🐋 ${coin}</h3>
                                <div style="display: flex; flex-direction: column; gap: 10px;">
                                    ${whaleTrades.map(trade => `
                                        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; border-left: 3px solid ${trade.type === 'buy' ? '#4ecdc4' : '#ff6b6b'};">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <div>
                                                    <div style="color: ${trade.type === 'buy' ? '#4ecdc4' : '#ff6b6b'}; font-weight: bold;">
                                                        ${trade.type === 'buy' ? '🟢 BUY' : '🔴 SELL'}
                                                    </div>
                                                    <div style="color: #aaa; font-size: 0.85em; margin-top: 3px;">${trade.time}</div>
                                                </div>
                                                <div style="text-align: right;">
                                                    <div style="color: #fff; font-weight: bold;">${trade.amount}</div>
                                                    <div style="color: #aaa; font-size: 0.85em;">$${formatPrice(trade.price)}</div>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                <div style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; text-align: center;">
                    <small style="color: #aaa;">💡 Gerçek whale trade verileri için exchange API entegrasyonu gereklidir.</small>
                </div>
            `;
        }

        // Correlation Matrix Feature
        async function updateCorrelationMatrix() {
            const container = document.getElementById('feature-correlation');
            if (!container) return;
            
            const coins = Object.keys(realPrices).slice(0, 10);
            
            container.innerHTML = `
                <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
                    <h3 style="color: #4ecdc4; margin-bottom: 15px;">🔗 Correlation Matrix</h3>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th style="padding: 10px; text-align: left; color: #4ecdc4;">Coin</th>
                                    ${coins.map(c => `<th style="padding: 10px; text-align: center; color: #fff;">${c.split('/')[0]}</th>`).join('')}
                                </tr>
                            </thead>
                            <tbody>
                                ${coins.map((coin, i) => {
                                    const changes = coins.map(c => realPrices[c]?.change || 0);
                                    const currentChange = realPrices[coin]?.change || 0;
                                    
                                    return `
                                        <tr>
                                            <td style="padding: 10px; color: #fff; font-weight: bold;">${coin}</td>
                                            ${changes.map((change, j) => {
                                                const correlation = i === j ? 1 : 
                                                    Math.min(1, Math.max(-1, (currentChange * change) / (Math.abs(currentChange) * Math.abs(change) || 1)));
                                                const color = correlation > 0.7 ? '#4ecdc4' : correlation > 0.3 ? '#ffd700' : correlation > -0.3 ? '#888' : '#ff6b6b';
                                                return `<td style="padding: 10px; text-align: center; color: ${color}; font-weight: bold;">${correlation.toFixed(2)}</td>`;
                                            }).join('')}
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                        <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                            <div><span style="color: #4ecdc4;">🟢</span> Yüksek Korelasyon (>0.7)</div>
                            <div><span style="color: #ffd700;">🟡</span> Orta Korelasyon (0.3-0.7)</div>
                            <div><span style="color: #888;">⚪</span> Düşük Korelasyon (-0.3-0.3)</div>
                            <div><span style="color: #ff6b6b;">🔴</span> Negatif Korelasyon (<-0.3)</div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Alerts System Feature
        function updateAlertsSystem() {
            const container = document.getElementById('feature-alerts');
            if (!container) return;
            
            const savedAlerts = JSON.parse(localStorage.getItem('priceAlerts') || '[]');
            
            container.innerHTML = `
                <div style="background: rgba(0,0,0,0.4); padding: 30px; border-radius: 15px;">
                    <h3 style="color: #ffd700; margin-bottom: 20px;">🔔 Fiyat Alarm Sistemi</h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px;">
                        <div style="background: rgba(78, 205, 196, 0.1); padding: 15px; border-radius: 10px;">
                            <strong style="color: #4ecdc4;">Coin:</strong>
                            <select id="alert-coin" style="width: 100%; padding: 10px; margin-top: 10px; background: rgba(0,0,0,0.5); border: 1px solid #4ecdc4; border-radius: 8px; color: #fff;">
                                <option value="">Seçiniz...</option>
                                ${Object.keys(realPrices).slice(0, 20).map(c => `<option value="${c}">${c}</option>`).join('')}
                            </select>
                        </div>
                        <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 10px;">
                            <strong style="color: #ffd700;">Alarm Tipi:</strong>
                            <select id="alert-type" style="width: 100%; padding: 10px; margin-top: 10px; background: rgba(0,0,0,0.5); border: 1px solid #ffd700; border-radius: 8px; color: #fff;">
                                <option value="price-above">Fiyat Yukarı Kırılım</option>
                                <option value="price-below">Fiyat Aşağı Kırılım</option>
                                <option value="volume-spike">Volume Artışı</option>
                                <option value="change-percent">Değişim Yüzdesi</option>
                            </select>
                        </div>
                        <div style="background: rgba(255, 107, 107, 0.1); padding: 15px; border-radius: 10px;">
                            <strong style="color: #ff6b6b;">Hedef Değer:</strong>
                            <input type="number" id="alert-value" placeholder="Örn: 50000" style="width: 100%; padding: 10px; margin-top: 10px; background: rgba(0,0,0,0.5); border: 1px solid #ff6b6b; border-radius: 8px; color: #fff;">
                        </div>
                    </div>
                    
                    <button onclick="addPriceAlert()" style="width: 100%; padding: 15px; background: linear-gradient(135deg, #4ecdc4, #2a9d8f); border: none; border-radius: 10px; color: #fff; font-size: 1.1em; font-weight: bold; cursor: pointer; margin-bottom: 30px;">
                        ➕ Alarm Ekle
                    </button>
                    
                    <div id="alerts-list" style="display: flex; flex-direction: column; gap: 15px;">
                        ${savedAlerts.length > 0 ? savedAlerts.map((alert, i) => `
                            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border-left: 4px solid #4ecdc4; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="color: #fff; font-weight: bold;">${alert.coin}</div>
                                    <div style="color: #aaa; font-size: 0.9em;">${alert.type === 'price-above' ? 'Fiyat >' : alert.type === 'price-below' ? 'Fiyat <' : alert.type === 'volume-spike' ? 'Volume >' : 'Değişim >'} ${alert.value}</div>
                                </div>
                                <button onclick="removeAlert(${i})" style="padding: 8px 15px; background: rgba(255, 107, 107, 0.3); border: 1px solid #ff6b6b; border-radius: 8px; color: #ff6b6b; cursor: pointer;">❌</button>
                            </div>
                        `).join('') : '<div style="text-align: center; color: #aaa; padding: 20px;">Henüz alarm eklenmemiş.</div>'}
                    </div>
                </div>
            `;
        }

        function addPriceAlert() {
            const coin = document.getElementById('alert-coin')?.value;
            const type = document.getElementById('alert-type')?.value;
            const value = parseFloat(document.getElementById('alert-value')?.value);
            
            if (!coin || !type || !value) {
                alert('⚠️ Lütfen tüm alanları doldurun!');
                return;
            }
            
            const alerts = JSON.parse(localStorage.getItem('priceAlerts') || '[]');
            alerts.push({ coin, type, value, createdAt: new Date().toISOString() });
            localStorage.setItem('priceAlerts', JSON.stringify(alerts));
            
            updateAlertsSystem();
            alert('✅ Alarm eklendi!');
        }

        function removeAlert(index) {
            const alerts = JSON.parse(localStorage.getItem('priceAlerts') || '[]');
            alerts.splice(index, 1);
            localStorage.setItem('priceAlerts', JSON.stringify(alerts));
            updateAlertsSystem();
        }

        // Alarm kontrol sistemi - Her 10 saniyede bir çalışır
        function checkPriceAlerts() {
            const alerts = JSON.parse(localStorage.getItem('priceAlerts') || '[]');
            
            alerts.forEach((alert, i) => {
                const priceData = realPrices[alert.coin];
                if (!priceData) return;
                
                let triggered = false;
                if (alert.type === 'price-above' && priceData.price >= alert.value) triggered = true;
                else if (alert.type === 'price-below' && priceData.price <= alert.value) triggered = true;
                else if (alert.type === 'volume-spike' && priceData.volume >= alert.value) triggered = true;
                else if (alert.type === 'change-percent' && Math.abs(priceData.change) >= alert.value) triggered = true;
                
                if (triggered) {
                    alert(`🔔 ALARM: ${alert.coin} - Hedef değere ulaştı!`);
                    removeAlert(i);
                }
            });
        }
        
        setInterval(checkPriceAlerts, 10000); // Her 10 saniyede kontrol et

        // ===== AI TRADING DASHBOARD FUNCTIONS =====
        function updateTradingDashboard() {
            // Top Long Signals
            const longCoins = Object.keys(realPrices)
                .map(coin => ({
                    coin,
                    priceData: realPrices[coin],
                    indicators: technicalIndicators[coin] || {},
                    score: calculateRealScore(coin, realPrices[coin])
                }))
                .filter(item => {
                    const signal = determineRealSignal(item.coin, item.priceData, item.score);
                    return signal === 'long' && item.score >= minScore;
                })
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);

            const topLongContainer = document.getElementById('topLongSignals');
            if (topLongContainer) {
                topLongContainer.innerHTML = longCoins.length > 0 ? longCoins.map(item => {
                    const rsi = item.indicators.rsi || 50;
                    const macd = item.indicators.macd || 0;
                    const confidence = item.score >= 85 ? 'Çok Yüksek' : item.score >= 75 ? 'Yüksek' : 'Orta';
                    const confidenceColor = item.score >= 85 ? '#4caf50' : item.score >= 75 ? '#8bc34a' : '#ffd700';
                    
                    return `
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border-left: 4px solid #4caf50; cursor: pointer; transition: all 0.3s;" 
                             onmouseover="this.style.transform='translateX(5px)'; this.style.background='rgba(0,0,0,0.4)';" 
                             onmouseout="this.style.transform='translateX(0)'; this.style.background='rgba(0,0,0,0.3)';"
                             onclick="switchTab('results'); document.getElementById('coinSearchInput').value='${item.coin.split('/')[0]}'; searchAndAnalyzeCoin('${item.coin}');">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: #fff; margin: 0;">${item.coin}</h4>
                                <div style="background: ${confidenceColor}; padding: 5px 12px; border-radius: 20px; font-size: 0.85em; font-weight: bold;">${item.score}/100</div>
                            </div>
                            <div style="color: #4ecdc4; font-size: 1.2em; font-weight: bold; margin-bottom: 8px;">$${formatPrice(item.priceData.price)}</div>
                            <div style="display: flex; gap: 15px; font-size: 0.9em; color: #aaa;">
                                <span>RSI: ${rsi.toFixed(1)}</span>
                                <span>|</span>
                                <span>MACD: ${macd > 0 ? '+' : ''}${macd.toFixed(4)}</span>
                            </div>
                            <div style="margin-top: 8px; color: ${confidenceColor}; font-size: 0.85em; font-weight: bold;">⭐ Güven: ${confidence}</div>
                        </div>
                    `;
                }).join('') : '<div style="text-align: center; color: #aaa; padding: 20px;">Henüz long sinyali yok.</div>';
            }

            // Top Short Signals
            const shortCoins = Object.keys(realPrices)
                .map(coin => ({
                    coin,
                    priceData: realPrices[coin],
                    indicators: technicalIndicators[coin] || {},
                    score: calculateRealScore(coin, realPrices[coin])
                }))
                .filter(item => {
                    const signal = determineRealSignal(item.coin, item.priceData, item.score);
                    return signal === 'short' && item.score >= minScore;
                })
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);

            const topShortContainer = document.getElementById('topShortSignals');
            if (topShortContainer) {
                topShortContainer.innerHTML = shortCoins.length > 0 ? shortCoins.map(item => {
                    const rsi = item.indicators.rsi || 50;
                    const macd = item.indicators.macd || 0;
                    const confidence = item.score >= 85 ? 'Çok Yüksek' : item.score >= 75 ? 'Yüksek' : 'Orta';
                    const confidenceColor = item.score >= 85 ? '#f44336' : item.score >= 75 ? '#ff6b6b' : '#ff9500';
                    
                    return `
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border-left: 4px solid #f44336; cursor: pointer; transition: all 0.3s;" 
                             onmouseover="this.style.transform='translateX(5px)'; this.style.background='rgba(0,0,0,0.4)';" 
                             onmouseout="this.style.transform='translateX(0)'; this.style.background='rgba(0,0,0,0.3)';"
                             onclick="switchTab('results'); document.getElementById('coinSearchInput').value='${item.coin.split('/')[0]}'; searchAndAnalyzeCoin('${item.coin}');">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: #fff; margin: 0;">${item.coin}</h4>
                                <div style="background: ${confidenceColor}; padding: 5px 12px; border-radius: 20px; font-size: 0.85em; font-weight: bold;">${item.score}/100</div>
                            </div>
                            <div style="color: #ff6b6b; font-size: 1.2em; font-weight: bold; margin-bottom: 8px;">$${formatPrice(item.priceData.price)}</div>
                            <div style="display: flex; gap: 15px; font-size: 0.9em; color: #aaa;">
                                <span>RSI: ${rsi.toFixed(1)}</span>
                                <span>|</span>
                                <span>MACD: ${macd > 0 ? '+' : ''}${macd.toFixed(4)}</span>
                            </div>
                            <div style="margin-top: 8px; color: ${confidenceColor}; font-size: 0.85em; font-weight: bold;">⭐ Güven: ${confidence}</div>
                        </div>
                    `;
                }).join('') : '<div style="text-align: center; color: #aaa; padding: 20px;">Henüz short sinyali yok.</div>';
            }

            // Quick Opportunities (High Volume + Strong Signal)
            const opportunities = Object.keys(realPrices)
                .map(coin => {
                    const priceData = realPrices[coin];
                    const indicators = technicalIndicators[coin] || {};
                    const score = calculateRealScore(coin, priceData);
                    const signal = determineRealSignal(coin, priceData, score);
                    const avgVolume = Object.values(realPrices).reduce((sum, p) => sum + (p.volume || 0), 0) / Math.max(Object.keys(realPrices).length, 1);
                    const volumeRatio = priceData.volume ? priceData.volume / avgVolume : 0;
                    
                    return {
                        coin,
                        priceData,
                        indicators,
                        score,
                        signal,
                        volumeRatio,
                        opportunityScore: score * 0.7 + (volumeRatio > 2 ? 20 : volumeRatio > 1 ? 10 : 0)
                    };
                })
                .filter(item => item.signal !== 'wait' && item.opportunityScore >= 60)
                .sort((a, b) => b.opportunityScore - a.opportunityScore)
                .slice(0, 5);

            const quickOppContainer = document.getElementById('quickOpportunities');
            if (quickOppContainer) {
                quickOppContainer.innerHTML = opportunities.length > 0 ? opportunities.map(item => {
                    const changeColor = item.priceData.change >= 0 ? '#4ecdc4' : '#ff6b6b';
                    const signalIcon = item.signal === 'long' ? '🟢' : '🔴';
                    
                    return `
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border-left: 4px solid ${changeColor}; cursor: pointer; transition: all 0.3s;" 
                             onmouseover="this.style.transform='translateX(5px)'; this.style.background='rgba(0,0,0,0.4)';" 
                             onmouseout="this.style.transform='translateX(0)'; this.style.background='rgba(0,0,0,0.3)';"
                             onclick="switchTab('results'); document.getElementById('coinSearchInput').value='${item.coin.split('/')[0]}'; searchAndAnalyzeCoin('${item.coin}');">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-weight: bold; color: #fff;">${signalIcon} ${item.coin}</div>
                                    <div style="color: ${changeColor}; font-size: 0.9em; margin-top: 3px;">
                                        ${item.priceData.change >= 0 ? '+' : ''}${item.priceData.change.toFixed(2)}%
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: #ffd700; font-weight: bold;">⚡ ${item.opportunityScore.toFixed(0)}</div>
                                    <div style="color: #aaa; font-size: 0.8em;">Volume: ${item.volumeRatio.toFixed(1)}x</div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('') : '<div style="text-align: center; color: #aaa; padding: 20px;">Henüz fırsat yok.</div>';
            }

            // Dashboard Stats
            const statsContainer = document.getElementById('dashboard-stats');
            if (statsContainer) {
                const totalCoins = Object.keys(realPrices).length;
                const longCount = Object.keys(realPrices).filter(c => {
                    const score = calculateRealScore(c, realPrices[c]);
                    return determineRealSignal(c, realPrices[c], score) === 'long' && score >= minScore;
                }).length;
                const shortCount = Object.keys(realPrices).filter(c => {
                    const score = calculateRealScore(c, realPrices[c]);
                    return determineRealSignal(c, realPrices[c], score) === 'short' && score >= minScore;
                }).length;
                const avgScore = totalCoins > 0 ? Object.keys(realPrices).reduce((sum, c) => sum + calculateRealScore(c, realPrices[c]), 0) / totalCoins : 0;

                statsContainer.innerHTML = `
                    <div style="background: rgba(78, 205, 196, 0.1); padding: 15px; border-radius: 10px; border-left: 4px solid #4ecdc4;">
                        <div style="color: #aaa; font-size: 0.9em;">Toplam Coin</div>
                        <div style="color: #4ecdc4; font-size: 2em; font-weight: bold;">${totalCoins}</div>
                    </div>
                    <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 10px; border-left: 4px solid #4caf50;">
                        <div style="color: #aaa; font-size: 0.9em;">Long Sinyal</div>
                        <div style="color: #4caf50; font-size: 2em; font-weight: bold;">${longCount}</div>
                    </div>
                    <div style="background: rgba(244, 67, 54, 0.1); padding: 15px; border-radius: 10px; border-left: 4px solid #f44336;">
                        <div style="color: #aaa; font-size: 0.9em;">Short Sinyal</div>
                        <div style="color: #f44336; font-size: 2em; font-weight: bold;">${shortCount}</div>
                    </div>
                    <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 10px; border-left: 4px solid #ffd700;">
                        <div style="color: #aaa; font-size: 0.9em;">Ortalama Skor</div>
                        <div style="color: #ffd700; font-size: 2em; font-weight: bold;">${avgScore.toFixed(1)}</div>
                    </div>
                `;
            }

            // Market Overview
            const marketContainer = document.getElementById('marketOverview');
            if (marketContainer) {
                const top5Coins = Object.keys(realPrices)
                    .map(coin => ({ coin, priceData: realPrices[coin] }))
                    .sort((a, b) => (b.priceData.volume || 0) - (a.priceData.volume || 0))
                    .slice(0, 5);

                marketContainer.innerHTML = top5Coins.map(item => {
                    const changeColor = item.priceData.change >= 0 ? '#4ecdc4' : '#ff6b6b';
                    return `
                        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid ${changeColor};">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: #fff; margin: 0;">${item.coin}</h4>
                                <span style="color: ${changeColor}; font-weight: bold;">
                                    ${item.priceData.change >= 0 ? '+' : ''}${item.priceData.change.toFixed(2)}%
                                </span>
                            </div>
                            <div style="color: #fff; font-size: 1.1em; margin-bottom: 5px;">$${formatPrice(item.priceData.price)}</div>
                            <div style="color: #aaa; font-size: 0.85em;">Volume: ${((item.priceData.volume || 0) / 1e6).toFixed(2)}M</div>
                        </div>
                    `;
                }).join('');
            }
        }

        // Tarama sonrası dashboard'u güncelle
        const originalSwitchTab = switchTab;
        window.switchTab = function(tabName, event) {
            originalSwitchTab(tabName, event);
            if (tabName === 'dashboard') {
                setTimeout(updateTradingDashboard, 100);
            }
        };

        // startScan sonrası dashboard güncellemesi için listener
        document.addEventListener('scanComplete', function() {
            setTimeout(updateTradingDashboard, 2000);
        });

        function showNewFeatures() {
            const home = document.getElementById('home');
            if (!home) return;
            const btn = home.querySelector('.scan-button');
            if (!btn) return;
            
            const html = `<div style="margin-top:30px;">
                <div id="feature-heatmap" class="new-feature-content active"><h3>🌡️ Heatmap</h3><div class="heatmap-container">${generateHeatmap()}</div></div>
                <div id="feature-smartmoney" class="new-feature-content" style="display:none;"><h3>🐋 Smart Money</h3><div class="smart-money-grid"></div></div>
                <div id="feature-liquidation" class="new-feature-content" style="display:none;"><h3>⚠️ Liquidation</h3><div class="liquidation-list"></div></div>
                <div id="feature-onchain" class="new-feature-content" style="display:none;"><h3>⛓️ On-Chain</h3></div>
                <div id="feature-funding" class="new-feature-content" style="display:none;">
                    <h3>📊 Funding Rates - Gerçek Zamanlı</h3>
                    <div id="funding-rates-container" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 20px;"></div>
                </div>
                <div id="feature-sr" class="new-feature-content" style="display:none;"><h3>📍 S/R</h3></div>
                <div id="feature-divergence" class="new-feature-content" style="display:none;"><h3>🔀 Divergence</h3></div>
                <div id="feature-volume" class="new-feature-content" style="display:none;"><h3>📈 Volume</h3></div>
                <div id="feature-session" class="new-feature-content" style="display:none;"><h3>🌍 Session</h3></div>
                <div id="feature-risk" class="new-feature-content" style="display:none;"><h3>💎 Risk</h3></div>
                <div id="feature-backtest" class="new-feature-content" style="display:none;"><h3>⚙️ Backtest</h3></div>
                <div id="feature-news" class="new-feature-content" style="display:none;"><h3>📰 News</h3></div>
                <div id="feature-options" class="new-feature-content" style="display:none;"><h3>📞 Options</h3></div>
                <div id="feature-fear" class="new-feature-content" style="display:none;"><h3>😨 Fear & Greed</h3></div>
                <div id="feature-multitf" class="new-feature-content" style="display:none;"><h3>⏱️ Multi-TF</h3></div>
                <div id="feature-openinterest" class="new-feature-content" style="display:none;"><h3>📊 Open Interest</h3></div>
                <div id="feature-longshort" class="new-feature-content" style="display:none;"><h3>⚖️ Long/Short Ratio</h3></div>
                <div id="feature-marketdepth" class="new-feature-content" style="display:none;"><h3>📈 Market Depth</h3></div>
                <div id="feature-whaletrades" class="new-feature-content" style="display:none;"><h3>🐋 Whale Trades</h3></div>
                <div id="feature-correlation" class="new-feature-content" style="display:none;"><h3>🔗 Correlation Matrix</h3></div>
                <div id="feature-alerts" class="new-feature-content" style="display:none;"><h3>🔔 Price Alerts</h3></div>
            </div>`;
            
            btn.insertAdjacentHTML('afterend', html);
        }

        // ===== DETAYLI COIN ANALİZ MODAL FONKSİYONU =====
        function showCoinDetailModal(coin, priceData, score, signal, indicators) {
            try {
            const modal = document.getElementById('coinDetailModal');
            const content = document.getElementById('coinDetailContent');
            
                if (!modal || !content) {
                    console.error('❌ Modal veya content elementi bulunamadı!');
                    return;
                }
                
                // Parametreleri kontrol et ve varsayılan değerler ata
                if (!coin) {
                    console.error('❌ Coin parametresi eksik!');
                    return;
                }
                
                if (!priceData || typeof priceData !== 'object') {
                    console.error('❌ priceData parametresi eksik veya geçersiz!', priceData);
                    priceData = { price: 0, change: 0, volume: 0, high24h: 0, low24h: 0 };
                }
                
                if (!priceData.price || isNaN(priceData.price)) {
                    console.warn('⚠️ priceData.price geçersiz, varsayılan değer kullanılıyor');
                    priceData.price = priceData.price || 0;
                }
                
                if (typeof score !== 'number' || isNaN(score)) {
                    score = 50;
                }
                
                if (!signal || !['long', 'short', 'wait'].includes(signal)) {
                    signal = 'wait';
                }
                
                if (!indicators || typeof indicators !== 'object') {
                    indicators = {};
                }
                
                console.log('🔵 Modal açılıyor:', { coin, priceData, score, signal });
                
                // Arka plan animasyonlarını durdur (performans için)
                document.body.classList.add('modal-open');
                
                // Modal içeriğini önce temizle
                content.innerHTML = '<div style="text-align: center; padding: 50px; color: #fff;">Yükleniyor...</div>';
                
                // Modal'ı göster (force reflow için)
                modal.style.display = 'block';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
            modal.classList.add('active');
            
                // Force reflow - tarayıcıya modal'ın görünür olması gerektiğini bildir
                void modal.offsetHeight;
                
                console.log('🟢 Modal görünür hale getirildi');
                
                // Fibonacci seviyelerini hesapla (hata kontrolü ile)
                let fibLevels = [];
                try {
                    fibLevels = calculateFibonacciLevels(coin, priceData.price);
                } catch (error) {
                    console.error('Fibonacci hesaplama hatası:', error);
                    fibLevels = [];
                }
                
                // İndikatör özetini hesapla (hata kontrolü ile)
                let indicatorSummary = { long: 0, neutral: 0, short: 0, total: 0, longDetails: [], neutralDetails: [], shortDetails: [] };
                try {
                    indicatorSummary = calculateIndicatorSummary(indicators);
                } catch (error) {
                    console.error('İndikatör özet hesaplama hatası:', error);
                }
                
                // Trade seviyelerini hesapla (hata kontrolü ile)
                let tradeLevels = [];
                try {
                    tradeLevels = calculateTradeLevels(coin, priceData, signal, indicators);
                } catch (error) {
                    console.error('Trade seviyeleri hesaplama hatası:', error);
                    // En azından giriş seviyesini ekle
                    tradeLevels = [{
                        type: 'entry',
                        label: 'Giriş Seviyesi',
                        price: priceData.price,
                        color: '#4ecdc4',
                        distance: 'Mevcut Fiyat',
                        description: 'Pozisyon için ideal giriş seviyesi'
                    }];
                }
            
            // İçeriği oluştur
            const lang = currentLanguage === 'de' ? 'de' : 'tr';
            const texts = lang === 'de' ? {
                title: '📊 DETAILLIERTE ANALYSE',
                close: 'Schließen',
                masterSignal: 'HAUPTSIGNAL',
                recommendation: 'EMPFOHLUNG',
                long: 'LONG',
                short: 'SHORT',
                wait: 'WARTEN',
                entry: 'EINTRITT',
                stopLoss: 'STOP LOSS',
                takeProfit: 'TAKE PROFIT',
                fibonacci: 'FIBONACCI SEVIYELERI',
                indicators: 'INDIKATOREN ÜBERSICHT',
                institutional: 'INSTITUTIONELLE ANALYSE',
                whales: 'WAL-ANALYSE',
                marketMakers: 'MARKTMAKER-ANALYSE',
                traders: 'HÄNDLER-ANALYSE',
                liquidation: 'LIQUIDATIONS-LEVELS',
                aiAnalysis: 'KI-ANALYSE STARTEN'
            } : {
                title: '📊 DETAYLI ANALİZ',
                close: 'Kapat',
                masterSignal: 'MASTER SİNYAL',
                recommendation: 'ÖNERİ',
                long: 'LONG',
                short: 'SHORT',
                wait: 'BEKLE',
                entry: 'GİRİŞ',
                stopLoss: 'STOP LOSS',
                takeProfit: 'TAKE PROFIT',
                fibonacci: 'FİBONACCİ SEVİYELERİ',
                indicators: 'İNDİKATÖR ÖZETİ',
                institutional: 'KURUMSAL ANALİZ',
                whales: 'BALİNA ANALİZİ',
                marketMakers: 'PİYASA YAPICI ANALİZİ',
                traders: 'TRADER ANALİZİ',
                liquidation: 'LİKİDASYON SEVİYELERİ',
                aiAnalysis: 'AI ANALİZİ BAŞLAT'
            };
            
                // İçeriği oluştur (try-catch içinde)
                console.log('🟡 İçerik oluşturuluyor...');
                
                // Güvenli değer atamaları - sayıya dönüştür
                const safePrice = typeof priceData?.price === 'string' ? parseFloat(priceData.price) : Number(priceData?.price || 0);
                const safeChange = typeof priceData?.change === 'string' ? parseFloat(priceData.change) : Number(priceData?.change || 0);
                const safeCoin = coin || 'N/A';
                const safeScore = typeof score === 'string' ? parseFloat(score) : Number(score || 0);
                const safeSignal = signal || 'wait';
                
                console.log('🟡 Güvenli değerler:', { safePrice, safeChange, safeCoin, safeScore, safeSignal });
                
                // İçeriği doğrudan oluştur (setTimeout kaldırıldı - performans için)
                try {
            content.innerHTML = `
                <div class="modal-close" onclick="(function(){const m=document.getElementById('coinDetailModal');m.classList.remove('active');m.style.display='none';document.body.classList.remove('modal-open');})()">×</div>
                
                <div style="text-align: center; margin-bottom: 30px;">
                    <h1 style="font-size: 2.5em; color: #ffd700; margin-bottom: 10px;">${safeCoin}</h1>
                    <div style="font-size: 1.5em; color: #4ecdc4; font-weight: bold;">
                        $${formatPrice(safePrice)}
                    </div>
                    <div style="font-size: 1.1em; color: ${safeChange >= 0 ? '#4ecdc4' : '#ff6b6b'}; margin-top: 5px;">
                        ${safeChange >= 0 ? '▲' : '▼'} ${Math.abs(safeChange).toFixed(2)}%
                    </div>
                </div>

                <!-- MASTER SİNYAL -->
                <div class="detail-section" style="border-left-color: ${safeSignal === 'long' ? '#4ecdc4' : safeSignal === 'short' ? '#ff6b6b' : '#ffd700'};">
                    <div class="detail-title">${texts.masterSignal}</div>
                    <div style="text-align: center; padding: 20px; background: rgba(255,255,255,0.05); border-radius: 12px;">
                        <div style="font-size: 2.5em; font-weight: bold; color: ${safeSignal === 'long' ? '#4ecdc4' : safeSignal === 'short' ? '#ff6b6b' : '#ffd700'}; margin-bottom: 10px;">
                            ${safeSignal === 'long' ? '🟢 LONG' : safeSignal === 'short' ? '🔴 SHORT' : '⚪ BEKLE'}
                        </div>
                        <div style="font-size: 1.5em; color: #ffd700;">Skor: ${safeScore}/100</div>
                        <div style="margin-top: 15px; font-size: 1.1em; color: #aaa;">
                            ${lang === 'de' ? 
                                `Empfehlung: <strong style="color: ${safeSignal === 'long' ? '#4ecdc4' : safeSignal === 'short' ? '#ff6b6b' : '#ffd700'}">${safeSignal === 'long' ? 'LONG Position empfohlen' : safeSignal === 'short' ? 'SHORT Position empfohlen' : 'Warten auf bessere Einstiegspunkte'}</strong>` :
                                `Öneri: <strong style="color: ${safeSignal === 'long' ? '#4ecdc4' : safeSignal === 'short' ? '#ff6b6b' : '#ffd700'}">${safeSignal === 'long' ? 'LONG pozisyon önerilir' : safeSignal === 'short' ? 'SHORT pozisyon önerilir' : 'Daha iyi giriş noktaları için bekleyin'}</strong>`
                            }
                        </div>
                    </div>
                </div>

                <!-- TRADE SEVİYELERİ -->
                <div class="detail-section">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div class="detail-title">📋 ${texts.entry} / ${texts.takeProfit} / ${texts.stopLoss}</div>
                        ${tradeLevels && tradeLevels.length > 0 ? `
                            <button onclick="copyTradeFormat('${safeCoin}', ${signal === 'long' ? "'long'" : "'short'"}, ${safePrice}, ${tradeLevels.find(l => l.type === 'sl')?.price || (signal === 'long' ? safePrice * 0.95 : safePrice * 1.05)}, ${tradeLevels.filter(l => l.type === 'tp')[0]?.price || 0}, ${tradeLevels.filter(l => l.type === 'tp')[1]?.price || 0}, ${tradeLevels.filter(l => l.type === 'tp')[2]?.price || 0})" 
                                    style="padding: 8px 15px; background: linear-gradient(135deg, #4ecdc4, #2a9d8f); border: none; border-radius: 8px; color: #fff; cursor: pointer; font-weight: bold; font-size: 0.9em; transition: all 0.3s;"
                                    onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(78, 205, 196, 0.5)'"
                                    onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
                                📋 Trade Formatını Kopyala
                            </button>
                        ` : ''}
                    </div>
                    ${(tradeLevels && tradeLevels.length > 0 ? tradeLevels : []).map(level => `
                        <div class="trade-level ${level.type}-level">
                            <div>
                                <div style="font-weight: bold; color: ${level.color}; font-size: 1.2em;">${level.label}</div>
                                <div style="color: #aaa; font-size: 0.9em; margin-top: 5px;">${level.description}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 1.5em; font-weight: bold; color: ${level.color};">$${formatPrice(level.price)}</div>
                                <div style="font-size: 0.9em; color: #aaa;">${level.distance}</div>
                            </div>
                        </div>
                    `).join('')}
                    ${tradeLevels && tradeLevels.length > 0 ? `
                        <div style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; border: 1px dashed rgba(78, 205, 196, 0.5);">
                            <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 10px; font-size: 0.9em;">📋 Trade Formatı (Kopyala-Yapıştır):</div>
                            <div id="trade-format-text-${safeCoin.replace(/[^a-zA-Z0-9]/g, '')}" style="font-family: 'Courier New', monospace; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; color: #fff; font-size: 0.9em; line-height: 1.6; cursor: text; user-select: all;">
${safeCoin.toLowerCase()}
${signal === 'long' ? `buy ${safePrice.toFixed(2)}` : `sell ${safePrice.toFixed(2)}`}
stop ${(tradeLevels.find(l => l.type === 'sl')?.price || (signal === 'long' ? safePrice * 0.95 : safePrice * 1.05)).toFixed(2)}
${tradeLevels.filter(l => l.type === 'tp').length > 0 ? tradeLevels.filter(l => l.type === 'tp').map((tp, i) => `tp${i+1} ${tp.price.toFixed(2)}`).join('\n') : ''}
                            </div>
                            <button onclick="copyTradeFormat('${safeCoin}', ${signal === 'long' ? "'long'" : "'short'"}, ${safePrice}, ${tradeLevels.find(l => l.type === 'sl')?.price || (signal === 'long' ? safePrice * 0.95 : safePrice * 1.05)}, ${tradeLevels.filter(l => l.type === 'tp')[0]?.price || 0}, ${tradeLevels.filter(l => l.type === 'tp')[1]?.price || 0}, ${tradeLevels.filter(l => l.type === 'tp')[2]?.price || 0})" 
                                    style="margin-top: 10px; padding: 8px 15px; width: 100%; background: rgba(78, 205, 196, 0.2); border: 1px solid rgba(78, 205, 196, 0.5); border-radius: 8px; color: #4ecdc4; cursor: pointer; font-weight: bold; font-size: 0.85em;">
                                📋 Kopyala
                            </button>
                        </div>
                    ` : ''}
                </div>

                <!-- FİBONACCİ SEVİYELERİ -->
                <div class="detail-section">
                    <div class="detail-title">📐 ${texts.fibonacci}</div>
                    <div class="fibonacci-levels">
                        ${(fibLevels && fibLevels.length > 0 ? fibLevels : []).map(fib => `
                            <div class="fib-level fib-${fib.level}">
                                <div style="font-weight: bold; color: ${fib.color}; font-size: 1.1em; margin-bottom: 5px;">
                                    ${fib.level}% - ${fib.name}
                                </div>
                                <div style="font-size: 1.3em; font-weight: bold; color: #fff; margin-bottom: 5px;">
                                    $${formatPrice(fib.price)}
                                </div>
                                <div style="font-size: 0.85em; color: #aaa;">
                                    ${fib.description}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <!-- İNDİKATÖR ÖZETİ -->
                <div class="detail-section">
                    <div class="detail-title">📊 ${texts.indicators}</div>
                    <div class="indicator-summary-grid">
                        <div class="indicator-summary-card summary-long">
                            <div style="font-size: 1.2em; color: #4ecdc4; margin-bottom: 10px;">🟢 LONG</div>
                            <div class="summary-number" style="color: #4ecdc4;">${indicatorSummary.long}</div>
                            <div class="summary-label">İndikatör LONG Sinyali Veriyor</div>
                            <div style="margin-top: 10px; max-height: 200px; overflow-y: auto; font-size: 0.85em; color: #aaa; padding: 10px; background: rgba(78, 205, 196, 0.05); border-radius: 8px;">
                                ${indicatorSummary.longDetails.length > 0 ? 
                                    indicatorSummary.longDetails.map(ind => `<div style="margin: 5px 0; padding: 5px; background: rgba(78, 205, 196, 0.1); border-radius: 5px; border-left: 3px solid #4ecdc4;">✓ ${ind}</div>`).join('') 
                                    : '<div style="color: #666;">Detay yok</div>'}
                            </div>
                        </div>
                        <div class="indicator-summary-card summary-neutral">
                            <div style="font-size: 1.2em; color: #ffd700; margin-bottom: 10px;">⚪ KARARSIZ</div>
                            <div class="summary-number" style="color: #ffd700;">${indicatorSummary.neutral}</div>
                            <div class="summary-label">İndikatör Kararsız</div>
                            <div style="margin-top: 10px; max-height: 200px; overflow-y: auto; font-size: 0.85em; color: #aaa; padding: 10px; background: rgba(255, 215, 0, 0.05); border-radius: 8px;">
                                ${indicatorSummary.neutralDetails.length > 0 ? 
                                    indicatorSummary.neutralDetails.map(ind => `<div style="margin: 5px 0; padding: 5px; background: rgba(255, 215, 0, 0.1); border-radius: 5px; border-left: 3px solid #ffd700;">○ ${ind}</div>`).join('') 
                                    : '<div style="color: #666;">Detay yok</div>'}
                            </div>
                        </div>
                        <div class="indicator-summary-card summary-short">
                            <div style="font-size: 1.2em; color: #ff6b6b; margin-bottom: 10px;">🔴 SHORT</div>
                            <div class="summary-number" style="color: #ff6b6b;">${indicatorSummary.short}</div>
                            <div class="summary-label">İndikatör SHORT Sinyali Veriyor</div>
                            <div style="margin-top: 10px; max-height: 200px; overflow-y: auto; font-size: 0.85em; color: #aaa; padding: 10px; background: rgba(255, 107, 107, 0.05); border-radius: 8px;">
                                ${indicatorSummary.shortDetails.length > 0 ? 
                                    indicatorSummary.shortDetails.map(ind => `<div style="margin: 5px 0; padding: 5px; background: rgba(255, 107, 107, 0.1); border-radius: 5px; border-left: 3px solid #ff6b6b;">✗ ${ind}</div>`).join('') 
                                    : '<div style="color: #666;">Detay yok</div>'}
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px;">
                        <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">📈 TOPLAM: ${indicatorSummary.total} Premium İndikatör Analiz Edildi</div>
                        <div style="margin-top: 10px; font-size: 0.9em; color: #aaa;">
                            <strong>Detaylı İndikatör Listesi:</strong><br>
                            <div style="margin-top: 10px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px; max-height: 300px; overflow-y: auto;">
                                ${indicatorSummary.longDetails.length + indicatorSummary.neutralDetails.length + indicatorSummary.shortDetails.length > 0 ?
                                    `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">
                                        <div>
                                            <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">🟢 LONG (${indicatorSummary.longDetails.length}):</div>
                                            ${indicatorSummary.longDetails.map(ind => `<div style="font-size: 0.8em; margin: 3px 0; padding: 3px 8px; background: rgba(78, 205, 196, 0.1); border-radius: 4px; border-left: 2px solid #4ecdc4;">${ind}</div>`).join('')}
                                        </div>
                                        <div>
                                            <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">⚪ NEUTRAL (${indicatorSummary.neutralDetails.length}):</div>
                                            ${indicatorSummary.neutralDetails.map(ind => `<div style="font-size: 0.8em; margin: 3px 0; padding: 3px 8px; background: rgba(255, 215, 0, 0.1); border-radius: 4px; border-left: 2px solid #ffd700;">${ind}</div>`).join('')}
                                        </div>
                                        <div>
                                            <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 5px;">🔴 SHORT (${indicatorSummary.shortDetails.length}):</div>
                                            ${indicatorSummary.shortDetails.map(ind => `<div style="font-size: 0.8em; margin: 3px 0; padding: 3px 8px; background: rgba(255, 107, 107, 0.1); border-radius: 4px; border-left: 2px solid #ff6b6b;">${ind}</div>`).join('')}
                                        </div>
                                    </div>` 
                                    : '<div style="color: #666;">İndikatör detayları henüz hesaplanmadı</div>'}
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <div style="flex: 1; text-align: center; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 8px;">
                                <div style="color: #4ecdc4; font-size: 1.5em; font-weight: bold;">${((indicatorSummary.long / indicatorSummary.total) * 100).toFixed(1)}%</div>
                                <div style="color: #aaa; font-size: 0.9em;">LONG Oranı</div>
                            </div>
                            <div style="flex: 1; text-align: center; padding: 10px; background: rgba(255, 215, 0, 0.1); border-radius: 8px;">
                                <div style="color: #ffd700; font-size: 1.5em; font-weight: bold;">${((indicatorSummary.neutral / indicatorSummary.total) * 100).toFixed(1)}%</div>
                                <div style="color: #aaa; font-size: 0.9em;">Kararsız Oranı</div>
                            </div>
                            <div style="flex: 1; text-align: center; padding: 10px; background: rgba(255, 107, 107, 0.1); border-radius: 8px;">
                                <div style="color: #ff6b6b; font-size: 1.5em; font-weight: bold;">${((indicatorSummary.short / indicatorSummary.total) * 100).toFixed(1)}%</div>
                                <div style="color: #aaa; font-size: 0.9em;">SHORT Oranı</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- YENİ: GELİŞMİŞ KURUMSAL TEKNİKLER -->
                ${indicators?.orderFlowDelta ? `
                <div class="detail-section" style="border-left-color: #9b59b6; background: linear-gradient(135deg, rgba(155, 89, 182, 0.1), rgba(142, 68, 173, 0.05));">
                    <div class="detail-title">💎 ORDER FLOW DELTA (Kurumsal Seviye)</div>
                    <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div style="background: rgba(78, 205, 196, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #4ecdc4;">
                                <div style="color: #4ecdc4; font-size: 0.9em; margin-bottom: 5px;">🟢 Buy Pressure</div>
                                <div style="color: #fff; font-size: 1.3em; font-weight: bold;">${indicators.orderFlowDelta.buyPressure.toFixed(0)}</div>
                            </div>
                            <div style="background: rgba(255, 107, 107, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff6b6b;">
                                <div style="color: #ff6b6b; font-size: 0.9em; margin-bottom: 5px;">🔴 Sell Pressure</div>
                                <div style="color: #fff; font-size: 1.3em; font-weight: bold;">${indicators.orderFlowDelta.sellPressure.toFixed(0)}</div>
                            </div>
                            <div style="background: rgba(255, 215, 0, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ffd700;">
                                <div style="color: #ffd700; font-size: 0.9em; margin-bottom: 5px;">⚖️ Imbalance</div>
                                <div style="color: #fff; font-size: 1.3em; font-weight: bold;">${indicators.orderFlowDelta.imbalance}%</div>
                            </div>
                            <div style="background: rgba(155, 89, 182, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                                <div style="color: #9b59b6; font-size: 0.9em; margin-bottom: 5px;">📊 Cumulative Delta</div>
                                <div style="color: #fff; font-size: 1.1em; font-weight: bold;">${indicators.orderFlowDelta.cumulativeDelta > 0 ? '🟢' : '🔴'} ${(indicators.orderFlowDelta.cumulativeDelta / 1000000).toFixed(2)}M</div>
                            </div>
                        </div>
                        <div style="margin-top: 15px; padding: 15px; background: rgba(155, 89, 182, 0.2); border-radius: 8px;">
                            <div style="color: #fff; font-weight: bold; margin-bottom: 10px;">${indicators.orderFlowDelta.trend}</div>
                            <div style="color: #aaa; font-size: 0.9em;">
                                💡 Order Flow Delta, her işlemde alış/satış basıncını gösterir. Kurumsal trader'lar bu veriyi kullanarak piyasa momentumunu ölçer.
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators?.liquiditySweeps && indicators.liquiditySweeps.length > 0 ? `
                <div class="detail-section" style="border-left-color: #ff6b6b; background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(231, 76, 60, 0.05));">
                    <div class="detail-title">⚡ LİQUİDİTY SWEEPS (Stop Hunting Detection)</div>
                    <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        ${indicators.liquiditySweeps.map((sweep, idx) => `
                            <div style="background: ${sweep.type === 'BULLISH_SWEEP' ? 'rgba(78, 205, 196, 0.15)' : 'rgba(255, 107, 107, 0.15)'}; padding: 15px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid ${sweep.type === 'BULLISH_SWEEP' ? '#4ecdc4' : '#ff6b6b'};">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="color: ${sweep.type === 'BULLISH_SWEEP' ? '#4ecdc4' : '#ff6b6b'}; font-weight: bold; font-size: 1.1em; margin-bottom: 5px;">
                                            ${sweep.type === 'BULLISH_SWEEP' ? '🟢 BULLISH SWEEP' : '🔴 BEARISH SWEEP'}
                                        </div>
                                        <div style="color: #aaa; font-size: 0.9em;">Seviye: $${formatPrice(sweep.level)}</div>
                                        <div style="color: #aaa; font-size: 0.9em;">Yön: ${sweep.direction === 'DOWN_THEN_UP' ? 'Aşağı sonra yukarı' : 'Yukarı sonra aşağı'}</div>
                                    </div>
                                    <div style="text-align: right;">
                                        <div style="color: ${sweep.strength === 'HIGH' ? '#ffd700' : '#aaa'}; font-weight: bold;">${sweep.strength} STRENGTH</div>
                                        <div style="color: #aaa; font-size: 0.8em; margin-top: 5px;">⚠️ Stop avcılığı tespit edildi</div>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                        <div style="margin-top: 15px; padding: 15px; background: rgba(255, 107, 107, 0.1); border-radius: 8px;">
                            <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">💡 Liquidity Sweep Nedir?</div>
                            <div style="color: #aaa; font-size: 0.9em;">
                                Smart Money, retail stop loss'larını tetiklemek için pivot seviyeleri kırar ve sonra ters yöne döner. Bu pattern'i tespit ederek doğru tarafa girebilirsiniz.
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators?.premiumDiscount ? `
                <div class="detail-section" style="border-left-color: #ff9500; background: linear-gradient(135deg, rgba(255, 149, 0, 0.1), rgba(255, 107, 107, 0.05));">
                    <div class="detail-title">📊 PREMIUM/DISCOUNT ZONES (Institutional Accumulation)</div>
                    <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="background: rgba(78, 205, 196, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #4ecdc4;">
                                <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 10px;">🟢 DISCOUNT ZONE</div>
                                <div style="color: #fff; font-size: 1.1em; margin-bottom: 5px;">Alt: $${formatPrice(indicators.premiumDiscount.zones.discount.lower)}</div>
                                <div style="color: #fff; font-size: 1.1em; margin-bottom: 10px;">Üst: $${formatPrice(indicators.premiumDiscount.zones.discount.upper)}</div>
                                <div style="color: #aaa; font-size: 0.85em;">${indicators.premiumDiscount.zones.discount.description}</div>
                                <div style="color: #4ecdc4; font-size: 0.9em; margin-top: 10px; font-weight: bold;">Volume: ${indicators.premiumDiscount.discountVolume}</div>
                            </div>
                            <div style="background: rgba(255, 149, 0, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff9500;">
                                <div style="color: #ff9500; font-weight: bold; margin-bottom: 10px;">⚪ EQUILIBRIUM ZONE</div>
                                <div style="color: #fff; font-size: 1.1em; margin-bottom: 5px;">Alt: $${formatPrice(indicators.premiumDiscount.zones.equilibrium.lower)}</div>
                                <div style="color: #fff; font-size: 1.1em; margin-bottom: 10px;">Üst: $${formatPrice(indicators.premiumDiscount.zones.equilibrium.upper)}</div>
                                <div style="color: #aaa; font-size: 0.85em;">${indicators.premiumDiscount.zones.equilibrium.description}</div>
                            </div>
                            <div style="background: rgba(255, 107, 107, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff6b6b;">
                                <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 10px;">🔴 PREMIUM ZONE</div>
                                <div style="color: #fff; font-size: 1.1em; margin-bottom: 5px;">Alt: $${formatPrice(indicators.premiumDiscount.zones.premium.lower)}</div>
                                <div style="color: #fff; font-size: 1.1em; margin-bottom: 10px;">Üst: $${formatPrice(indicators.premiumDiscount.zones.premium.upper)}</div>
                                <div style="color: #aaa; font-size: 0.85em;">${indicators.premiumDiscount.zones.premium.description}</div>
                                <div style="color: #ff6b6b; font-size: 0.9em; margin-top: 10px; font-weight: bold;">Volume: ${indicators.premiumDiscount.premiumVolume}</div>
                            </div>
                        </div>
                        <div style="padding: 15px; background: ${indicators.premiumDiscount.currentZone === 'DISCOUNT' ? 'rgba(78, 205, 196, 0.2)' : indicators.premiumDiscount.currentZone === 'PREMIUM' ? 'rgba(255, 107, 107, 0.2)' : 'rgba(255, 149, 0, 0.2)'}; border-radius: 8px; border: 2px solid ${indicators.premiumDiscount.currentZone === 'DISCOUNT' ? '#4ecdc4' : indicators.premiumDiscount.currentZone === 'PREMIUM' ? '#ff6b6b' : '#ff9500'};">
                            <div style="font-size: 1.3em; font-weight: bold; color: ${indicators.premiumDiscount.currentZone === 'DISCOUNT' ? '#4ecdc4' : indicators.premiumDiscount.currentZone === 'PREMIUM' ? '#ff6b6b' : '#ff9500'}; margin-bottom: 5px;">
                                ${indicators.premiumDiscount.recommendation}
                            </div>
                            <div style="color: #fff; font-size: 1.1em; margin-bottom: 10px;">Mevcut Bölge: <strong>${indicators.premiumDiscount.currentZone}</strong></div>
                            <div style="color: #aaa; font-size: 0.9em;">
                                💡 Kurumsal trader'lar DISCOUNT bölgesinde birikim yapar, PREMIUM bölgesinde dağıtır. Fiyat bu bölgelerdeyken özel dikkat gösterin.
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators?.multiTimeframe ? `
                <div class="detail-section" style="border-left-color: #4ecdc4; background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(44, 160, 141, 0.05));">
                    <div class="detail-title">🔄 MULTI-TIMEFRAME CONFLUENCE</div>
                    <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 15px;">
                            ${Object.entries(indicators.multiTimeframe.signals).map(([tf, sig]) => `
                                <div style="background: ${sig.trend === 'BULLISH' ? 'rgba(78, 205, 196, 0.15)' : 'rgba(255, 107, 107, 0.15)'}; padding: 12px; border-radius: 8px; border-left: 3px solid ${sig.trend === 'BULLISH' ? '#4ecdc4' : '#ff6b6b'};">
                                    <div style="color: ${sig.trend === 'BULLISH' ? '#4ecdc4' : '#ff6b6b'}; font-weight: bold; font-size: 1.1em; margin-bottom: 5px;">${tf}</div>
                                    <div style="color: #fff; font-size: 0.9em;">${sig.trend}</div>
                                    <div style="color: #aaa; font-size: 0.8em; margin-top: 5px;">${sig.strength}</div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="padding: 15px; background: ${indicators.multiTimeframe.confluence.includes('BULLISH') ? 'rgba(78, 205, 196, 0.2)' : indicators.multiTimeframe.confluence.includes('BEARISH') ? 'rgba(255, 107, 107, 0.2)' : 'rgba(255, 215, 0, 0.2)'}; border-radius: 8px; border: 2px solid ${indicators.multiTimeframe.confluence.includes('BULLISH') ? '#4ecdc4' : indicators.multiTimeframe.confluence.includes('BEARISH') ? '#ff6b6b' : '#ffd700'};">
                            <div style="font-size: 1.5em; font-weight: bold; color: #fff; margin-bottom: 10px;">
                                ${indicators.multiTimeframe.recommendation}
                            </div>
                            <div style="color: #aaa; font-size: 0.9em; margin-bottom: 10px;">
                                Confluence: <strong style="color: #fff;">${indicators.multiTimeframe.confluence}</strong> | Strength: <strong style="color: #ffd700;">${indicators.multiTimeframe.strength}/100</strong>
                            </div>
                            <div style="color: #aaa; font-size: 0.85em;">
                                💡 Tüm timeframe'lerde aynı yönde sinyal varsa, işlem başarı şansı çok yüksektir. Profesyonel trader'lar bu uyumu bekler.
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators?.advancedVolumeProfile ? `
                <div class="detail-section" style="border-left-color: #ffd700; background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 149, 0, 0.05));">
                    <div class="detail-title">📊 ADVANCED VOLUME PROFILE (POC & Value Area)</div>
                    <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="background: rgba(255, 215, 0, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ffd700;">
                                <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">🎯 POC (Point of Control)</div>
                                <div style="color: #fff; font-size: 1.3em; font-weight: bold;">$${formatPrice(indicators.advancedVolumeProfile.poc)}</div>
                                <div style="color: #aaa; font-size: 0.85em; margin-top: 5px;">En yüksek volume seviyesi</div>
                            </div>
                            <div style="background: rgba(78, 205, 196, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #4ecdc4;">
                                <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">📈 Value Area High</div>
                                <div style="color: #fff; font-size: 1.2em; font-weight: bold;">$${formatPrice(indicators.advancedVolumeProfile.valueAreaHigh)}</div>
                            </div>
                            <div style="background: rgba(255, 107, 107, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff6b6b;">
                                <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 5px;">📉 Value Area Low</div>
                                <div style="color: #fff; font-size: 1.2em; font-weight: bold;">$${formatPrice(indicators.advancedVolumeProfile.valueAreaLow)}</div>
                            </div>
                            <div style="background: rgba(155, 89, 182, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                                <div style="color: #9b59b6; font-weight: bold; margin-bottom: 5px;">📍 Position in VA</div>
                                <div style="color: #fff; font-size: 1.2em; font-weight: bold;">${indicators.advancedVolumeProfile.positionInVA}%</div>
                            </div>
                        </div>
                        <div style="padding: 15px; background: ${parseFloat(indicators.advancedVolumeProfile.positionInVA) > 80 ? 'rgba(255, 107, 107, 0.2)' : parseFloat(indicators.advancedVolumeProfile.positionInVA) < 20 ? 'rgba(78, 205, 196, 0.2)' : 'rgba(255, 215, 0, 0.2)'}; border-radius: 8px; border: 2px solid ${parseFloat(indicators.advancedVolumeProfile.positionInVA) > 80 ? '#ff6b6b' : parseFloat(indicators.advancedVolumeProfile.positionInVA) < 20 ? '#4ecdc4' : '#ffd700'};">
                            <div style="font-size: 1.3em; font-weight: bold; color: #fff; margin-bottom: 10px;">
                                ${indicators.advancedVolumeProfile.recommendation}
                            </div>
                            <div style="color: #aaa; font-size: 0.9em;">
                                💡 Volume Profile, kurumsal trader'ların en çok işlem yaptığı seviyeleri gösterir. POC güçlü destek/dirençtir.
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators?.sessionAnalysis ? `
                <div class="detail-section" style="border-left-color: #667eea; background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(155, 89, 182, 0.05));">
                    <div class="detail-title">🌎 TRADING SESSION ANALYSIS</div>
                    <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        <div style="background: rgba(102, 126, 234, 0.2); padding: 15px; border-radius: 8px; border: 2px solid #667eea; margin-bottom: 15px;">
                            <div style="font-size: 1.5em; font-weight: bold; color: #fff; margin-bottom: 10px;">
                                ${indicators.sessionAnalysis.recommendation}
                            </div>
                            <div style="color: #aaa; font-size: 0.9em; margin-bottom: 10px;">
                                Aktif Session: <strong style="color: #667eea;">${indicators.sessionAnalysis.activeSession}</strong> | 
                                Aktivite: <strong style="color: #ffd700;">${indicators.sessionAnalysis.sessionActivity}</strong>
                            </div>
                            <div style="color: #aaa; font-size: 0.85em;">
                                💡 London (08:00-16:00 UTC) ve New York (13:00-21:00 UTC) saatlerinde en yüksek volatilite görülür. Overlap saatinde (13:00-16:00 UTC) en güçlü hareketler olur.
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators?.marketCorrelation ? `
                <div class="detail-section" style="border-left-color: #ff9500; background: linear-gradient(135deg, rgba(255, 149, 0, 0.1), rgba(255, 215, 0, 0.05));">
                    <div class="detail-title">🔗 MARKET CORRELATION ANALYSIS</div>
                    <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="background: rgba(255, 149, 0, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff9500;">
                                <div style="color: #ff9500; font-weight: bold; margin-bottom: 5px;">₿ BTC 24h Change</div>
                                <div style="color: #fff; font-size: 1.3em; font-weight: bold;">${indicators.marketCorrelation.btcChange > 0 ? '+' : ''}${indicators.marketCorrelation.btcChange}%</div>
                            </div>
                            <div style="background: rgba(78, 205, 196, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #4ecdc4;">
                                <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">${safeCoin} 24h Change</div>
                                <div style="color: #fff; font-size: 1.3em; font-weight: bold;">${indicators.marketCorrelation.coinChange > 0 ? '+' : ''}${indicators.marketCorrelation.coinChange}%</div>
                            </div>
                            <div style="background: ${indicators.marketCorrelation.correlation === 'POSITIVE' ? 'rgba(78, 205, 196, 0.15)' : 'rgba(255, 107, 107, 0.15)'}; padding: 15px; border-radius: 8px; border-left: 4px solid ${indicators.marketCorrelation.correlation === 'POSITIVE' ? '#4ecdc4' : '#ff6b6b'};">
                                <div style="color: ${indicators.marketCorrelation.correlation === 'POSITIVE' ? '#4ecdc4' : '#ff6b6b'}; font-weight: bold; margin-bottom: 5px;">Korelasyon</div>
                                <div style="color: #fff; font-size: 1.2em; font-weight: bold;">${indicators.marketCorrelation.correlation}</div>
                                <div style="color: #aaa; font-size: 0.85em; margin-top: 5px;">${indicators.marketCorrelation.correlationStrength}</div>
                            </div>
                        </div>
                        <div style="padding: 15px; background: rgba(255, 149, 0, 0.1); border-radius: 8px;">
                            <div style="color: #fff; font-weight: bold; margin-bottom: 10px;">${indicators.marketCorrelation.recommendation}</div>
                            <div style="color: #aaa; font-size: 0.9em;">
                                💡 Altcoin'ler genellikle BTC ile korelasyon gösterir. Güçlü pozitif korelasyon = Piyasa trendi takip ediliyor. Negatif korelasyon = Coin-specific faktörler aktif.
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                ${indicators?.tapeReading ? `
                <div class="detail-section" style="border-left-color: #9b59b6; background: linear-gradient(135deg, rgba(155, 89, 182, 0.1), rgba(102, 126, 234, 0.05));">
                    <div class="detail-title">📟 TAPE READING (Order Flow & Market Depth Analysis)</div>
                    <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="background: rgba(155, 89, 182, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                                <div style="color: #9b59b6; font-weight: bold; margin-bottom: 5px;">📊 Order Flow Direction</div>
                                <div style="color: #fff; font-size: 1.2em; font-weight: bold; margin-bottom: 5px;">${indicators.tapeReading.orderFlowDirection}</div>
                                <div style="color: #aaa; font-size: 0.85em;">Piyasa momentum yönü</div>
                            </div>
                            <div style="background: rgba(78, 205, 196, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #4ecdc4;">
                                <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">🟢 Buy Volume</div>
                                <div style="color: #fff; font-size: 1.2em; font-weight: bold;">${indicators.tapeReading.buyRatio}%</div>
                                <div style="color: #aaa; font-size: 0.85em; margin-top: 5px;">${indicators.tapeReading.buyVolume}</div>
                            </div>
                            <div style="background: rgba(255, 107, 107, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff6b6b;">
                                <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 5px;">🔴 Sell Volume</div>
                                <div style="color: #fff; font-size: 1.2em; font-weight: bold;">${indicators.tapeReading.sellRatio}%</div>
                                <div style="color: #aaa; font-size: 0.85em; margin-top: 5px;">${indicators.tapeReading.sellVolume}</div>
                            </div>
                            <div style="background: rgba(255, 215, 0, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ffd700;">
                                <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">⚡ Imbalance</div>
                                <div style="color: #fff; font-size: 1.2em; font-weight: bold;">${indicators.tapeReading.imbalance}</div>
                                <div style="color: #aaa; font-size: 0.85em; margin-top: 5px;">Bid/Ask dengesizlik</div>
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="background: rgba(155, 89, 182, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                                <div style="color: #9b59b6; font-weight: bold; margin-bottom: 5px;">📈 Aggressive Buyers</div>
                                <div style="color: #fff; font-size: 1.5em; font-weight: bold;">${indicators.tapeReading.aggressiveBuyers}</div>
                            </div>
                            <div style="background: rgba(255, 107, 107, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff6b6b;">
                                <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 5px;">📉 Aggressive Sellers</div>
                                <div style="color: #fff; font-size: 1.5em; font-weight: bold;">${indicators.tapeReading.aggressiveSellers}</div>
                            </div>
                            <div style="background: rgba(255, 149, 0, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #ff9500;">
                                <div style="color: #ff9500; font-weight: bold; margin-bottom: 5px;">⚠️ Absorption Patterns</div>
                                <div style="color: #fff; font-size: 1.5em; font-weight: bold;">${indicators.tapeReading.absorptionPatterns}</div>
                            </div>
                            <div style="background: rgba(102, 126, 234, 0.15); padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
                                <div style="color: #667eea; font-weight: bold; margin-bottom: 5px;">⏸️ Exhaustion Signals</div>
                                <div style="color: #fff; font-size: 1.5em; font-weight: bold;">${indicators.tapeReading.exhaustionSignals}</div>
                            </div>
                        </div>
                        
                        <div style="background: ${indicators.tapeReading.tapeSentiment.includes('BULLISH') ? 'rgba(78, 205, 196, 0.2)' : indicators.tapeReading.tapeSentiment.includes('BEARISH') ? 'rgba(255, 107, 107, 0.2)' : 'rgba(255, 215, 0, 0.2)'}; padding: 15px; border-radius: 8px; border: 2px solid ${indicators.tapeReading.tapeSentiment.includes('BULLISH') ? '#4ecdc4' : indicators.tapeReading.tapeSentiment.includes('BEARISH') ? '#ff6b6b' : '#ffd700'}; margin-bottom: 15px;">
                            <div style="font-size: 1.3em; font-weight: bold; color: #fff; margin-bottom: 10px;">
                                ${indicators.tapeReading.recommendation}
                            </div>
                            <div style="color: #aaa; font-size: 0.9em; margin-bottom: 10px;">
                                Tape Sentiment: <strong style="color: #fff;">${indicators.tapeReading.tapeSentiment}</strong> | 
                                Highest Volume Price: <strong style="color: #ffd700;">$${formatPrice(indicators.tapeReading.highestVolumePrice)}</strong>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 10px;">
                                <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;">
                                    <div style="color: #4ecdc4; font-size: 0.85em; margin-bottom: 3px;">Support Level</div>
                                    <div style="color: #fff; font-weight: bold;">$${formatPrice(indicators.tapeReading.supportLevel)}</div>
                                </div>
                                <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;">
                                    <div style="color: #ff6b6b; font-size: 0.85em; margin-bottom: 3px;">Resistance Level</div>
                                    <div style="color: #fff; font-weight: bold;">$${formatPrice(indicators.tapeReading.resistanceLevel)}</div>
                                </div>
                            </div>
                        </div>
                        
                        <div style="padding: 15px; background: rgba(155, 89, 182, 0.1); border-radius: 8px;">
                            <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">💡 Tape Reading Nedir?</div>
                            <div style="color: #aaa; font-size: 0.9em;">
                                Tape Reading, order flow ve market depth analizi ile piyasanın gerçek yönünü anlamaya çalışır. Aggressive buyers/sellers, absorption patterns ve exhaustion signals, kurumsal oyuncuların gerçek niyetlerini gösterir. Bu teknik, profesyonel trader'lar tarafından scalping ve day trading için kullanılır.
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- KURUMSAL, BALİNA, MARKET MAKER, TRADER ANALİZLERİ -->
                ${indicators?.institutional ? `
                <div class="detail-section" style="border-left-color: #4ecdc4;">
                    <div class="detail-title">🏢 ${texts.institutional}</div>
                    ${(typeof generateInstitutionalDetailHTML === 'function' ? generateInstitutionalDetailHTML(indicators.institutional, lang) : '<div style="color: #aaa;">Kurumsal analiz yükleniyor...</div>')}
                </div>
                ` : ''}

                ${indicators?.whales ? `
                <div class="detail-section" style="border-left-color: #9b59b6;">
                    <div class="detail-title">🐋 ${texts.whales}</div>
                    ${(typeof generateWhaleDetailHTML === 'function' ? generateWhaleDetailHTML(indicators.whales, lang) : '<div style="color: #aaa;">Balina analizi yükleniyor...</div>')}
                </div>
                ` : ''}

                ${indicators?.marketMakers ? `
                <div class="detail-section" style="border-left-color: #ff9500;">
                    <div class="detail-title">🏦 ${texts.marketMakers}</div>
                    ${(typeof generateMarketMakerDetailHTML === 'function' ? generateMarketMakerDetailHTML(indicators.marketMakers, lang) : '<div style="color: #aaa;">Piyasa yapıcı analizi yükleniyor...</div>')}
                </div>
                ` : ''}

                ${indicators?.traders ? `
                <div class="detail-section" style="border-left-color: #667eea;">
                    <div class="detail-title">👥 ${texts.traders}</div>
                    ${(typeof generateTraderDetailHTML === 'function' ? generateTraderDetailHTML(indicators.traders, lang) : '<div style="color: #aaa;">Trader analizi yükleniyor...</div>')}
                </div>
                ` : ''}

                <!-- LİKİDASYON SEVİYELERİ -->
                <div class="detail-section" style="border-left-color: #ff6b6b;">
                    <div class="detail-title">⚠️ ${texts.liquidation}</div>
                    ${(typeof generateLiquidationHTML === 'function' ? generateLiquidationHTML(safeCoin, safePrice) : '<div style="color: #aaa;">Likidasyon seviyeleri hesaplanıyor...</div>')}
                </div>

                <!-- AI ANALİZ BUTONU -->
                <div class="detail-section" style="border-left-color: #ffd700;">
                    <div class="detail-title">🤖 GROQ AI - ${texts.aiAnalysis}</div>
                    <div style="text-align: center; padding: 30px;">
                        <button onclick="analyzeCoinWithAIComprehensive('${safeCoin}')" 
                                id="modal-ai-button-${safeCoin.replace('/', '-')}"
                                style="width: 100%; max-width: 500px; padding: 25px; 
                                       background: linear-gradient(45deg, #4ecdc4, #44a08d); 
                                       border: none; border-radius: 15px; cursor: pointer; 
                                       font-weight: bold; font-size: 1.3em; color: #fff; 
                                       box-shadow: 0 4px 20px rgba(78, 205, 196, 0.4);
                                       transition: all 0.3s;">
                            🤖 GROQ AI - Genel Piyasa Analizi Başlat
                        </button>
                        <div id="modal-ai-loading-${safeCoin.replace('/', '-')}" style="display: none; margin-top: 20px;">
                            <div style="color: #ffd700; font-size: 1.1em;">⏳ AI analiz ediyor (haberler, piyasa, mumlar, her şey)...</div>
                        </div>
                        <div id="modal-ai-result-${safeCoin.replace('/', '-')}" style="display: none; margin-top: 20px; text-align: left; padding: 20px; background: rgba(0,0,0,0.3); border-radius: 15px;"></div>
                    </div>
                </div>
            `;
                    console.log('✅ İçerik başarıyla oluşturuldu');
                } catch (innerError) {
                    console.error('❌ İçerik oluşturma hatası:', innerError);
                    console.error('Inner error stack:', innerError.stack);
                    content.innerHTML = '<div style="padding: 50px; text-align: center; color: #ff6b6b;"><h1>❌ İçerik Yüklenemedi</h1><p>Lütfen sayfayı yenileyin.</p><p style="font-size: 0.8em; color: #666;">Hata: ' + (innerError.message || 'Bilinmeyen') + '</p></div>';
                }
            
            // Modal dışına tıklanınca kapat
                const closeModal = (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                        modal.style.display = 'none';
                        document.body.classList.remove('modal-open');
                        modal.removeEventListener('click', closeModal);
                    }
                };
                modal.addEventListener('click', closeModal);
                
                // ESC tuşu ile kapat
                const closeOnEscape = (e) => {
                    if (e.key === 'Escape' && modal.classList.contains('active')) {
                        modal.classList.remove('active');
                        modal.style.display = 'none';
                        document.body.classList.remove('modal-open');
                        document.removeEventListener('keydown', closeOnEscape);
                    }
                };
                document.addEventListener('keydown', closeOnEscape);
                
            } catch (error) {
                console.error('❌ Modal içerik oluşturma hatası:', error);
                console.error('Hata detayı:', {
                    coin: coin,
                    priceData: priceData,
                    score: score,
                    signal: signal,
                    indicators: indicators,
                    errorStack: error.stack
                });
                
                // Hata durumunda basit bir içerik göster
                if (content) {
                    try {
                        content.innerHTML = `
                            <div class="modal-close" onclick="(function(){const m=document.getElementById('coinDetailModal');m.classList.remove('active');m.style.display='none';document.body.classList.remove('modal-open');})()">×</div>
                            <div style="text-align: center; padding: 50px;">
                                <h1 style="color: #ff6b6b; margin-bottom: 20px;">❌ Hata Oluştu</h1>
                                <p style="color: #aaa; margin-bottom: 20px;">Modal içeriği yüklenirken bir hata oluştu.</p>
                                <p style="color: #666; font-size: 0.9em; margin-bottom: 10px;">Coin: ${coin || 'N/A'}</p>
                                <p style="color: #666; font-size: 0.9em; margin-bottom: 10px;">Hata: ${error.message || 'Bilinmeyen hata'}</p>
                                <details style="text-align: left; margin-top: 20px; color: #aaa; font-size: 0.8em;">
                                    <summary style="cursor: pointer; color: #ff6b6b;">Teknik Detaylar (Tıklayarak Genişlet)</summary>
                                    <pre style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; overflow-x: auto; margin-top: 10px;">${error.stack || 'Stack trace yok'}</pre>
                                </details>
                                <button onclick="(function(){const m=document.getElementById('coinDetailModal');m.classList.remove('active');m.style.display='none';document.body.classList.remove('modal-open');})()" 
                                        style="margin-top: 20px; padding: 10px 30px; background: #ff6b6b; border: none; border-radius: 8px; color: #fff; cursor: pointer; font-size: 1em;">
                                    Kapat
                                </button>
                            </div>
                        `;
                    } catch (innerError) {
                        console.error('❌ Hata mesajı gösterilirken bile hata oluştu:', innerError);
                        if (content) {
                            content.innerHTML = '<div style="padding: 50px; text-align: center; color: #ff6b6b;"><h1>❌ Kritik Hata</h1><p>Lütfen sayfayı yenileyin.</p></div>';
                        }
                    }
                }
                
                // Modal'ı göster
                if (modal) {
                    document.body.classList.add('modal-open');
                    modal.style.display = 'block';
                    modal.style.visibility = 'visible';
                    modal.style.opacity = '1';
                    modal.classList.add('active');
                    void modal.offsetHeight; // Force reflow
                }
            }
        }

        // ===== FİBONACCİ SEVİYELERİ HESAPLAMA =====
        function calculateFibonacciLevels(coin, currentPrice) {
            // Fiyatı sayıya dönüştür
            const price = typeof currentPrice === 'string' ? parseFloat(currentPrice) : Number(currentPrice || 0);
            
            // Geçerli bir fiyat değilse boş array döndür
            if (!price || isNaN(price) || price <= 0) {
                return [];
            }
            
            // Son 100 mumdan high ve low bul
            const symbol = coin.replace('/USDT', 'USDT');
            // Gerçek veriler için API'den al, şimdilik tahmin
            const recentHigh = price * 1.15; // %15 yukarı
            const recentLow = price * 0.85;   // %15 aşağı
            const range = recentHigh - recentLow;
            
            const fibLevels = [
                { level: '236', name: 'Fib 23.6%', price: recentHigh - (range * 0.236), color: '#ff6b6b', description: 'İlk geri çekilme seviyesi - Güçlü destek/direnç' },
                { level: '382', name: 'Fib 38.2%', price: recentHigh - (range * 0.382), color: '#ff9500', description: 'Orta seviye geri çekilme - Önemli seviye' },
                { level: '500', name: 'Fib 50.0%', price: recentHigh - (range * 0.500), color: '#ffd700', description: 'Merkez seviye - Çok güçlü destek/direnç' },
                { level: '618', name: 'Fib 61.8%', price: recentHigh - (range * 0.618), color: '#4ecdc4', description: 'Altın oran - En önemli Fibonacci seviyesi' },
                { level: '786', name: 'Fib 78.6%', price: recentHigh - (range * 0.786), color: '#9b59b6', description: 'Son geri çekilme seviyesi - Kritik' }
            ];
            
            return fibLevels;
        }

        // ===== İNDİKATÖR ÖZETİ HESAPLAMA (OPTİMİZE EDİLMİŞ) =====
        function calculateIndicatorSummary(indicators) {
            if (!indicators) {
                return { long: 0, neutral: 0, short: 0, total: 50, longDetails: [], neutralDetails: [], shortDetails: [] };
            }
            
            let long = 0, neutral = 0, short = 0;
            const longDetails = [], neutralDetails = [], shortDetails = [];
            
            // 90 İndikatör özeti varsa ÖNCE onu kullan (en önemli)
            if (indicators.indicators90) {
                const bullCount = indicators.indicators90.bull || 0;
                const bearCount = indicators.indicators90.bear || 0;
                const neutralCount = indicators.indicators90.neutral || 0;
                
                long += bullCount;
                short += bearCount;
                neutral += neutralCount;
                
                // 90 indikatörün detaylarını ekle (indicatorDetails varsa)
                if (indicators.indicators90.indicatorDetails) {
                    longDetails.push(...indicators.indicators90.indicatorDetails.long);
                    shortDetails.push(...indicators.indicators90.indicatorDetails.short);
                    neutralDetails.push(...indicators.indicators90.indicatorDetails.neutral);
                }
                if (indicators.indicators90.scores) {
                    if (indicators.indicators90.scores.trend) {
                        longDetails.push(`Trend: ${indicators.indicators90.scores.trend.bull || 0} Bull`);
                        shortDetails.push(`Trend: ${indicators.indicators90.scores.trend.bear || 0} Bear`);
                    }
                    if (indicators.indicators90.scores.momentum) {
                        longDetails.push(`Momentum: ${indicators.indicators90.scores.momentum.bull || 0} Bull`);
                        shortDetails.push(`Momentum: ${indicators.indicators90.scores.momentum.bear || 0} Bear`);
                    }
                    if (indicators.indicators90.scores.volume) {
                        longDetails.push(`Volume: ${indicators.indicators90.scores.volume.bull || 0} Bull`);
                        shortDetails.push(`Volume: ${indicators.indicators90.scores.volume.bear || 0} Bear`);
                    }
                    if (indicators.indicators90.scores.volatility) {
                        longDetails.push(`Volatility: ${indicators.indicators90.scores.volatility.bull || 0} Bull`);
                        shortDetails.push(`Volatility: ${indicators.indicators90.scores.volatility.bear || 0} Bear`);
                    }
                    if (indicators.indicators90.scores.institutional) {
                        longDetails.push(`Institutional: ${indicators.indicators90.scores.institutional.bull || 0} Bull`);
                        shortDetails.push(`Institutional: ${indicators.indicators90.scores.institutional.bear || 0} Bear`);
                    }
                }
                
                // Toplam premium indikatörlerden çıkan neutral
                const totalPremium = bullCount + bearCount + neutralCount;
                
                // Eğer premium indikatörler varsa, diğer analizleri de ekle ama toplam 50+ güvenilir indikatör
                const remainingNeeded = 50 - totalPremium;
                
                // RSI (1 indikatör)
                if (indicators.rsi !== undefined && remainingNeeded > 0) {
                    if (indicators.rsi < 30) { long++; longDetails.push('RSI Oversold'); }
                    else if (indicators.rsi > 70) { short++; shortDetails.push('RSI Overbought'); }
                    else { neutral++; neutralDetails.push('RSI Neutral'); }
                }
                
                // MACD (2 indikatör - MACD ve Histogram)
                if (indicators.macd !== undefined && indicators.macdSignal !== undefined && remainingNeeded > 0) {
                    if (indicators.macd > indicators.macdSignal && indicators.macdHistogram > 0) { 
                        long++; longDetails.push('MACD Bullish'); 
                    } else if (indicators.macd < indicators.macdSignal && indicators.macdHistogram < 0) { 
                        short++; shortDetails.push('MACD Bearish'); 
                    } else { 
                        neutral++; neutralDetails.push('MACD Neutral'); 
                    }
                }
                
                // Stochastic (2 indikatör)
                if (indicators.stochastic !== undefined && remainingNeeded > 0) {
                    if (indicators.stochastic < 20) { long++; longDetails.push('Stochastic Oversold'); }
                    else if (indicators.stochastic > 80) { short++; shortDetails.push('Stochastic Overbought'); }
                    else { neutral++; neutralDetails.push('Stochastic Neutral'); }
                }
                
                // ADX
                if (indicators.adx !== undefined && remainingNeeded > 0) {
                    if (indicators.adx > 25 && indicators.trend === 'UP') { long++; longDetails.push('ADX Strong UP'); }
                    else if (indicators.adx > 25 && indicators.trend === 'DOWN') { short++; shortDetails.push('ADX Strong DOWN'); }
                    else { neutral++; neutralDetails.push('ADX Weak'); }
                }
                
                // CVD
                if (indicators.cvdTrend && remainingNeeded > 0) {
                    if (indicators.cvdTrend === 'BULLISH') { long++; longDetails.push('CVD Bullish'); }
                    else if (indicators.cvdTrend === 'BEARISH') { short++; shortDetails.push('CVD Bearish'); }
                    else { neutral++; neutralDetails.push('CVD Neutral'); }
                }
                
                // Volume
                if (indicators.volumeRatio !== undefined && remainingNeeded > 0) {
                    if (indicators.volumeRatio > 1.5) { long++; longDetails.push('High Volume'); }
                    else if (indicators.volumeRatio < 0.5) { short++; shortDetails.push('Low Volume'); }
                    else { neutral++; neutralDetails.push('Normal Volume'); }
                }
            } else {
                // 90 indikatör yoksa, mevcut indikatörleri detaylı say
                // RSI
                if (indicators.rsi !== undefined) {
                    if (indicators.rsi < 30) { long++; longDetails.push('RSI Oversold'); }
                    else if (indicators.rsi > 70) { short++; shortDetails.push('RSI Overbought'); }
                    else { neutral++; neutralDetails.push('RSI Neutral'); }
                }
                
                // MACD
                if (indicators.macd !== undefined && indicators.macdSignal !== undefined) {
                    if (indicators.macd > indicators.macdSignal && indicators.macdHistogram > 0) { 
                        long++; longDetails.push('MACD Bullish'); 
                    } else if (indicators.macd < indicators.macdSignal && indicators.macdHistogram < 0) { 
                        short++; shortDetails.push('MACD Bearish'); 
                    } else { 
                        neutral++; neutralDetails.push('MACD Neutral'); 
                    }
                }
                
                // EMA Trend
                if (indicators.ema9 !== undefined && indicators.ema21 !== undefined) {
                    if (indicators.ema9 > indicators.ema21) { long++; longDetails.push('EMA 9>21'); }
                    else { short++; shortDetails.push('EMA 9<21'); }
                }
                
                if (indicators.ema21 !== undefined && indicators.ema50 !== undefined) {
                    if (indicators.ema21 > indicators.ema50) { long++; longDetails.push('EMA 21>50'); }
                    else { short++; shortDetails.push('EMA 21<50'); }
                }
                
                // Bollinger Bands
                if (indicators.bbLower !== undefined && indicators.bbUpper !== undefined) {
                    neutral++; neutralDetails.push('BB Analiz');
                }
                
                // Stochastic
                if (indicators.stochastic !== undefined) {
                    if (indicators.stochastic < 20) { long++; longDetails.push('Stochastic Oversold'); }
                    else if (indicators.stochastic > 80) { short++; shortDetails.push('Stochastic Overbought'); }
                    else { neutral++; neutralDetails.push('Stochastic Neutral'); }
                }
                
                // ADX
                if (indicators.adx !== undefined) {
                    if (indicators.adx > 25 && indicators.trend === 'UP') { long++; longDetails.push('ADX Strong UP'); }
                    else if (indicators.adx > 25 && indicators.trend === 'DOWN') { short++; shortDetails.push('ADX Strong DOWN'); }
                    else { neutral++; neutralDetails.push('ADX Weak'); }
                }
                
                // CVD
                if (indicators.cvdTrend) {
                    if (indicators.cvdTrend === 'BULLISH') { long++; longDetails.push('CVD Bullish'); }
                    else if (indicators.cvdTrend === 'BEARISH') { short++; shortDetails.push('CVD Bearish'); }
                    else { neutral++; neutralDetails.push('CVD Neutral'); }
                }
                
                // Volume
                if (indicators.volumeRatio !== undefined) {
                    if (indicators.volumeRatio > 1.5) { long++; longDetails.push('High Volume'); }
                    else if (indicators.volumeRatio < 0.5) { short++; shortDetails.push('Low Volume'); }
                    else { neutral++; neutralDetails.push('Normal Volume'); }
                }
            }
            
            // Toplam: Optimize edilmiş premium indikatör sayısı (50+ en güvenilir indikatör)
            const total = Math.max(50, long + neutral + short);
            
            return { long, neutral, short, total, longDetails, neutralDetails, shortDetails };
        }

        // ===== DİNAMİK FİYAT FORMATLAMA FONKSİYONU =====
        function formatPrice(price) {
            // Önce sayıya dönüştür
            const numPrice = typeof price === 'string' ? parseFloat(price) : Number(price);
            
            // Geçerli bir sayı değilse veya 0'dan küçükse
            if (!numPrice || isNaN(numPrice) || numPrice <= 0) return '0.00';
            
            // Fiyat değerine göre uygun ondalık basamak sayısını belirle
            if (numPrice >= 1) {
                return numPrice.toFixed(2);
            } else if (numPrice >= 0.1) {
                return numPrice.toFixed(3);
            } else if (numPrice >= 0.01) {
                return numPrice.toFixed(4);
            } else if (numPrice >= 0.001) {
                return numPrice.toFixed(5);
            } else if (numPrice >= 0.0001) {
                return numPrice.toFixed(6);
            } else if (numPrice >= 0.00001) {
                return numPrice.toFixed(7);
            } else {
                return numPrice.toFixed(8);
            }
        }

        // ===== HIZLI İNDİKATÖR HESAPLAMA (Performans için) =====
        async function calculateQuickIndicators(symbol, priceData) {
            try {
                // Sadece en gerekli indikatörleri hesapla
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=15m&limit=50`);
                const klines = await response.json();
                
                if (!klines || klines.length < 20) {
                    return {
                        rsi: 50,
                        macd: 0,
                        trend: priceData.change > 0 ? 'UP' : 'DOWN',
                        ema9: priceData.price,
                        ema21: priceData.price,
                        atr: priceData.price * 0.02
                    };
                }
                
                const closes = klines.map(k => parseFloat(k[4]));
                
                // Basit RSI
                let gains = 0, losses = 0;
                for (let i = Math.max(1, closes.length - 14); i < closes.length; i++) {
                    const change = closes[i] - closes[i - 1];
                    if (change > 0) gains += change;
                    else losses += Math.abs(change);
                }
                const rsi = losses === 0 ? 100 : 100 - (100 / (1 + (gains / 14) / (losses / 14)));
                
                return {
                    rsi: rsi || 50,
                    macd: 0,
                    trend: priceData.change > 0 ? 'UP' : 'DOWN',
                    ema9: closes[closes.length - 1],
                    ema21: closes[closes.length - 1],
                    atr: priceData.price * 0.02
                };
            } catch (error) {
                console.log('Hızlı indikatör hatası:', error);
                return {
                    rsi: 50,
                    macd: 0,
                    trend: 'NEUTRAL',
                    ema9: priceData.price,
                    ema21: priceData.price,
                    atr: priceData.price * 0.02
                };
            }
        }

        // ===== TRADE FORMAT KOPYALAMA FONKSİYONU =====
        function copyTradeFormat(coin, signal, entryPrice, stopLoss, tp1, tp2, tp3) {
            const coinLower = coin.toLowerCase().replace('/', '/');
            const entry = typeof entryPrice === 'number' ? entryPrice.toFixed(2) : parseFloat(entryPrice || 0).toFixed(2);
            const stop = typeof stopLoss === 'number' ? stopLoss.toFixed(2) : parseFloat(stopLoss || 0).toFixed(2);
            
            let tradeText = '';
            if (signal === 'long') {
                tradeText = `${coinLower}\nbuy ${entry}\nstop ${stop}`;
            } else if (signal === 'short') {
                tradeText = `${coinLower}\nsell ${entry}\nstop ${stop}`;
            } else {
                tradeText = `${coinLower}\nentry ${entry}\nstop ${stop}`;
            }
            
            // TP seviyelerini ekle (eğer varsa)
            if (tp1 && tp1 > 0) {
                const tp1Val = typeof tp1 === 'number' ? tp1.toFixed(2) : parseFloat(tp1).toFixed(2);
                tradeText += `\ntp1 ${tp1Val}`;
            }
            if (tp2 && tp2 > 0) {
                const tp2Val = typeof tp2 === 'number' ? tp2.toFixed(2) : parseFloat(tp2).toFixed(2);
                tradeText += `\ntp2 ${tp2Val}`;
            }
            if (tp3 && tp3 > 0) {
                const tp3Val = typeof tp3 === 'number' ? tp3.toFixed(2) : parseFloat(tp3).toFixed(2);
                tradeText += `\ntp3 ${tp3Val}`;
            }
            
            // Clipboard'a kopyala
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(tradeText).then(() => {
                    alert('✅ Trade formatı kopyalandı!\n\n' + tradeText);
                }).catch(err => {
                    // Fallback: textarea ile kopyala
                    fallbackCopyToClipboard(tradeText);
                });
            } else {
                // Fallback: textarea ile kopyala
                fallbackCopyToClipboard(tradeText);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                alert('✅ Trade formatı kopyalandı!\n\n' + text);
            } catch (err) {
                alert('❌ Kopyalama başarısız. Manuel kopyalayın:\n\n' + text);
            }
            document.body.removeChild(textArea);
        }

        // ===== TRADE SEVİYELERİ HESAPLAMA =====
        function calculateTradeLevels(coin, priceData, signal, indicators) {
            // Fiyatı sayıya dönüştür
            const entry = typeof priceData.price === 'string' ? parseFloat(priceData.price) : Number(priceData.price || 0);
            
            // Geçerli bir fiyat değilse boş array döndür
            if (!entry || isNaN(entry) || entry <= 0) {
                return [];
            }
            
            // ATR'yi doğru hesapla - array ise son değeri al, değilse hesapla
            let atr = entry * 0.02; // Varsayılan %2
            if (indicators?.atr) {
                if (Array.isArray(indicators.atr) && indicators.atr.length > 0) {
                    atr = indicators.atr[indicators.atr.length - 1];
                } else if (typeof indicators.atr === 'number') {
                    atr = indicators.atr;
                }
            }
            
            // ATR çok küçük veya çok büyükse mantıklı bir değere ayarla
            if (atr < entry * 0.005) atr = entry * 0.01; // Minimum %1
            if (atr > entry * 0.1) atr = entry * 0.05;   // Maximum %5
            
            const lang = currentLanguage === 'de' ? 'de' : 'tr';
            
            const levels = [];
            
            // Giriş seviyesi
            levels.push({
                type: 'entry',
                label: lang === 'de' ? 'Eintritt' : 'Giriş Seviyesi',
                price: entry,
                color: '#4ecdc4',
                distance: lang === 'de' ? 'Aktueller Preis' : 'Mevcut Fiyat',
                description: lang === 'de' ? 
                    'Ideal Einstiegspunkt für die Position' : 
                    'Pozisyon için ideal giriş seviyesi'
            });
            
            if (signal === 'long') {
                // LONG pozisyon seviyeleri
                levels.push({
                    type: 'tp',
                    label: lang === 'de' ? 'Take Profit 1' : 'Take Profit 1',
                    price: entry + (atr * 1.0),
                    color: '#4ecdc4',
                    distance: `+${((atr * 1.0 / entry) * 100).toFixed(2)}%`,
                    description: lang === 'de' ? 
                        'Erste Gewinnmitnahme - %50 pozisyon kapat' : 
                        'İlk kar alma - Pozisyonun %50\'sini kapat'
                });
                levels.push({
                    type: 'tp',
                    label: lang === 'de' ? 'Take Profit 2' : 'Take Profit 2',
                    price: entry + (atr * 2.0),
                    color: '#4ecdc4',
                    distance: `+${((atr * 2.0 / entry) * 100).toFixed(2)}%`,
                    description: lang === 'de' ? 
                        'Zweite Gewinnmitnahme - %30 pozisyon kapat' : 
                        'İkinci kar alma - Pozisyonun %30\'unu kapat'
                });
                levels.push({
                    type: 'tp',
                    label: lang === 'de' ? 'Take Profit 3' : 'Take Profit 3',
                    price: entry + (atr * 3.0),
                    color: '#4ecdc4',
                    distance: `+${((atr * 3.0 / entry) * 100).toFixed(2)}%`,
                    description: lang === 'de' ? 
                        'Finale Gewinnmitnahme - %20 pozisyon kapat' : 
                        'Son kar alma - Pozisyonun %20\'sini kapat'
                });
                levels.push({
                    type: 'sl',
                    label: lang === 'de' ? 'Stop Loss' : 'Stop Loss',
                    price: entry - (atr * 1.5),
                    color: '#ff6b6b',
                    distance: `-${((atr * 1.5 / entry) * 100).toFixed(2)}%`,
                    description: lang === 'de' ? 
                        'Risikomanagement - Tüm pozisyonu kapat' : 
                        'Risk yönetimi - Tüm pozisyonu kapat'
                });
            } else if (signal === 'short') {
                // SHORT pozisyon seviyeleri
                levels.push({
                    type: 'tp',
                    label: lang === 'de' ? 'Take Profit 1' : 'Take Profit 1',
                    price: entry - (atr * 1.0),
                    color: '#4ecdc4',
                    distance: `-${((atr * 1.0 / entry) * 100).toFixed(2)}%`,
                    description: lang === 'de' ? 
                        'Erste Gewinnmitnahme - %50 pozisyon kapat' : 
                        'İlk kar alma - Pozisyonun %50\'sini kapat'
                });
                levels.push({
                    type: 'tp',
                    label: lang === 'de' ? 'Take Profit 2' : 'Take Profit 2',
                    price: entry - (atr * 2.0),
                    color: '#4ecdc4',
                    distance: `-${((atr * 2.0 / entry) * 100).toFixed(2)}%`,
                    description: lang === 'de' ? 
                        'Zweite Gewinnmitnahme - %30 pozisyon kapat' : 
                        'İkinci kar alma - Pozisyonun %30\'unu kapat'
                });
                levels.push({
                    type: 'tp',
                    label: lang === 'de' ? 'Take Profit 3' : 'Take Profit 3',
                    price: entry - (atr * 3.0),
                    color: '#4ecdc4',
                    distance: `-${((atr * 3.0 / entry) * 100).toFixed(2)}%`,
                    description: lang === 'de' ? 
                        'Finale Gewinnmitnahme - %20 pozisyon kapat' : 
                        'Son kar alma - Pozisyonun %20\'sini kapat'
                });
                levels.push({
                    type: 'sl',
                    label: lang === 'de' ? 'Stop Loss' : 'Stop Loss',
                    price: entry + (atr * 1.5),
                    color: '#ff6b6b',
                    distance: `+${((atr * 1.5 / entry) * 100).toFixed(2)}%`,
                    description: lang === 'de' ? 
                        'Risikomanagement - Tüm pozisyonu kapat' : 
                        'Risk yönetimi - Tüm pozisyonu kapat'
                });
            }
            
            return levels;
        }

        // ===== DETAY HTML GENERATÖRLERİ =====
        function generateInstitutionalDetailHTML(institutional, lang) {
            return `
                <div style="padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 10px; margin-bottom: 15px;">
                    <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 10px;">🏢 Dark Pool Aktivität</div>
                    <div style="color: #fff; font-size: 1.2em; margin-bottom: 5px;">${institutional.darkPool?.status || 'N/A'}</div>
                    <div style="color: #aaa; font-size: 0.9em;">${lang === 'de' ? 'Block Trades:' : 'Blok İşlemler:'} ${institutional.darkPool?.blocks || 0}</div>
                </div>
                <div style="padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 10px;">
                    <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 10px;">📊 Order Flow</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div style="background: rgba(78, 205, 196, 0.2); padding: 10px; border-radius: 8px;">
                            <div style="color: #4ecdc4; font-size: 0.9em;">🟢 ${lang === 'de' ? 'Kaufdruck' : 'Alım Baskısı'}</div>
                            <div style="color: #fff; font-size: 1.1em; font-weight: bold;">${institutional.orderFlow?.buyPressure || 'N/A'}</div>
                        </div>
                        <div style="background: rgba(255, 107, 107, 0.2); padding: 10px; border-radius: 8px;">
                            <div style="color: #ff6b6b; font-size: 0.9em;">🔴 ${lang === 'de' ? 'Verkaufsdruck' : 'Satış Baskısı'}</div>
                            <div style="color: #fff; font-size: 1.1em; font-weight: bold;">${institutional.orderFlow?.sellPressure || 'N/A'}</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function generateWhaleDetailHTML(whales, lang) {
            return `
                <div style="padding: 15px; background: rgba(155, 89, 182, 0.1); border-radius: 10px; margin-bottom: 15px;">
                    <div style="color: #9b59b6; font-weight: bold; margin-bottom: 10px;">🐋 ${lang === 'de' ? 'Walaktivität' : 'Balina Aktivitesi'}</div>
                    <div style="color: #fff; font-size: 1.2em; margin-bottom: 5px;">${whales.activity?.status || 'N/A'}</div>
                    <div style="color: #aaa; font-size: 0.9em;">${lang === 'de' ? 'Gesamt Aufträge:' : 'Toplam Siparişler:'} ${whales.activity?.total || 0}</div>
                </div>
                <div style="padding: 15px; background: rgba(155, 89, 182, 0.1); border-radius: 10px;">
                    <div style="color: #9b59b6; font-weight: bold; margin-bottom: 10px;">💰 ${lang === 'de' ? 'Sentiment' : 'Sentiment'}</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div style="background: rgba(78, 205, 196, 0.2); padding: 10px; border-radius: 8px;">
                            <div style="color: #4ecdc4; font-size: 0.9em;">📈 ${lang === 'de' ? 'Akkumulation' : 'Birikim'}</div>
                            <div style="color: #fff; font-size: 1.1em; font-weight: bold;">${whales.sentiment?.accumulation || '0'}%</div>
                        </div>
                        <div style="background: rgba(255, 107, 107, 0.2); padding: 10px; border-radius: 8px;">
                            <div style="color: #ff6b6b; font-size: 0.9em;">📉 ${lang === 'de' ? 'Distribution' : 'Dağıtım'}</div>
                            <div style="color: #fff; font-size: 1.1em; font-weight: bold;">${whales.sentiment?.distribution || '0'}%</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function generateMarketMakerDetailHTML(marketMakers, lang) {
            return `
                <div style="padding: 15px; background: rgba(255, 149, 0, 0.1); border-radius: 10px; margin-bottom: 15px;">
                    <div style="color: #ff9500; font-weight: bold; margin-bottom: 10px;">📊 ${lang === 'de' ? 'Wyckoff Phase' : 'Wyckoff Fazı'}</div>
                    <div style="color: #fff; font-size: 1.2em; margin-bottom: 5px;">${marketMakers.wyckoff?.phase || 'N/A'}</div>
                    <div style="color: #aaa; font-size: 0.9em;">${lang === 'de' ? 'Position:' : 'Pozisyon:'} ${marketMakers.wyckoff?.position || '0'}%</div>
                </div>
                <div style="padding: 15px; background: rgba(255, 149, 0, 0.1); border-radius: 10px;">
                    <div style="color: #ff9500; font-weight: bold; margin-bottom: 10px;">📈 CVD Trend</div>
                    <div style="color: #fff; font-size: 1.1em;">${marketMakers.cvd?.trend || 'N/A'}</div>
                    <div style="color: #aaa; font-size: 0.9em; margin-top: 5px;">${lang === 'de' ? 'Wert:' : 'Değer:'} ${marketMakers.cvd?.value || '0'}</div>
                </div>
            `;
        }

        function generateTraderDetailHTML(traders, lang) {
            return `
                <div style="padding: 15px; background: rgba(103, 126, 234, 0.1); border-radius: 10px;">
                    <div style="color: #667eea; font-weight: bold; margin-bottom: 10px;">📊 ${lang === 'de' ? 'Volume Verteilung' : 'Volume Dağılımı'}</div>
                    <div style="margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="color: #ff9500;">👤 ${lang === 'de' ? 'Retail' : 'Retail'}</span>
                            <span style="color: #fff; font-weight: bold;">${traders.retailRatio || '0'}%</span>
                        </div>
                        <div style="background: rgba(255, 149, 0, 0.2); border-radius: 8px; overflow: hidden; height: 20px;">
                            <div style="height: 100%; background: #ff9500; width: ${traders.retailRatio || 0}%;"></div>
                        </div>
                    </div>
                    <div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="color: #4ecdc4;">🏢 ${lang === 'de' ? 'Institutional' : 'Kurumsal'}</span>
                            <span style="color: #fff; font-weight: bold;">${traders.ratio || '0'}%</span>
                        </div>
                        <div style="background: rgba(78, 205, 196, 0.2); border-radius: 8px; overflow: hidden; height: 20px;">
                            <div style="height: 100%; background: #4ecdc4; width: ${traders.ratio || 0}%;"></div>
                        </div>
                    </div>
                </div>
            `;
        }

        // ===== GELİŞTİRİLMİŞ AI ANALİZ (HABERLER, PİYASA, GENEL) =====
        async function analyzeCoinWithAIComprehensive(coin) {
            const buttonId = `modal-ai-button-${coin.replace('/', '-')}`;
            const loadingId = `modal-ai-loading-${coin.replace('/', '-')}`;
            const resultId = `modal-ai-result-${coin.replace('/', '-')}`;
            
            const button = document.getElementById(buttonId);
            const loading = document.getElementById(loadingId);
            const result = document.getElementById(resultId);
            
            if (!button || !loading || !result) return;
            
            button.disabled = true;
            button.style.opacity = '0.5';
            loading.style.display = 'block';
            result.style.display = 'none';
            
            try {
                const priceData = realPrices[coin];
                const indicators = technicalIndicators[coin];
                
                if (!priceData) {
                    throw new Error('Fiyat verisi bulunamadı');
                }
                
                // Geliştirilmiş AI analizi (haberler, piyasa, mumlar, genel)
                const comprehensiveAnalysis = await getAIAnalysisComprehensive(coin, priceData, indicators);
                
                result.innerHTML = `
                    <div style="background: rgba(0,0,0,0.5); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                        <div style="white-space: pre-wrap; line-height: 2; font-size: 1em; color: #fff; text-align: left;">
${comprehensiveAnalysis}
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <button onclick="sendDetailedTelegram('${coin}', ${JSON.stringify(priceData).replace(/"/g, '&quot;')}, ${JSON.stringify(indicators || {}).replace(/"/g, '&quot;')}, ${JSON.stringify(comprehensiveAnalysis).replace(/"/g, '&quot;').replace(/\n/g, '\\n')})" 
                                style="padding: 15px; background: linear-gradient(45deg, #25d366, #128c7e); 
                                       border: none; border-radius: 10px; cursor: pointer; font-weight: bold; 
                                       color: #fff; font-size: 1em;">
                            📱 Telegram'a Gönder (Detaylı)
                        </button>
                        <button onclick="navigator.clipboard.writeText(\`${comprehensiveAnalysis.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`) && alert('✅ Kopyalandı!')" 
                                style="padding: 15px; background: linear-gradient(45deg, #667eea, #764ba2); 
                                       border: none; border-radius: 10px; cursor: pointer; font-weight: bold; 
                                       color: #fff; font-size: 1em;">
                            📋 Analizi Kopyala
                        </button>
                    </div>
                `;
                
                result.style.display = 'block';
                loading.style.display = 'none';
                
            } catch (error) {
                console.error('Kapsamlı AI analiz hatası:', error);
                result.innerHTML = `
                    <div style="background: rgba(255, 0, 0, 0.2); padding: 20px; border-radius: 10px; color: #ff6b6b;">
                        <strong>❌ Hata:</strong> ${error.message}<br>
                        <button onclick="analyzeCoinWithAIComprehensive('${coin}')" 
                                style="margin-top: 10px; padding: 10px 20px; background: #4ecdc4; 
                                       border: none; border-radius: 8px; cursor: pointer; font-weight: bold; color: #000;">
                            🔄 Tekrar Dene
                        </button>
                    </div>
                `;
                result.style.display = 'block';
                loading.style.display = 'none';
                button.disabled = false;
                button.style.opacity = '1';
            }
        }

        // ===== GELİŞTİRİLMİŞ AI ANALİZ PROMPT (HABERLER, PİYASA, MUM, GENEL) =====
        async function getAIAnalysisComprehensive(coin, priceData, indicators) {
            const lang = currentLanguage === 'de' ? 'de' : 'tr';
            
            // Detaylı prompt oluştur
            const prompt = lang === 'de' ? `
Du bist ein professioneller Krypto-Analyst. Analysiere ${coin} UMFASSEND:

AKTUELLE SITUATION:
- Preis: $${priceData.price.toFixed(2)}
- 24h Änderung: ${priceData.change.toFixed(2)}%
- Volume: ${priceData.volume?.toFixed(0) || 'N/A'}
- High 24h: $${priceData.high24h?.toFixed(2) || 'N/A'}
- Low 24h: $${priceData.low24h?.toFixed(2) || 'N/A'}

TECHNISCHE INDIKATOREN:
${indicators ? `
- RSI: ${indicators.rsi?.toFixed(1) || 'N/A'}
- MACD: ${indicators.macd?.toFixed(2) || 'N/A'} (Signal: ${indicators.macdSignal?.toFixed(2) || 'N/A'})
- EMA Trend: ${indicators.trend || 'N/A'}
- Stochastic: ${indicators.stochastic?.toFixed(1) || 'N/A'} / ${indicators.stochasticD?.toFixed(1) || 'N/A'}
- ADX: ${indicators.adx?.toFixed(1) || 'N/A'}
- CVD Trend: ${indicators.cvdTrend || 'N/A'}
- Volume Ratio: ${indicators.volumeRatio?.toFixed(2) || 'N/A'}
- Order Blocks: ${indicators.orderBlocks || 0}
- Fair Value Gaps: ${indicators.fvg || 0}
` : 'Keine Indikatoren verfügbar'}

UMFASSENDE ANALYSE ERFORDERLICH:
1. **MARKT-UMLAGE**: Aktuelle Krypto-Markttrends, BTC-Korrelation, Gesamtmarkt-Sentiment
2. **NACHRICHTEN & FUNDAMENTALE**: Aktuelle Nachrichten, Entwicklungs-Updates, Partnerschaften, regulatorische Änderungen
3. **KERZEN-ANALYSE**: Muster, Formationen, Unterstützung/Widerstand, Momentum
4. **VOLUMEN-ANALYSE**: Ungewöhnliche Volumenbewegungen, Liquiditätsniveaus
5. **WHALE & INSTITUTIONAL**: Große Transaktionen, Smart Money Flow
6. **RISIKO-BEWERTUNG**: Liquidationsrisiken, Volatilität, technische Risiken
7. **TRADING-EMPFEHLUNG**: KLARE HANDLUNGSANWEISUNG (LONG/SHORT/WARTEN) mit Begründung
8. **EINTRITTS-PUNKTE**: Spezifische Preisniveaus für Einstieg
9. **RISIKO-MANAGEMENT**: Stop-Loss, Take-Profit, Position Sizing

Gib eine DETAILLIERTE, PROFESSIONELLE Analyse auf DEUTSCH.
Formatiere mit Emojis für bessere Lesbarkeit.
` : `
Sen profesyonel bir kripto analizcisin. ${coin} coin'ini KAPSAMLI olarak analiz et:

MEVCUT DURUM:
- Fiyat: $${priceData.price.toFixed(2)}
- 24s Değişim: ${priceData.change.toFixed(2)}%
- Volume: ${priceData.volume?.toFixed(0) || 'N/A'}
- 24s Yüksek: $${priceData.high24h?.toFixed(2) || 'N/A'}
- 24s Düşük: $${priceData.low24h?.toFixed(2) || 'N/A'}

TEKNİK İNDİKATÖRLER:
${indicators ? `
- RSI: ${indicators.rsi?.toFixed(1) || 'N/A'}
- MACD: ${indicators.macd?.toFixed(2) || 'N/A'} (Signal: ${indicators.macdSignal?.toFixed(2) || 'N/A'})
- EMA Trend: ${indicators.trend || 'N/A'}
- Stochastic: ${indicators.stochastic?.toFixed(1) || 'N/A'} / ${indicators.stochasticD?.toFixed(1) || 'N/A'}
- ADX: ${indicators.adx?.toFixed(1) || 'N/A'}
- CVD Trend: ${indicators.cvdTrend || 'N/A'}
- Volume Ratio: ${indicators.volumeRatio?.toFixed(2) || 'N/A'}
- Order Blocks: ${indicators.orderBlocks || 0}
- Fair Value Gaps: ${indicators.fvg || 0}
` : 'İndikatör verisi yok'}

KAPSAMLI ANALİZ İSTENİYOR:
1. **PİYASA ANALİZİ**: Genel kripto piyasa trendleri, BTC korelasyonu, genel piyasa sentimenti
2. **HABERLER & FUNDAMENTALLER**: Güncel haberler, geliştirme güncellemeleri, ortaklıklar, düzenlemeler
3. **MUM ANALİZİ**: Mum desenleri, formasyonlar, destek/direnç seviyeleri, momentum
4. **VOLUME ANALİZİ**: Olağandışı volume hareketleri, likidite seviyeleri
5. **BALİNA & KURUMSAL**: Büyük işlemler, Smart Money akışı
6. **RİSK DEĞERLENDİRMESİ**: Likidasyon riskleri, volatilite, teknik riskler
7. **TRADİNG ÖNERİSİ**: NET KARAR (LONG/SHORT/BEKLE) ve gerekçesi
8. **GİRİŞ SEVİYELERİ**: Spesifik fiyat seviyeleri için giriş noktaları
9. **RİSK YÖNETİMİ**: Stop-Loss, Take-Profit, pozisyon boyutlandırma

DETAYLI, PROFESYONEL bir analiz ver. Emojiler kullanarak daha okunabilir hale getir.
`;

            try {
                const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEYS.GROQ}`
                    },
                    body: JSON.stringify({
                        model: 'llama-3.3-70b-versatile',
                        messages: [
                            {
                                role: 'system',
                                content: lang === 'de' ? 
                                    'Du bist ein professioneller Krypto-Analyst mit Expertise in technischer Analyse, Fundamentalanalyse und Marktpsychologie.' :
                                    'Sen kripto piyasalarında teknik analiz, fundamental analiz ve piyasa psikolojisi konularında uzman bir analizcisin.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 4000,
                        temperature: 0.7
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(`Groq API hatası: ${data.error?.message || 'Bilinmeyen hata'}`);
                }
                
                return data.choices[0].message.content;
                
            } catch (error) {
                console.error('Groq API hatası:', error);
                throw error;
            }
        }

        window.addEventListener('load', showNewFeatures);

        // ===== TRADING TOOLS FONKSİYONLARI =====
        
        // Position Size Calculator
        function calculatePositionSize() {
            const portfolioValue = parseFloat(document.getElementById('portfolioValue').value) || 0;
            const riskPercent = parseFloat(document.getElementById('riskPercent').value) || 0;
            const entryPrice = parseFloat(document.getElementById('entryPrice').value) || 0;
            const stopLossPrice = parseFloat(document.getElementById('stopLossPrice').value) || 0;
            const leverage = parseFloat(document.getElementById('leverage').value) || 1;
            
            if (!portfolioValue || !riskPercent || !entryPrice || !stopLossPrice) {
                document.getElementById('positionSizeResult').innerHTML = 
                    '<div style="color: #ff6b6b;">⚠️ Lütfen tüm alanları doldurun!</div>';
                document.getElementById('positionSizeResult').style.display = 'block';
                return;
            }
            
            const riskAmount = portfolioValue * (riskPercent / 100);
            const priceRisk = Math.abs(entryPrice - stopLossPrice);
            const riskPerUnit = priceRisk;
            
            const positionSize = (riskAmount / riskPerUnit) * leverage;
            const positionValue = positionSize * entryPrice;
            const marginRequired = positionValue / leverage;
            
            const result = `
                <div style="color: #4ecdc4; font-weight: bold; font-size: 1.2em; margin-bottom: 15px;">💰 Position Size Sonuçları</div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                    <div style="padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 8px;">
                        <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">Pozisyon Boyutu</div>
                        <div style="color: #fff; font-size: 1.3em;">${positionSize.toFixed(4)}</div>
                    </div>
                    <div style="padding: 15px; background: rgba(255, 215, 0, 0.1); border-radius: 8px;">
                        <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">Pozisyon Değeri</div>
                        <div style="color: #fff; font-size: 1.3em;">$${positionValue.toFixed(2)}</div>
                    </div>
                    <div style="padding: 15px; background: rgba(255, 107, 107, 0.1); border-radius: 8px;">
                        <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 5px;">Gerekli Margin</div>
                        <div style="color: #fff; font-size: 1.3em;">$${marginRequired.toFixed(2)}</div>
                    </div>
                    <div style="padding: 15px; background: rgba(155, 89, 182, 0.1); border-radius: 8px;">
                        <div style="color: #9b59b6; font-weight: bold; margin-bottom: 5px;">Risk Miktarı</div>
                        <div style="color: #fff; font-size: 1.3em;">$${riskAmount.toFixed(2)}</div>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                    <div style="color: #aaa; font-size: 0.9em;">
                        <strong>Hesaplama Detayları:</strong><br>
                        • Risk Yüzdesi: %${riskPercent} ($${riskAmount.toFixed(2)})<br>
                        • Stop Loss Mesafesi: ${priceRisk.toFixed(2)} USDT (%${((priceRisk/entryPrice)*100).toFixed(2)})<br>
                        • Leverage: ${leverage}x<br>
                        • Her bir birim başına risk: $${riskPerUnit.toFixed(2)}
                    </div>
                </div>
            `;
            
            document.getElementById('positionSizeResult').innerHTML = result;
            document.getElementById('positionSizeResult').style.display = 'block';
        }

        // Risk/Reward Calculator
        function calculateRiskReward() {
            const entry = parseFloat(document.getElementById('rrEntry').value) || 0;
            const stopLoss = parseFloat(document.getElementById('rrStopLoss').value) || 0;
            const tp1 = parseFloat(document.getElementById('rrTP1').value) || 0;
            const tp2 = parseFloat(document.getElementById('rrTP2').value) || 0;
            const positionType = document.getElementById('positionType').value;
            
            if (!entry || !stopLoss || !tp1 || !tp2) {
                document.getElementById('riskRewardResult').innerHTML = 
                    '<div style="color: #ff6b6b;">⚠️ Lütfen tüm alanları doldurun!</div>';
                document.getElementById('riskRewardResult').style.display = 'block';
                return;
            }
            
            const risk = Math.abs(entry - stopLoss);
            const reward1 = positionType === 'long' ? tp1 - entry : entry - tp1;
            const reward2 = positionType === 'long' ? tp2 - entry : entry - tp2;
            
            const rr1 = reward1 / risk;
            const rr2 = reward2 / risk;
            
            const result = `
                <div style="color: #ffd700; font-weight: bold; font-size: 1.2em; margin-bottom: 15px;">📈 Risk/Reward Analizi</div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                    <div style="padding: 15px; background: rgba(255, 107, 107, 0.1); border-radius: 8px;">
                        <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 5px;">Risk</div>
                        <div style="color: #fff; font-size: 1.3em;">$${risk.toFixed(2)}</div>
                        <div style="color: #aaa; font-size: 0.8em;">${((risk/entry)*100).toFixed(2)}%</div>
                    </div>
                    <div style="padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 8px;">
                        <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">TP1 Reward</div>
                        <div style="color: #fff; font-size: 1.3em;">$${reward1.toFixed(2)}</div>
                        <div style="color: #4ecdc4; font-size: 0.8em;">RR: 1:${rr1.toFixed(2)}</div>
                    </div>
                    <div style="padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 8px;">
                        <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">TP2 Reward</div>
                        <div style="color: #fff; font-size: 1.3em;">$${reward2.toFixed(2)}</div>
                        <div style="color: #4ecdc4; font-size: 0.8em;">RR: 1:${rr2.toFixed(2)}</div>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                    <div style="color: ${rr1 >= 2 ? '#4ecdc4' : rr1 >= 1 ? '#ffd700' : '#ff6b6b'}; font-weight: bold; font-size: 1.1em;">
                        TP1 Risk/Reward: ${rr1 >= 2 ? '✅ İdeal' : rr1 >= 1 ? '⚠️ Makul' : '❌ Düşük'}
                    </div>
                    <div style="color: ${rr2 >= 3 ? '#4ecdc4' : rr2 >= 2 ? '#ffd700' : '#ff6b6b'}; font-weight: bold; font-size: 1.1em; margin-top: 10px;">
                        TP2 Risk/Reward: ${rr2 >= 3 ? '✅ Mükemmel' : rr2 >= 2 ? '⚠️ İyi' : '❌ Düşük'}
                    </div>
                </div>
            `;
            
            document.getElementById('riskRewardResult').innerHTML = result;
            document.getElementById('riskRewardResult').style.display = 'block';
        }

        // Leverage Calculator
        function calculateLeverage() {
            const margin = parseFloat(document.getElementById('marginAmount').value) || 0;
            const leverage = parseFloat(document.getElementById('leverageAmount').value) || 1;
            const entryPrice = parseFloat(document.getElementById('levEntryPrice').value) || 0;
            
            if (!margin || !leverage || !entryPrice) {
                document.getElementById('leverageResult').innerHTML = 
                    '<div style="color: #ff6b6b;">⚠️ Lütfen tüm alanları doldurun!</div>';
                document.getElementById('leverageResult').style.display = 'block';
                return;
            }
            
            const positionValue = margin * leverage;
            const positionSize = positionValue / entryPrice;
            
            // Liquidation hesaplaması (basitleştirilmiş)
            const liquidationPercent = 100 / leverage;
            const liquidationPriceLong = entryPrice * (1 - liquidationPercent / 100);
            const liquidationPriceShort = entryPrice * (1 + liquidationPercent / 100);
            
            const result = `
                <div style="color: #ff6b6b; font-weight: bold; font-size: 1.2em; margin-bottom: 15px;">⚡ Leverage Hesaplama</div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                    <div style="padding: 15px; background: rgba(255, 107, 107, 0.1); border-radius: 8px;">
                        <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 5px;">Pozisyon Değeri</div>
                        <div style="color: #fff; font-size: 1.3em;">$${positionValue.toFixed(2)}</div>
                    </div>
                    <div style="padding: 15px; background: rgba(255, 215, 0, 0.1); border-radius: 8px;">
                        <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">Pozisyon Boyutu</div>
                        <div style="color: #fff; font-size: 1.3em;">${positionSize.toFixed(4)}</div>
                    </div>
                    <div style="padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 8px;">
                        <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">Leverage</div>
                        <div style="color: #fff; font-size: 1.3em;">${leverage}x</div>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(255,107,107,0.1); border-radius: 8px;">
                    <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 10px;">⚠️ Likidasyon Seviyeleri</div>
                    <div style="color: #fff;">LONG Liquidation: $${liquidationPriceLong.toFixed(2)} (${liquidationPercent.toFixed(2)}% düşüş)</div>
                    <div style="color: #fff; margin-top: 5px;">SHORT Liquidation: $${liquidationPriceShort.toFixed(2)} (${liquidationPercent.toFixed(2)}% yükseliş)</div>
                    <div style="color: #aaa; font-size: 0.85em; margin-top: 10px;">
                        ⚠️ Yüksek leverage yüksek risk demektir! Dikkatli kullanın.
                    </div>
                </div>
            `;
            
            document.getElementById('leverageResult').innerHTML = result;
            document.getElementById('leverageResult').style.display = 'block';
        }

        // Correlation Analyzer
        async function analyzeCorrelation() {
            const baseCoin = document.getElementById('baseCoin').value;
            const compareCoinsText = document.getElementById('compareCoins').value;
            const period = parseInt(document.getElementById('correlationPeriod').value) || 30;
            
            if (!compareCoinsText) {
                document.getElementById('correlationResult').innerHTML = 
                    '<div style="color: #ff6b6b;">⚠️ Lütfen karşılaştırılacak coinleri girin!</div>';
                document.getElementById('correlationResult').style.display = 'block';
                return;
            }
            
            const compareCoins = compareCoinsText.split(',').map(c => c.trim());
            const resultDiv = document.getElementById('correlationResult');
            resultDiv.innerHTML = '<div style="color: #ffd700;">⏳ Korelasyon analizi hesaplanıyor...</div>';
            resultDiv.style.display = 'block';
            
            try {
                // Basitleştirilmiş korelasyon hesaplaması (gerçek veri yerine örnek)
                // Gerçek implementasyonda CoinGecko API'den fiyat verileri çekilmeli
                let resultHTML = `
                    <div style="color: #9b59b6; font-weight: bold; font-size: 1.2em; margin-bottom: 15px;">🔗 Korelasyon Analizi</div>
                    <div style="margin-bottom: 15px; color: #aaa;">
                        Ana Coin: <strong style="color: #fff;">${baseCoin}</strong><br>
                        Periyot: <strong style="color: #fff;">${period} gün</strong>
                    </div>
                `;
                
                for (const coin of compareCoins) {
                    if (!realPrices[coin]) {
                        resultHTML += `
                            <div style="padding: 10px; background: rgba(255,107,107,0.1); border-radius: 8px; margin-bottom: 10px;">
                                <div style="color: #ff6b6b;">⚠️ ${coin} için veri bulunamadı</div>
                            </div>
                        `;
                        continue;
                    }
                    
                    // Basit korelasyon hesaplaması (örnek)
                    const baseChange = realPrices[baseCoin]?.change || 0;
                    const coinChange = realPrices[coin]?.change || 0;
                    
                    // Basit korelasyon skoru
                    const correlation = Math.abs(baseChange - coinChange) < 2 ? 0.8 : 
                                      Math.abs(baseChange - coinChange) < 5 ? 0.5 : 0.2;
                    
                    const correlationColor = correlation > 0.7 ? '#4ecdc4' : correlation > 0.4 ? '#ffd700' : '#ff6b6b';
                    const correlationText = correlation > 0.7 ? 'Yüksek' : correlation > 0.4 ? 'Orta' : 'Düşük';
                    
                    resultHTML += `
                        <div style="padding: 15px; background: rgba(155,89,182,0.1); border-radius: 8px; margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="color: #fff; font-weight: bold; font-size: 1.1em;">${coin}</div>
                                    <div style="color: #aaa; font-size: 0.9em;">Değişim: ${coinChange.toFixed(2)}%</div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: ${correlationColor}; font-size: 1.5em; font-weight: bold;">${(correlation * 100).toFixed(0)}%</div>
                                    <div style="color: ${correlationColor}; font-size: 0.9em;">${correlationText} Korelasyon</div>
                                </div>
                            </div>
                            <div style="margin-top: 10px; background: rgba(0,0,0,0.2); border-radius: 5px; overflow: hidden; height: 10px;">
                                <div style="height: 100%; background: linear-gradient(90deg, ${correlationColor}, ${correlationColor}88); width: ${correlation * 100}%; transition: width 0.5s;"></div>
                            </div>
                        </div>
                    `;
                }
                
                resultDiv.innerHTML = resultHTML;
            } catch (error) {
                resultDiv.innerHTML = `<div style="color: #ff6b6b;">❌ Hata: ${error.message}</div>`;
            }
        }

        // Portfolio Tracker
        let portfolioData = JSON.parse(localStorage.getItem('portfolioData') || '[]');
        
        function addToPortfolio() {
            const coin = document.getElementById('portfolioCoin').value.trim();
            const amount = parseFloat(document.getElementById('portfolioAmount').value) || 0;
            const entryPrice = parseFloat(document.getElementById('portfolioEntry').value) || 0;
            const positionType = document.getElementById('portfolioType').value;
            
            if (!coin || !amount || !entryPrice) {
                alert('⚠️ Lütfen tüm alanları doldurun!');
                return;
            }
            
            const entry = {
                coin,
                amount,
                entryPrice,
                positionType,
                timestamp: new Date().toISOString()
            };
            
            portfolioData.push(entry);
            localStorage.setItem('portfolioData', JSON.stringify(portfolioData));
            
            updatePortfolioList();
            
            // Formu temizle
            document.getElementById('portfolioCoin').value = '';
            document.getElementById('portfolioAmount').value = '';
            document.getElementById('portfolioEntry').value = '';
        }
        
        function updatePortfolioList() {
            const container = document.getElementById('portfolioList');
            if (!container) return;
            
            if (portfolioData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #aaa; padding: 40px;">Portföyünüzde henüz pozisyon yok</div>';
                return;
            }
            
            let totalPnL = 0;
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">';
            
            portfolioData.forEach((entry, index) => {
                const currentPrice = realPrices[entry.coin]?.price || entry.entryPrice;
                const pnl = entry.positionType === 'long' 
                    ? (currentPrice - entry.entryPrice) * entry.amount
                    : (entry.entryPrice - currentPrice) * entry.amount;
                const pnlPercent = entry.positionType === 'long'
                    ? ((currentPrice - entry.entryPrice) / entry.entryPrice) * 100
                    : ((entry.entryPrice - currentPrice) / entry.entryPrice) * 100;
                
                totalPnL += pnl;
                
                const pnlColor = pnl >= 0 ? '#4ecdc4' : '#ff6b6b';
                const pnlIcon = pnl >= 0 ? '📈' : '📉';
                
                html += `
                    <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; border: 2px solid ${pnlColor}33;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <div style="color: #fff; font-weight: bold; font-size: 1.2em;">${entry.coin}</div>
                                <div style="color: #aaa; font-size: 0.9em;">${entry.positionType === 'long' ? '🟢 LONG' : '🔴 SHORT'}</div>
                            </div>
                            <button onclick="removePortfolioEntry(${index})" style="padding: 5px 10px; background: rgba(255,107,107,0.2); border: 1px solid #ff6b6b; border-radius: 5px; color: #ff6b6b; cursor: pointer;">🗑️</button>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <div style="color: #aaa; font-size: 0.85em;">Miktar: <span style="color: #fff;">${entry.amount}</span></div>
                            <div style="color: #aaa; font-size: 0.85em;">Entry: <span style="color: #fff;">$${entry.entryPrice.toFixed(2)}</span></div>
                            <div style="color: #aaa; font-size: 0.85em;">Güncel: <span style="color: #fff;">$${currentPrice.toFixed(2)}</span></div>
                        </div>
                        <div style="padding: 10px; background: rgba(${pnl >= 0 ? '78, 205, 196' : '255, 107, 107'}, 0.1); border-radius: 8px;">
                            <div style="color: ${pnlColor}; font-weight: bold; font-size: 1.1em;">
                                ${pnlIcon} P&L: $${pnl.toFixed(2)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            html += `
                <div style="margin-top: 20px; padding: 20px; background: rgba(255,215,0,0.1); border-radius: 10px; text-align: center;">
                    <div style="color: #ffd700; font-weight: bold; font-size: 1.3em; margin-bottom: 5px;">Toplam P&L</div>
                    <div style="color: ${totalPnL >= 0 ? '#4ecdc4' : '#ff6b6b'}; font-size: 2em; font-weight: bold;">
                        ${totalPnL >= 0 ? '📈' : '📉'} $${totalPnL.toFixed(2)}
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        function removePortfolioEntry(index) {
            portfolioData.splice(index, 1);
            localStorage.setItem('portfolioData', JSON.stringify(portfolioData));
            updatePortfolioList();
        }
        
        // Sayfa yüklendiğinde portföyü güncelle
        if (document.getElementById('portfolioList')) {
            updatePortfolioList();
            setInterval(updatePortfolioList, 30000); // Her 30 saniyede bir güncelle
        }

        // ===== COIN ARAMA FONKSİYONLARI =====
        let allAvailableCoins = [];
        let coinSearchCache = {};
        let searchTimeout = null;
        
        // Debounce arama - performans için
        function debounceSearch(value) {
            if (searchTimeout) clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                filterCoinSearch(value);
            }, 300);
        }

        // CoinGecko'dan coin arama fonksiyonu
        async function searchCoinGecko(query) {
            try {
                const searchQuery = query.toLowerCase().trim();
                
                // Önce tam eşleşme ara
                let response = await fetch(`https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(searchQuery)}`);
                let data = await response.json();
                
                if (data && data.coins && data.coins.length > 0) {
                    // Önce tam sembol eşleşmesine bak
                    const exactMatch = data.coins.find(c => c.symbol.toLowerCase() === searchQuery || c.id.toLowerCase() === searchQuery);
                    if (exactMatch) {
                        return [{
                            id: exactMatch.id,
                            symbol: exactMatch.symbol.toUpperCase(),
                            name: exactMatch.name,
                            market_cap_rank: exactMatch.market_cap_rank || 9999
                        }];
                    }
                    
                    // En popüler coin'leri döndür (ilk 20)
                    return data.coins.slice(0, 20).map(coin => ({
                        id: coin.id,
                        symbol: coin.symbol.toUpperCase(),
                        name: coin.name,
                        market_cap_rank: coin.market_cap_rank || 9999
                    })).sort((a, b) => (a.market_cap_rank || 9999) - (b.market_cap_rank || 9999));
                }
                
                // Sonuç yoksa, farklı bir arama terimiyle tekrar dene (sadece sembol kısmı)
                const symbolOnly = searchQuery.replace(/usdt|btc|eth/i, '').trim();
                if (symbolOnly && symbolOnly !== searchQuery) {
                    response = await fetch(`https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(symbolOnly)}`);
                    data = await response.json();
                    if (data && data.coins && data.coins.length > 0) {
                        return data.coins.slice(0, 10).map(coin => ({
                            id: coin.id,
                            symbol: coin.symbol.toUpperCase(),
                            name: coin.name,
                            market_cap_rank: coin.market_cap_rank || 9999
                        })).sort((a, b) => (a.market_cap_rank || 9999) - (b.market_cap_rank || 9999));
                    }
                }
                
                return [];
            } catch (error) {
                console.log('⚠️ CoinGecko arama hatası:', error);
                return [];
            }
        }

        // CoinGecko'dan fiyat verisi al
        async function getCoinGeckoPrice(coinId) {
            try {
                const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true&include_last_updated_at=true`);
                const data = await response.json();
                
                if (data && data[coinId]) {
                    const priceData = data[coinId];
                    return {
                        price: priceData.usd || 0,
                        change: priceData.usd_24h_change || 0,
                        volume: 0,
                        high24h: 0,
                        low24h: 0,
                        source: 'COINGECKO'
                    };
                }
                return null;
            } catch (error) {
                console.log('⚠️ CoinGecko fiyat hatası:', error);
                return null;
            }
        }

        // Tüm mevcut coinleri yükle - CoinGecko entegrasyonu ile
        async function loadAllAvailableCoins() {
            try {
                const coinSet = new Set();
                
                // Önce CoinGecko'dan popüler coinleri al (en hızlı yöntem)
                try {
                    const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=1&sparkline=false');
                    const data = await response.json();
                    
                    if (data && Array.isArray(data)) {
                        data.forEach(coin => {
                            if (coin.symbol) {
                                coinSet.add(`${coin.symbol.toUpperCase()}/USDT`);
                            }
                        });
                        console.log(`✅ CoinGecko: ${data.length} popüler coin eklendi`);
                    }
                } catch (error) {
                    console.log('⚠️ CoinGecko API hatası:', error);
                }
                
                // Sonra 7 borsadan coinleri al
                const exchanges = ['binance', 'okx', 'bybit', 'mexc', 'kucoin', 'gate', 'huobi'];
                
                for (const exchange of exchanges) {
                    try {
                        let symbols = [];
                        
                        if (exchange === 'binance') {
                            const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                            const data = await response.json();
                            symbols = data.symbols
                                .filter(s => s.quoteAsset === 'USDT' && s.status === 'TRADING')
                                .map(s => `${s.baseAsset}/USDT`);
                        } else if (exchange === 'okx') {
                            const response = await fetch('https://www.okx.com/api/v5/public/instruments?instType=SPOT');
                            const data = await response.json();
                            symbols = (data.data || [])
                                .filter(s => s.settleCcy === 'USDT' && s.state === 'live')
                                .map(s => s.instId.replace('-', '/'));
                        } else if (exchange === 'bybit') {
                            const response = await fetch('https://api.bybit.com/v5/market/instruments-info?category=spot');
                            const data = await response.json();
                            symbols = (data.result?.list || [])
                                .filter(s => s.quoteCoin === 'USDT' && s.status === 'Trading')
                                .map(s => `${s.baseCoin}/USDT`);
                        } else if (exchange === 'mexc') {
                            const response = await fetch('https://api.mexc.com/api/v3/exchangeInfo');
                            const data = await response.json();
                            symbols = (data.symbols || [])
                                .filter(s => s.symbol.endsWith('USDT') && s.status === 'ENABLED')
                                .map(s => s.symbol.replace('USDT', '/USDT'));
                        } else if (exchange === 'kucoin') {
                            const response = await fetch('https://api.kucoin.com/api/v1/symbols');
                            const data = await response.json();
                            symbols = (data.data || [])
                                .filter(s => s.quoteCurrency === 'USDT' && s.enableTrading)
                                .map(s => `${s.baseCurrency}/USDT`);
                        } else if (exchange === 'gate') {
                            const response = await fetch('https://api.gateio.ws/api/v4/spot/currency_pairs');
                            const data = await response.json();
                            symbols = (data || [])
                                .filter(s => s.quote === 'USDT' && s.trade_status === 'tradable')
                                .map(s => `${s.base}/USDT`);
                        } else if (exchange === 'huobi') {
                            try {
                                const response = await fetch('https://api.huobi.pro/v1/common/symbols');
                                const data = await response.json();
                                symbols = (data.data || [])
                                    .filter(s => s.quoteCurrency === 'usdt' && s.state === 'online')
                                    .map(s => `${s.baseCurrency.toUpperCase()}/USDT`);
                            } catch (e) {
                                symbols = [];
                            }
                        }
                        
                        symbols.forEach(coin => coinSet.add(coin.toUpperCase()));
                        console.log(`✅ ${exchange}: ${symbols.length} coin eklendi`);
                    } catch (error) {
                        console.log(`⚠️ ${exchange} API hatası:`, error);
                    }
                }
                
                // RealPrices'dan da ekle
                Object.keys(realPrices).forEach(coin => coinSet.add(coin.toUpperCase()));
                
                allAvailableCoins = Array.from(coinSet).sort();
                console.log(`✅ Toplam ${allAvailableCoins.length} coin yüklendi`);
                
                return allAvailableCoins;
            } catch (error) {
                console.error('❌ Coin yükleme hatası:', error);
                return Object.keys(realPrices).map(c => c.toUpperCase());
            }
        }

        // Coin arama filtreleme - CoinGecko entegrasyonu ile (Optimize edilmiş)
        async function filterCoinSearch(query) {
            const resultsDiv = document.getElementById('coinSearchResults');
            if (!resultsDiv) return;
            
            if (!query || query.length < 2) {
                resultsDiv.style.display = 'none';
                return;
            }
            
            const queryUpper = query.toUpperCase().trim();
            
            // Cache kontrolü - performans için
            if (coinSearchCache[queryUpper]) {
                resultsDiv.innerHTML = coinSearchCache[queryUpper];
                resultsDiv.style.display = 'block';
                return;
            }
            
            // Önce local cache'den ara (daha hızlı)
            let matches = allAvailableCoins
                .filter(coin => {
                    const baseCoin = coin.replace('/USDT', '').toUpperCase();
                    return baseCoin === queryUpper || 
                           baseCoin.startsWith(queryUpper) || 
                           coin.includes(queryUpper);
                })
                .slice(0, 10);
            
            // Eğer local'de bulunamadıysa CoinGecko'dan ara (lazy)
            if (matches.length === 0 && query.length >= 3) {
                try {
                    resultsDiv.innerHTML = '<div style="padding: 15px; text-align: center; color: #4ecdc4;">🔍 CoinGecko\'dan aranıyor...</div>';
                    resultsDiv.style.display = 'block';
                    
                    const geckoResults = await searchCoinGecko(query);
                    
                    if (geckoResults && geckoResults.length > 0) {
                        matches = geckoResults.map(coin => `${coin.symbol}/USDT`);
                        
                        // CoinGecko sonuçlarını göster
                        resultsDiv.innerHTML = geckoResults.map(coin => `
                            <div onclick="searchCoinGeckoSelected('${coin.id}', '${coin.symbol.toUpperCase()}')" 
                                 style="padding: 12px; margin: 5px 0; background: rgba(78, 205, 196, 0.15); 
                                        border-radius: 8px; cursor: pointer; transition: all 0.3s;
                                        border: 2px solid rgba(78, 205, 196, 0.4);"
                                 onmouseover="this.style.background='rgba(78, 205, 196, 0.25)'; this.style.transform='translateX(5px)'"
                                 onmouseout="this.style.background='rgba(78, 205, 196, 0.15)'; this.style.transform='translateX(0)'">
                                <div style="font-weight: bold; color: #4ecdc4; font-size: 1.1em;">${coin.symbol.toUpperCase()}/USDT</div>
                                <div style="font-size: 0.85em; color: #aaa; margin-top: 3px;">${coin.name}</div>
                                ${coin.market_cap_rank ? `<div style="font-size: 0.75em; color: #ffd700; margin-top: 3px;">📊 Market Cap Rank: #${coin.market_cap_rank}</div>` : ''}
                                <div style="font-size: 0.7em; color: #4ecdc4; margin-top: 5px;">✨ CoinGecko'dan bulundu - Tıklayarak analiz et</div>
                            </div>
                        `).join('');
                        resultsDiv.style.display = 'block';
                        return;
                    }
                } catch (error) {
                    console.log('CoinGecko arama hatası:', error);
                }
            }
            
            if (matches.length === 0) {
                resultsDiv.innerHTML = '<div style="padding: 15px; text-align: center; color: #ff6b6b;">❌ Coin bulunamadı. CoinGecko\'dan aranıyor...</div>';
                resultsDiv.style.display = 'block';
                
                // Son çare: CoinGecko'dan direkt ara
                setTimeout(async () => {
                    try {
                        const geckoResults = await searchCoinGecko(query);
                        if (geckoResults && geckoResults.length > 0) {
                            resultsDiv.innerHTML = geckoResults.map(coin => `
                                <div onclick="searchCoinGeckoSelected('${coin.id}', '${coin.symbol.toUpperCase()}')" 
                                     style="padding: 12px; margin: 5px 0; background: rgba(78, 205, 196, 0.15); 
                                            border-radius: 8px; cursor: pointer; transition: all 0.3s;
                                            border: 2px solid rgba(78, 205, 196, 0.4);"
                                     onmouseover="this.style.background='rgba(78, 205, 196, 0.25)'; this.style.transform='translateX(5px)'"
                                     onmouseout="this.style.background='rgba(78, 205, 196, 0.15)'; this.style.transform='translateX(0)'">
                                    <div style="font-weight: bold; color: #4ecdc4; font-size: 1.1em;">${coin.symbol.toUpperCase()}/USDT</div>
                                    <div style="font-size: 0.85em; color: #aaa; margin-top: 3px;">${coin.name}</div>
                                    <div style="font-size: 0.7em; color: #4ecdc4; margin-top: 5px;">✨ CoinGecko - Tıklayarak analiz et</div>
                                </div>
                            `).join('');
                        } else {
                            resultsDiv.innerHTML = '<div style="padding: 15px; text-align: center; color: #ff6b6b;">❌ Coin bulunamadı. Lütfen farklı bir arama terimi deneyin.</div>';
                        }
                    } catch (error) {
                        resultsDiv.innerHTML = '<div style="padding: 15px; text-align: center; color: #ff6b6b;">❌ Arama hatası. Lütfen tekrar deneyin.</div>';
                    }
                }, 500);
                return;
            }
            
            const html = matches.map(coin => `
                <div onclick="selectCoinFromSearch('${coin}')" 
                     style="padding: 12px; margin: 5px 0; background: rgba(255,215,0,0.1); 
                            border-radius: 8px; cursor: pointer; transition: all 0.3s;
                            border: 1px solid rgba(255,215,0,0.2);"
                     onmouseover="this.style.background='rgba(255,215,0,0.2)'; this.style.transform='translateX(5px)'"
                     onmouseout="this.style.background='rgba(255,215,0,0.1)'; this.style.transform='translateX(0)'">
                    <div style="font-weight: bold; color: #ffd700;">${coin}</div>
                    ${realPrices[coin] ? `<div style="font-size: 0.85em; color: #aaa;">$${formatPrice(realPrices[coin].price)}</div>` : ''}
                </div>
            `).join('');
            
            // Cache'e kaydet
            coinSearchCache[queryUpper] = html;
            
            resultsDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }

        // CoinGecko'dan seçilen coin'i analiz et
        async function searchCoinGeckoSelected(coinGeckoId, coinSymbol) {
            document.getElementById('coinSearchInput').value = coinSymbol;
            document.getElementById('coinSearchResults').style.display = 'none';
            
            let coinFormat = `${coinSymbol}/USDT`;
            
            // Results tab'ına geç
            switchTab('results');
            
            // Loading göster
            const loadingSection = document.getElementById('loadingSection');
            if (loadingSection) {
                loadingSection.style.display = 'block';
            }
            
            try {
                // ÖNCE borsalardan ara - daha güvenilir
                let priceData = await searchExchangeForCoin(coinFormat);
                let foundExchange = null;
                
                // Borsalarda bulunamadıysa CoinGecko'dan dene
                if (!priceData) {
                    priceData = await getCoinGeckoPrice(coinGeckoId);
                    if (priceData) {
                        foundExchange = 'COINGECKO';
                        console.log(`✅ CoinGecko'dan bulundu: ${coinSymbol}`);
                    }
                } else {
                    foundExchange = 'BORSALAR';
                }
                
                // Hala bulunamadıysa, CoinGecko'dan alınan coin ID ile farklı sembolleri dene
                if (!priceData && coinGeckoId) {
                    try {
                        // CoinGecko'dan coin detaylarını al
                        const geckoDetailResponse = await fetch(`https://api.coingecko.com/api/v3/coins/${coinGeckoId}?localization=false&tickers=true`);
                        const geckoDetail = await geckoDetailResponse.json();
                        
                        if (geckoDetail && geckoDetail.tickers) {
                            // Ticker'larda USDT çifti ara
                            const usdtTicker = geckoDetail.tickers.find(t => 
                                t.target && t.target.toUpperCase() === 'USDT' && 
                                t.last && t.last > 0
                            );
                            
                            if (usdtTicker && usdtTicker.last) {
                                priceData = {
                                    price: parseFloat(usdtTicker.last),
                                    change: 0,
                                    volume: parseFloat(usdtTicker.volume || 0),
                                    high24h: parseFloat(usdtTicker.last) * 1.05,
                                    low24h: parseFloat(usdtTicker.last) * 0.95,
                                    source: usdtTicker.market?.name || 'COINGECKO'
                                };
                                coinFormat = `${coinSymbol}/USDT`;
                                foundExchange = 'COINGECKO_TICKER';
                                console.log(`✅ CoinGecko ticker'dan bulundu: ${coinSymbol}`);
                            }
                        }
                    } catch (geckoDetailError) {
                        console.log('CoinGecko detay hatası:', geckoDetailError);
                    }
                }
                
                if (!priceData) {
                    throw new Error(`❌ "${coinSymbol}" coin'i için fiyat verisi alınamadı.`);
                }
                
                // RealPrices'a ekle
                realPrices[coinFormat] = priceData;
                
                // Coin'i allAvailableCoins'e ekle
                if (!allAvailableCoins.includes(coinFormat.toUpperCase())) {
                    allAvailableCoins.push(coinFormat.toUpperCase());
                    allAvailableCoins.sort();
                }
                
                // Teknik analiz hesapla
                try {
                    await calculateTechnicalIndicatorsForCoin(coinFormat, coinFormat.replace('/USDT', 'USDT'));
                } catch (techError) {
                    console.warn('⚠️ Teknik analiz hatası, devam ediliyor:', techError);
                }
                
                // Sonuçları göster
                const indicators = technicalIndicators[coinFormat] || {};
                
                // priceData'yı kontrol et ve eksik alanları doldur
                if (!priceData.change && priceData.change !== 0) {
                    priceData.change = 0;
                }
                if (!priceData.volume) priceData.volume = 0;
                if (!priceData.high24h) priceData.high24h = priceData.price * 1.05;
                if (!priceData.low24h) priceData.low24h = priceData.price * 0.95;
                
                const score = calculateRealScore(coinFormat, priceData);
                const signal = determineRealSignal(coinFormat, priceData, score);
                
                // Modal'ı aç (hata kontrolü ile)
                try {
                showCoinDetailModal(coinFormat, priceData, score, signal, indicators);
                } catch (modalError) {
                    console.error('❌ Modal açma hatası:', modalError);
                    alert(`✅ Coin bulundu: ${coinFormat}\n⚠️ Ancak detay görüntüleme sırasında bir hata oluştu. Lütfen tekrar deneyin.`);
                }
                
                // Loading'i gizle
                if (loadingSection) {
                    loadingSection.style.display = 'none';
                }
                
            } catch (error) {
                console.error('❌ CoinGecko analiz hatası:', error);
                alert(`❌ ${error.message}`);
                
                if (loadingSection) {
                    loadingSection.style.display = 'none';
                }
            }
        }

        // Borsalardan coin ara (helper function) - Geliştirilmiş
        async function searchExchangeForCoin(coinSymbol) {
            const baseSymbol = coinSymbol.replace('/USDT', '').replace('/usdt', '').toUpperCase();
            const exchanges = [
                { name: 'BINANCE', symbol: `${baseSymbol}USDT`, api: 'https://api.binance.com/api/v3/ticker/24hr?symbol=' },
                { name: 'OKX', symbol: `${baseSymbol}-USDT`, api: 'https://www.okx.com/api/v5/market/ticker?instId=' },
                { name: 'BYBIT', symbol: `${baseSymbol}USDT`, api: 'https://api.bybit.com/v5/market/tickers?category=spot&symbol=' },
                { name: 'MEXC', symbol: `${baseSymbol}_USDT`, api: 'https://api.mexc.com/api/v3/ticker/24hr?symbol=' },
                { name: 'KUCOIN', symbol: `${baseSymbol}-USDT`, api: 'https://api.kucoin.com/api/v1/market/stats?symbol=' },
                { name: 'GATE', symbol: `${baseSymbol}_USDT`, api: 'https://api.gateio.ws/api/v4/spot/tickers?currency_pair=' },
                { name: 'HUOBI', symbol: `${baseSymbol}usdt`.toLowerCase(), api: 'https://api.huobi.pro/market/detail/merged?symbol=' }
            ];
            
            for (const exchange of exchanges) {
                try {
                    const response = await fetch(`${exchange.api}${exchange.symbol}`);
                    if (!response.ok) continue;
                    
                    const data = await response.json();
                    
                    if (exchange.name === 'OKX') {
                        if (data.data && data.data[0] && data.data[0].last) {
                        return {
                                price: parseFloat(data.data[0].last),
                                change: parseFloat(data.data[0].lastPx || 0),
                                volume: parseFloat(data.data[0].vol24h || data.data[0].volCcy24h || 0),
                                high24h: parseFloat(data.data[0].high24h || 0),
                                low24h: parseFloat(data.data[0].low24h || 0),
                                source: exchange.name
                            };
                        }
                    } else if (exchange.name === 'BYBIT') {
                        if (data.result && data.result.list && data.result.list.length > 0 && data.result.list[0].lastPrice) {
                            const ticker = data.result.list[0];
                            return {
                                price: parseFloat(ticker.lastPrice),
                                change: parseFloat(ticker.price24hPcnt || 0) * 100,
                                volume: parseFloat(ticker.volume24h || 0),
                                high24h: parseFloat(ticker.highPrice24h || 0),
                                low24h: parseFloat(ticker.lowPrice24h || 0),
                                source: exchange.name
                            };
                        }
                    } else if (exchange.name === 'KUCOIN') {
                        if (data.data && data.data.last) {
                            return {
                                price: parseFloat(data.data.last),
                                change: parseFloat(data.data.changeRate || 0) * 100,
                                volume: parseFloat(data.data.vol || 0),
                                high24h: parseFloat(data.data.high || 0),
                                low24h: parseFloat(data.data.low || 0),
                                source: exchange.name
                            };
                        }
                    } else if (exchange.name === 'GATE') {
                        if (data && data.length > 0 && data[0].last) {
                            return {
                                price: parseFloat(data[0].last),
                                change: parseFloat(data[0].change_percentage || 0),
                                volume: parseFloat(data[0].base_volume || 0),
                                high24h: parseFloat(data[0].high_24h || 0),
                                low24h: parseFloat(data[0].low_24h || 0),
                                source: exchange.name
                            };
                        }
                    } else if (exchange.name === 'HUOBI') {
                        if (data && data.status === 'ok' && data.tick && data.tick.close) {
                            return {
                                price: parseFloat(data.tick.close),
                                change: 0,
                                volume: parseFloat(data.tick.vol || 0),
                                high24h: parseFloat(data.tick.high || 0),
                                low24h: parseFloat(data.tick.low || 0),
                                source: exchange.name
                            };
                        }
                    } else {
                        // Binance ve MEXC için standart format
                        if (data) {
                            const price = parseFloat(data.lastPrice || data.price || 0);
                            if (price > 0) {
                                return {
                                    price: price,
                                    change: parseFloat(data.priceChangePercent || data.priceChange || 0),
                            volume: parseFloat(data.volume || 0),
                                    high24h: parseFloat(data.highPrice || data.high24h || price * 1.05),
                                    low24h: parseFloat(data.lowPrice || data.low24h || price * 0.95),
                            source: exchange.name
                        };
                            }
                        }
                    }
                } catch (error) {
                    continue;
                }
            }
            return null;
        }

        // Arama sonuçlarından coin seçme
        function selectCoinFromSearch(coin) {
            document.getElementById('coinSearchInput').value = coin;
            document.getElementById('coinSearchResults').style.display = 'none';
            searchAndAnalyzeCoin();
        }

        // Coin arama ve analiz - Geliştirilmiş versiyon
        async function searchAndAnalyzeCoin(event) {
            if (event) event.preventDefault();
            
            const searchInput = document.getElementById('coinSearchInput');
            const query = (searchInput?.value || '').trim().toUpperCase();
            
            if (!query) {
                alert('⚠️ Lütfen bir coin adı girin!');
                return;
            }
            
            // Coin formatını düzelt (USDT ekle)
            let coinSymbol = query;
            if (!coinSymbol.includes('/')) {
                coinSymbol = `${coinSymbol}/USDT`;
            }
            
            // Results tab'ına geç
            switchTab('results', event);
            
            // Loading göster
            const loadingSection = document.getElementById('loadingSection');
            if (loadingSection) {
                loadingSection.style.display = 'block';
            }
            
            try {
                let priceData = null;
                let foundExchange = null;
                
                // Önce tüm borsalardan coin'i ara
                const exchanges = [
                    { name: 'BINANCE', symbol: coinSymbol.replace('/USDT', 'USDT'), api: 'https://api.binance.com/api/v3/ticker/24hr?symbol=' },
                    { name: 'OKX', symbol: coinSymbol.replace('/USDT', '-USDT'), api: 'https://www.okx.com/api/v5/market/ticker?instId=' },
                    { name: 'BYBIT', symbol: coinSymbol.replace('/USDT', 'USDT'), api: 'https://api.bybit.com/v5/market/tickers?category=spot&symbol=' },
                    { name: 'MEXC', symbol: coinSymbol.replace('/USDT', '_USDT'), api: 'https://api.mexc.com/api/v3/ticker/24hr?symbol=' },
                    { name: 'KUCOIN', symbol: coinSymbol.replace('/USDT', '-USDT'), api: 'https://api.kucoin.com/api/v1/market/stats?symbol=' },
                    { name: 'GATE', symbol: coinSymbol.replace('/USDT', '_USDT'), api: 'https://api.gateio.ws/api/v4/spot/tickers?currency_pair=' },
                    { name: 'HUOBI', symbol: coinSymbol.replace('/USDT', 'usdt').toLowerCase(), api: 'https://api.huobi.pro/market/detail/merged?symbol=' }
                ];
                
                // Her borsadan dene
                for (const exchange of exchanges) {
                    try {
                        let response;
                        let data;
                        
                        if (exchange.name === 'OKX') {
                            response = await fetch(`${exchange.api}${exchange.symbol}`);
                            const result = await response.json();
                            if (result.data && result.data[0]) {
                                data = result.data[0];
                                priceData = {
                                    price: parseFloat(data.last),
                                    change: parseFloat(data.lastPx) || 0,
                                    volume: parseFloat(data.vol24h || data.volCcy24h) || 0,
                                    high24h: parseFloat(data.high24h) || 0,
                                    low24h: parseFloat(data.low24h) || 0,
                                    source: exchange.name
                                };
                                foundExchange = exchange.name;
                                break;
                            }
                        } else if (exchange.name === 'BYBIT') {
                            response = await fetch(`${exchange.api}${exchange.symbol}`);
                            const result = await response.json();
                            if (result.result && result.result.list && result.result.list.length > 0) {
                                data = result.result.list[0];
                                priceData = {
                                    price: parseFloat(data.lastPrice),
                                    change: parseFloat(data.price24hPcnt) * 100 || 0,
                                    volume: parseFloat(data.volume24h) || 0,
                                    high24h: parseFloat(data.highPrice24h) || 0,
                                    low24h: parseFloat(data.lowPrice24h) || 0,
                                    source: exchange.name
                                };
                                foundExchange = exchange.name;
                                break;
                            }
                        } else if (exchange.name === 'KUCOIN') {
                            response = await fetch(`${exchange.api}${exchange.symbol}`);
                            const result = await response.json();
                            if (result.data) {
                                data = result.data;
                                priceData = {
                                    price: parseFloat(data.last),
                                    change: parseFloat(data.changeRate) * 100 || 0,
                                    volume: parseFloat(data.vol) || 0,
                                    high24h: parseFloat(data.high) || 0,
                                    low24h: parseFloat(data.low) || 0,
                                    source: exchange.name
                                };
                                foundExchange = exchange.name;
                                break;
                            }
                        } else if (exchange.name === 'GATE') {
                            response = await fetch(`${exchange.api}${exchange.symbol}`);
                            const result = await response.json();
                            if (result && result.length > 0) {
                                data = result[0];
                                priceData = {
                                    price: parseFloat(data.last),
                                    change: parseFloat(data.change_percentage) || 0,
                                    volume: parseFloat(data.base_volume) || 0,
                                    high24h: parseFloat(data.high_24h) || 0,
                                    low24h: parseFloat(data.low_24h) || 0,
                                    source: exchange.name
                                };
                                foundExchange = exchange.name;
                                break;
                            }
                        } else if (exchange.name === 'HUOBI') {
                            response = await fetch(`${exchange.api}${exchange.symbol}`);
                            const result = await response.json();
                            if (result && result.status === 'ok' && result.tick) {
                                data = result.tick;
                                priceData = {
                                    price: parseFloat(data.close),
                                    change: 0,
                                    volume: parseFloat(data.vol) || 0,
                                    high24h: parseFloat(data.high) || 0,
                                    low24h: parseFloat(data.low) || 0,
                                    source: exchange.name
                                };
                                foundExchange = exchange.name;
                                break;
                            }
                        } else {
                            // Binance ve MEXC için standart format
                            response = await fetch(`${exchange.api}${exchange.symbol}`);
                            data = await response.json();
                            
                            // Binance API response: {lastPrice, priceChangePercent, volume, highPrice, lowPrice}
                            // MEXC API response: {lastPrice, priceChangePercent, volume, highPrice, lowPrice}
                            if (data) {
                                const price = parseFloat(data.lastPrice || data.price || 0);
                                if (price > 0) {
                                priceData = {
                                        price: price,
                                        change: parseFloat(data.priceChangePercent || data.priceChange || 0),
                                    volume: parseFloat(data.volume || 0),
                                        high24h: parseFloat(data.highPrice || data.high24h || price * 1.05),
                                        low24h: parseFloat(data.lowPrice || data.low24h || price * 0.95),
                                    source: exchange.name
                                };
                                foundExchange = exchange.name;
                                break;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`⚠️ ${exchange.name} denemesi başarısız:`, error);
                        continue;
                    }
                }
                
                // Eğer hiçbir borsada bulunamadıysa, CoinGecko'dan ara
                if (!priceData) {
                    try {
                        // CoinGecko'dan coin ara
                        const geckoResults = await searchCoinGecko(query.replace('/USDT', ''));
                        
                        if (geckoResults && geckoResults.length > 0) {
                            // İlk sonucu kullan
                            const bestMatch = geckoResults[0];
                            priceData = await getCoinGeckoPrice(bestMatch.id);
                            
                            if (priceData) {
                                foundExchange = 'COINGECKO';
                                // Coin formatını güncelle
                                coinSymbol = `${bestMatch.symbol.toUpperCase()}/USDT`;
                                console.log(`✅ CoinGecko'dan bulundu: ${bestMatch.name} (${bestMatch.symbol})`);
                            }
                        }
                    } catch (geckoError) {
                        console.log('CoinGecko denemesi başarısız:', geckoError);
                    }
                    
                    // Hala bulunamadıysa hata ver
                    if (!priceData) {
                        throw new Error(`❌ "${query}" coin'i hiçbir borsada veya CoinGecko'da bulunamadı. Lütfen coin adını kontrol edin veya farklı bir arama terimi deneyin.`);
                    }
                }
                
                // RealPrices'a ekle
                realPrices[coinSymbol] = priceData;
                
                // Coin'i allAvailableCoins'e ekle (yoksa)
                if (!allAvailableCoins.includes(coinSymbol.toUpperCase())) {
                    allAvailableCoins.push(coinSymbol.toUpperCase());
                    allAvailableCoins.sort();
                }
                
                // Teknik analiz hesapla - Lazy loading (sadece modal açıldığında hesaplanır)
                // Hızlı göstermek için sadece temel indikatörleri hesapla
                try {
                    let symbol = coinSymbol.replace('/USDT', 'USDT');
                    if (foundExchange === 'OKX' || foundExchange === 'KUCOIN') {
                        symbol = coinSymbol.replace('/USDT', '-USDT');
                    } else if (foundExchange === 'MEXC' || foundExchange === 'GATE') {
                        symbol = coinSymbol.replace('/USDT', '_USDT');
                    }
                    
                    // Sadece hızlı indikatörleri hesapla (RSI, MACD, temel trend)
                    if (!technicalIndicators[coinSymbol]) {
                        // Basit hesaplama - ağır hesaplamaları modal açıldığında yapılacak
                        const quickIndicators = await calculateQuickIndicators(symbol, priceData);
                        technicalIndicators[coinSymbol] = quickIndicators;
                    }
                } catch (techError) {
                    console.warn('⚠️ Teknik analiz hatası, devam ediliyor:', techError);
                    // Varsayılan indikatörler
                    if (!technicalIndicators[coinSymbol]) {
                        technicalIndicators[coinSymbol] = {};
                    }
                }
                
                // Sonuçları göster
                const indicators = technicalIndicators[coinSymbol] || {};
                
                // priceData'yı kontrol et ve eksik alanları doldur
                if (!priceData.change && priceData.change !== 0) {
                    priceData.change = 0;
                }
                if (!priceData.volume) priceData.volume = 0;
                if (!priceData.high24h) priceData.high24h = priceData.price * 1.05;
                if (!priceData.low24h) priceData.low24h = priceData.price * 0.95;
                
                const score = calculateRealScore(coinSymbol, priceData);
                const signal = determineRealSignal(coinSymbol, priceData, score);
                
                // Modal'ı aç (hata kontrolü ile)
                try {
                showCoinDetailModal(coinSymbol, priceData, score, signal, indicators);
                } catch (modalError) {
                    console.error('❌ Modal açma hatası:', modalError);
                    alert(`✅ Coin bulundu: ${coinSymbol}\n⚠️ Ancak detay görüntüleme sırasında bir hata oluştu. Lütfen tekrar deneyin.`);
                }
                
                // Sonuçları results container'a ekle
                const resultsContainer = signal === 'long' ? 
                    document.getElementById('longResultsContainer') : 
                    signal === 'short' ? 
                    document.getElementById('shortResultsContainer') : 
                    document.getElementById('waitResultsContainer');
                
                if (resultsContainer) {
                    const card = createCompleteResultCard(coinSymbol, priceData, score, signal);
                    resultsContainer.innerHTML = card;
                    
                    // Sonuçları göstermek için section'ları aç
                    if (signal === 'long') {
                        document.getElementById('longSection')?.style.setProperty('display', 'block');
                        document.getElementById('longCount').textContent = '1 Coin';
                    } else if (signal === 'short') {
                        document.getElementById('shortSection')?.style.setProperty('display', 'block');
                        document.getElementById('shortCount').textContent = '1 Coin';
                    }
                }
                
                // Başarı mesajı
                console.log(`✅ Coin bulundu: ${coinSymbol} - ${foundExchange}`);
                
                // Loading'i gizle
                if (loadingSection) {
                    loadingSection.style.display = 'none';
                }
                
                // Arama sonuçlarını gizle
                const searchResults = document.getElementById('coinSearchResults');
                if (searchResults) {
                    searchResults.style.display = 'none';
                }
                
            } catch (error) {
                console.error('❌ Coin analiz hatası:', error);
                alert(`❌ ${error.message}`);
                
                if (loadingSection) {
                    loadingSection.style.display = 'none';
                }
            }
        }

        // Tek bir coin için teknik analiz
        async function calculateTechnicalIndicatorsForCoin(coin, symbol) {
            try {
                const timeframe = selectedTimeframe || '15m';
                const interval = timeframe === '1m' ? '1m' : 
                               timeframe === '5m' ? '5m' :
                               timeframe === '15m' ? '15m' :
                               timeframe === '30m' ? '30m' :
                               timeframe === '1h' ? '1h' :
                               timeframe === '4h' ? '4h' : '1d';
                
                // Binance'den klines al
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=200`);
                const klines = await response.json();
                
                if (!klines || klines.length < 50) {
                    throw new Error('Yeterli mum verisi yok');
                }
                
                const volumes = klines.map(k => parseFloat(k[5]));
                const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
                const currentVolume = volumes[volumes.length - 1];
                
                // Tüm indikatörleri hesapla
                const indicators90 = calculate90Indicators(klines, currentVolume, avgVolume);
                const institutional = analyzeInstitutional(klines, volumes);
                const whales = analyzeWhales(klines, avgVolume);
                const marketMakers = analyzeMarketMakers(klines);
                const smartMoneyConcepts = analyzeSmartMoneyConcepts(klines);
                const traders = analyzeTraders(klines, institutional);
                const pumpDump = analyzePumpDump(klines, calculateBollingerBands(klines.map(k => parseFloat(k[4])), 20), currentVolume, avgVolume);
                const trendBreak = analyzeTrendBreak(klines);
                const peaksAndDips = analyzePeaksAndDips(klines);
                
                // === YENİ: GELİŞMİŞ KURUMSAL TEKNİKLER ===
                const orderFlowDelta = calculateOrderFlowDelta(klines);
                const liquiditySweeps = detectLiquiditySweeps(klines);
                const premiumDiscount = calculatePremiumDiscountZones(klines);
                const multiTimeframe = calculateMultiTimeframeConfluence(coin, realPrices[coin] || { price: 0, change: 0 });
                const advancedVolumeProfile = calculateAdvancedVolumeProfile(klines);
                const sessionAnalysis = analyzeTradingSessions();
                const marketCorrelation = await analyzeMarketCorrelation(coin, realPrices[coin] || { price: 0, change: 0 });
                const tapeReading = analyzeTapeReading(klines);
                
                // Temel indikatörler
                const closes = klines.map(k => parseFloat(k[4]));
                const highs = klines.map(k => parseFloat(k[2]));
                const lows = klines.map(k => parseFloat(k[3]));
                
                technicalIndicators[coin] = {
                    ...calculateTechnicalIndicatorsBasic(klines, highs, lows, closes, volumes),
                    indicators90,
                    institutional,
                    whales,
                    marketMakers,
                    smartMoneyConcepts,
                    traders,
                    pumpDump,
                    trendBreak,
                    peaksAndDips,
                    // Yeni gelişmiş teknikler
                    orderFlowDelta,
                    liquiditySweeps,
                    premiumDiscount,
                    multiTimeframe,
                    advancedVolumeProfile,
                    sessionAnalysis,
                    marketCorrelation,
                    tapeReading
                };
                
            } catch (error) {
                console.error(`❌ ${coin} teknik analiz hatası:`, error);
                throw error;
            }
        }

        // Temel teknik indikatörler
        function calculateTechnicalIndicatorsBasic(klines, highs, lows, closes, volumes) {
            const rsi = calculateRSI(closes, 14);
            const macd = calculateMACD(closes);
            const ema9 = calculateEMA(closes, 9);
            const ema21 = calculateEMA(closes, 21);
            const ema50 = calculateEMA(closes, 50);
            const bb = calculateBollingerBands(closes, 20);
            const stoch = calculateStochastic(highs, lows, closes, 14);
            const adx = calculateADX(highs, lows, closes, 14);
            const atr = calculateATR(highs, lows, closes, 14);
            const vwap = calculateVWAP(klines);
            const cvd = calculateCVD(klines);
            
            return {
                rsi: rsi[rsi.length - 1],
                macd: macd.macd[macd.macd.length - 1],
                macdSignal: macd.signal[macd.signal.length - 1],
                macdHistogram: macd.histogram[macd.histogram.length - 1],
                ema9: ema9[ema9.length - 1],
                ema21: ema21[ema21.length - 1],
                ema50: ema50[ema50.length - 1],
                trend: ema9[ema9.length - 1] > ema50[ema50.length - 1] ? 'UP' : 'DOWN',
                bbUpper: bb.upper[bb.upper.length - 1],
                bbMiddle: bb.middle[bb.middle.length - 1],
                bbLower: bb.lower[bb.lower.length - 1],
                stochastic: stoch.k[stoch.k.length - 1],
                stochasticD: stoch.d[stoch.d.length - 1],
                adx: adx[adx.length - 1],
                atr: atr,
                vwap: vwap[vwap.length - 1],
                cvdTrend: cvd > 0 ? 'BULLISH' : cvd < 0 ? 'BEARISH' : 'NEUTRAL',
                volumeRatio: volumes[volumes.length - 1] / (volumes.reduce((a, b) => a + b, 0) / volumes.length)
            };
        }

        // Sayfa yüklendiğinde tüm coinleri yükle
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => loadAllAvailableCoins(), 2000);
        });
    </script>

    <!-- Detaylı Coin Analiz Modal -->
    <div id="coinDetailModal" class="coin-detail-modal">
        <div class="modal-content" id="coinDetailContent">
            <!-- İçerik JavaScript ile doldurulacak -->
        </div>
    </div>
</body>
</html>


